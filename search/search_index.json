{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Power Balance Models # Power Balance Models (PBM) is a framework developed by UKAEA for assessment of net power production by different Tokamak fusion reactor designs. The simulations are built around models constructed using Modelica for power generation and consumption systems. The included API allows users to configure and launch simulation runs quickly and easily either via a command line interface (CLI) or through scripts. This site provides information on the models contained within PBM and how to use the framework in your own analysis, as well as guidelines towards contributing to the project. You can download the latest release on the project repository . Current Development Team # Alexander Petrov Jack Acres Kristian Zar\u0119bski Tom Stroud Taiwo Owoeye Vignesh Laksharam Steven Wray Christie Finlay *-** Timothy Jackson ** Previous Development Team Members # Marius Cannon Nicholas Brewer Rhys Griffiths Sophie Gribben * Katherine Rochford * Samuel Stewart * * 2020 summer student ** 2021 summer student","title":"Home"},{"location":"#power-balance-models","text":"Power Balance Models (PBM) is a framework developed by UKAEA for assessment of net power production by different Tokamak fusion reactor designs. The simulations are built around models constructed using Modelica for power generation and consumption systems. The included API allows users to configure and launch simulation runs quickly and easily either via a command line interface (CLI) or through scripts. This site provides information on the models contained within PBM and how to use the framework in your own analysis, as well as guidelines towards contributing to the project. You can download the latest release on the project repository .","title":"Power Balance Models"},{"location":"#current-development-team","text":"Alexander Petrov Jack Acres Kristian Zar\u0119bski Tom Stroud Taiwo Owoeye Vignesh Laksharam Steven Wray Christie Finlay *-** Timothy Jackson **","title":"Current Development Team"},{"location":"#previous-development-team-members","text":"Marius Cannon Nicholas Brewer Rhys Griffiths Sophie Gribben * Katherine Rochford * Samuel Stewart * * 2020 summer student ** 2021 summer student","title":"Previous Development Team Members"},{"location":"API/advanced_api/","text":"Interactive Session # For inspection of outputs, and dynamically setting up and running of simulations it is recommended that the API be launched within an ipython session. This allows the user to create an instance of PowerBalance and modify/inspect parameters on the fly. Installing iPython # ipython can be installed using pip : pip install ipython Example # In [1]: from power_balance.core import PowerBalance In [2]: p = PowerBalance() Initialising session, please wait... In [3]: p.run_simulation('output_dir') stdout | info | ... loading \"data\" from \"/home/user/PowerBalanceModels/power_balance/profiles/mat_profile_files/ThermalPowerOut.mat\" stdout | info | ... loading \"data\" from \"/home/user/PowerBalanceModels/power_balance/profiles/mat_profile_files/currentCS.mat\" ... In [4]: p.get_parameters() Out[4]: {'Tokamak.Interdependencies.air_gas_power.compFeedGas.compressorWork': 485.8823529411765, 'Tokamak.Interdependencies.air_gas_power.compRegenGas.absorbentRequired': 381.9861818181818, 'Tokamak.Interdependencies.air_gas_power.compRegenGas.compressorWork': 227.0588235294117, ... In [5]: p.set_parameter_value('tokamak.interdependencies.magnetpower.magnetpf1.numcoils', 10) Out[5]: 10 In [6]: p.modifiable_parameters() Out[6]: ['tokamak.interdependencies.primarycoolanttype', 'tokamak.interdependencies.secondarycoolanttype', 'tokamak.interdependencies.ratiotype', 'tokamak.interdependencies.systempressure', ... In [7]: p.clear_cache() Parameter setting All parameters including those that are protected are listed via PowerBalance.get_parameters() for the purposes of inspection. Only modifiable parameters can be updated, these are listed by running PowerBalance.modifiable_parameters() . PyDelica cache On Windows temporary directories are not deleted on log out. PyDelica uses these to perform builds and store the model binaries. It is therefore recommended unless using PowerBalance as a context manager you should run the clear_cache method to wipe these build folders upon completion.","title":"Interactive Session"},{"location":"API/advanced_api/#interactive-session","text":"For inspection of outputs, and dynamically setting up and running of simulations it is recommended that the API be launched within an ipython session. This allows the user to create an instance of PowerBalance and modify/inspect parameters on the fly.","title":"Interactive Session"},{"location":"API/advanced_api/#installing-ipython","text":"ipython can be installed using pip : pip install ipython","title":"Installing iPython"},{"location":"API/advanced_api/#example","text":"In [1]: from power_balance.core import PowerBalance In [2]: p = PowerBalance() Initialising session, please wait... In [3]: p.run_simulation('output_dir') stdout | info | ... loading \"data\" from \"/home/user/PowerBalanceModels/power_balance/profiles/mat_profile_files/ThermalPowerOut.mat\" stdout | info | ... loading \"data\" from \"/home/user/PowerBalanceModels/power_balance/profiles/mat_profile_files/currentCS.mat\" ... In [4]: p.get_parameters() Out[4]: {'Tokamak.Interdependencies.air_gas_power.compFeedGas.compressorWork': 485.8823529411765, 'Tokamak.Interdependencies.air_gas_power.compRegenGas.absorbentRequired': 381.9861818181818, 'Tokamak.Interdependencies.air_gas_power.compRegenGas.compressorWork': 227.0588235294117, ... In [5]: p.set_parameter_value('tokamak.interdependencies.magnetpower.magnetpf1.numcoils', 10) Out[5]: 10 In [6]: p.modifiable_parameters() Out[6]: ['tokamak.interdependencies.primarycoolanttype', 'tokamak.interdependencies.secondarycoolanttype', 'tokamak.interdependencies.ratiotype', 'tokamak.interdependencies.systempressure', ... In [7]: p.clear_cache() Parameter setting All parameters including those that are protected are listed via PowerBalance.get_parameters() for the purposes of inspection. Only modifiable parameters can be updated, these are listed by running PowerBalance.modifiable_parameters() . PyDelica cache On Windows temporary directories are not deleted on log out. PyDelica uses these to perform builds and store the model binaries. It is therefore recommended unless using PowerBalance as a context manager you should run the clear_cache method to wipe these build folders upon completion.","title":"Example"},{"location":"API/api_overview/","text":"Power Balance Models API # Overview # The Application Programming Interface (API) provides commands for accessing features within Power Balance Models (PBM). The core part of the API is the PowerBalance class which holds session properties such as the model list and model parameters. Parameters can be set manually by the user within scripts, are read from input parameter files or default values are used. The interaction with Modelica source files is handled by PyDelica which is itself an API to the OpenModelica Compiler (OMC). When a model run is completed copies of the inputs are stored alongside the output data for reproducibility. graph LR; subgraph Inputs; subgraph TOML Files; A[API Config] B[Parameter Values] C[Simulation Config] end subgraph Profiles; D[Current Profiles] E[Heat Profiles] end subgraph Models; G[Modelica Files] end end subgraph PyDelica; ZP[PyDelica Input Files] ZW[C Code] ZK[Model Binaries] ZI[XML Input File] ZP --OMC--> ZI end subgraph Power Balance Models; G --> ZP --OMC--> ZW --Make--> ZK G --> H[Models List] B --> I[Parameters] DA[Validator] D --> I E --> I C --> DA --> J[Configuration] A --> DA H -.Extract.->I O[Simulation] I --> ZI J --> O ZI --> O ZK --> O end subgraph User Interface; K[Add Model] L[Set Parameter] M[Get Parameter] VA[View Plots] K --> ZP L --> I I --> M end subgraph Outputs; P[Dataframe] Q[Power Plots] O --> P O --> Q AA[Heat Profiles] BB[Current Profiles] I --> AA I --> BB R[Parameters] S[API Config] T[Simulation Config] I --> R J --> S J --> T end BR[PBMBrowser] Q --> BR VA --> BR PyDelica # PBM uses PyDelica to compile, configure and run a Modelica model. At its base the process consists of five main steps: Create a PyDelica session and hand it the Modelica files for the models required. The models will firstly be converted into C source files and relevant build files. The model will then be compiled using the created Makefile. As compiled models rely on a created XML file to set initial parameter values, PyDelica allows the user to set these conditions by modifying this XML file directly. Run the binary when a simulation is requested. Why not OMPython? For those who have researched the topic you will already know that OpenModelica already comes with a Python interface, OMPython . However rather than being a direct API for OpenModelica itself, it acts as an API for OMShell which in turn runs OpenModelica. In order to do this it has to run on a server (i.e. ZMQ session). Whilst writing Unit Tests for Power Balance Models using OMPython it was discovered that this server approach is very taxing on CPU especially when you want to run multiple models in tandem as each would create a new OMC session. When OMC is run in script generation mode an XML file is also created from which the compiled binary reads parameter values and simulation options. As Python is able to edit XML files PyDelica instead updates parameter values directly. Furthermore OMPython does not throw exceptions when the OpenModelica backend fails, instead the errors are largely lost or not even returned meaning any scripts continue to run even after model compilation/run failure. Validation # In the case of the API configuration , simulation configuration and plasma scenario files a validation check is performed on the inputs. These checks are performed using the pydantic Python module which compares the inputs to a defined schema containing rules. Further information these schemas can be found here .","title":"Overview"},{"location":"API/api_overview/#power-balance-models-api","text":"","title":"Power Balance Models API"},{"location":"API/api_overview/#overview","text":"The Application Programming Interface (API) provides commands for accessing features within Power Balance Models (PBM). The core part of the API is the PowerBalance class which holds session properties such as the model list and model parameters. Parameters can be set manually by the user within scripts, are read from input parameter files or default values are used. The interaction with Modelica source files is handled by PyDelica which is itself an API to the OpenModelica Compiler (OMC). When a model run is completed copies of the inputs are stored alongside the output data for reproducibility. graph LR; subgraph Inputs; subgraph TOML Files; A[API Config] B[Parameter Values] C[Simulation Config] end subgraph Profiles; D[Current Profiles] E[Heat Profiles] end subgraph Models; G[Modelica Files] end end subgraph PyDelica; ZP[PyDelica Input Files] ZW[C Code] ZK[Model Binaries] ZI[XML Input File] ZP --OMC--> ZI end subgraph Power Balance Models; G --> ZP --OMC--> ZW --Make--> ZK G --> H[Models List] B --> I[Parameters] DA[Validator] D --> I E --> I C --> DA --> J[Configuration] A --> DA H -.Extract.->I O[Simulation] I --> ZI J --> O ZI --> O ZK --> O end subgraph User Interface; K[Add Model] L[Set Parameter] M[Get Parameter] VA[View Plots] K --> ZP L --> I I --> M end subgraph Outputs; P[Dataframe] Q[Power Plots] O --> P O --> Q AA[Heat Profiles] BB[Current Profiles] I --> AA I --> BB R[Parameters] S[API Config] T[Simulation Config] I --> R J --> S J --> T end BR[PBMBrowser] Q --> BR VA --> BR","title":"Overview"},{"location":"API/api_overview/#pydelica","text":"PBM uses PyDelica to compile, configure and run a Modelica model. At its base the process consists of five main steps: Create a PyDelica session and hand it the Modelica files for the models required. The models will firstly be converted into C source files and relevant build files. The model will then be compiled using the created Makefile. As compiled models rely on a created XML file to set initial parameter values, PyDelica allows the user to set these conditions by modifying this XML file directly. Run the binary when a simulation is requested. Why not OMPython? For those who have researched the topic you will already know that OpenModelica already comes with a Python interface, OMPython . However rather than being a direct API for OpenModelica itself, it acts as an API for OMShell which in turn runs OpenModelica. In order to do this it has to run on a server (i.e. ZMQ session). Whilst writing Unit Tests for Power Balance Models using OMPython it was discovered that this server approach is very taxing on CPU especially when you want to run multiple models in tandem as each would create a new OMC session. When OMC is run in script generation mode an XML file is also created from which the compiled binary reads parameter values and simulation options. As Python is able to edit XML files PyDelica instead updates parameter values directly. Furthermore OMPython does not throw exceptions when the OpenModelica backend fails, instead the errors are largely lost or not even returned meaning any scripts continue to run even after model compilation/run failure.","title":"PyDelica"},{"location":"API/api_overview/#validation","text":"In the case of the API configuration , simulation configuration and plasma scenario files a validation check is performed on the inputs. These checks are performed using the pydantic Python module which compares the inputs to a defined schema containing rules. Further information these schemas can be found here .","title":"Validation"},{"location":"API/cli/","text":"Command Line Interface # Most analysis can be performed using the command line interface (CLI). The commands below are added to your PATH after installation. powerbalance # Power Balance Models CLI for running models, as well as generating and viewing profiles. Usage: powerbalance [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. generate-profiles # Generate profiles used as model inputs Usage: powerbalance generate-profiles [OPTIONS] Options: --outdir TEXT Profile output directory --help Show this message and exit. new # Create a new project folder with modifiable a parameter set Usage: powerbalance new [OPTIONS] OUTPUT_DIR Options: --help Show this message and exit. plugins # Commands relating to plugins Usage: powerbalance plugins [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. install # Installs a plugin from the given directory Usage: powerbalance plugins install [OPTIONS] PLUGIN_DIRECTORY Options: --help Show this message and exit. list # Lists all available plugins Usage: powerbalance plugins list [OPTIONS] Options: --help Show this message and exit. remove # Remove a plugin by name Usage: powerbalance plugins remove [OPTIONS] PLUGIN_NAME Options: --help Show this message and exit. run # Launch and run a PBM simulation session Usage: powerbalance run [OPTIONS] Options: --config TEXT TOML configuration file. --verbose / --no-verbose Run in Debug Mode --no-browser / --browser Run without launching result browser [default: browser] --outputdir TEXT Output directory, default is current directory --param-dir TEXT Location of parameter files --model-dir TEXT Modelica model file directory --profiles-dir TEXT Directory containing profiles --from-session TEXT Run Power Balance using an existing session output directory --help Show this message and exit. view-profile # View a profile within a '.mat' file Usage: powerbalance view-profile [OPTIONS] INPUT_MAT_FILE Options: --head INTEGER display head n rows --tail INTEGER display tail n rows --help Show this message and exit. view-results # Launch browser window from output directory Usage: powerbalance view-results [OPTIONS] OUTPUT_DIR Options: --help Show this message and exit.","title":"Command Line Interface"},{"location":"API/cli/#command-line-interface","text":"Most analysis can be performed using the command line interface (CLI). The commands below are added to your PATH after installation.","title":"Command Line Interface"},{"location":"API/cli/#powerbalance","text":"Power Balance Models CLI for running models, as well as generating and viewing profiles. Usage: powerbalance [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit.","title":"powerbalance"},{"location":"API/cli/#generate-profiles","text":"Generate profiles used as model inputs Usage: powerbalance generate-profiles [OPTIONS] Options: --outdir TEXT Profile output directory --help Show this message and exit.","title":"generate-profiles"},{"location":"API/cli/#new","text":"Create a new project folder with modifiable a parameter set Usage: powerbalance new [OPTIONS] OUTPUT_DIR Options: --help Show this message and exit.","title":"new"},{"location":"API/cli/#plugins","text":"Commands relating to plugins Usage: powerbalance plugins [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"plugins"},{"location":"API/cli/#install","text":"Installs a plugin from the given directory Usage: powerbalance plugins install [OPTIONS] PLUGIN_DIRECTORY Options: --help Show this message and exit.","title":"install"},{"location":"API/cli/#list","text":"Lists all available plugins Usage: powerbalance plugins list [OPTIONS] Options: --help Show this message and exit.","title":"list"},{"location":"API/cli/#remove","text":"Remove a plugin by name Usage: powerbalance plugins remove [OPTIONS] PLUGIN_NAME Options: --help Show this message and exit.","title":"remove"},{"location":"API/cli/#run","text":"Launch and run a PBM simulation session Usage: powerbalance run [OPTIONS] Options: --config TEXT TOML configuration file. --verbose / --no-verbose Run in Debug Mode --no-browser / --browser Run without launching result browser [default: browser] --outputdir TEXT Output directory, default is current directory --param-dir TEXT Location of parameter files --model-dir TEXT Modelica model file directory --profiles-dir TEXT Directory containing profiles --from-session TEXT Run Power Balance using an existing session output directory --help Show this message and exit.","title":"run"},{"location":"API/cli/#view-profile","text":"View a profile within a '.mat' file Usage: powerbalance view-profile [OPTIONS] INPUT_MAT_FILE Options: --head INTEGER display head n rows --tail INTEGER display tail n rows --help Show this message and exit.","title":"view-profile"},{"location":"API/cli/#view-results","text":"Launch browser window from output directory Usage: powerbalance view-results [OPTIONS] OUTPUT_DIR Options: --help Show this message and exit.","title":"view-results"},{"location":"API/configuration/","text":"Global Configuration File # The global config file contains options which are related to the API session as opposed to Modelica configurations. This configuration is validated before the session is started. The contents of the default configuration file are: models = [ \"Tokamak.Interdependencies\" ] # Default model parameters_directory = \"Default\" # Use built in simulation_options_file = \"simulation_options.toml\" # Opts TOML file plasma_scenario_file = \"plasma_scenario.toml\" # Opts TOML file structural_params_file = \"structural_parameters.toml\" # Opts TOML file profiles_directory = \"Default\" # Use built in modelica_file_directory = \"Default\" # Use built in Options with the value \"Default\" must still be specified, this option specifying to instead use the internal configurations. The default values can be viewed after a run within the output folder. Option Type Description Required Comments models List[str] List of models to run Make sure these are models and not model components. parameters_directory str Directory containing parameter files Defaults to internal parameter directory simulation_options_file str Identifier for the simulation options file in the parameters directory This is the relative filename not a path profiles_directory str Directory containing the .mat profiles Defaults to internal profile directory, is generated if it does not yet exist modelica_file_directory str Directory containing modelica model files Defaults to internal model directory sweep_mode str Type of sweep to perform (if sweep specified) See below structural_params_file str Identifier for the structural parameters file in the parameters directory Overrides the default structured parameters with the values provided (see here ) plugins Specify which plugins to run and the order in which to run them. By default all installed are used. Plugin Specification # The key plugins is not included by default. All plugins will be run in the order given by os.listdir . You can specify which plugins to use and in what order by adding this key along with a list: plugins = [ 'My Plugin' ] this name should match that of the plugin itself, but is case insensitive. A full list of available plugins is given by running: powerbalance plugins Order is Important! Plugins can change the input arguments for Power Balance as such the order in which they are executed is important. Given plugins A , B and C which all setup arguments: A -> B -> C would not be equivalent to a run order of B -> C -> A etc. Therefore usage of plugins is recommended where a run will use more than one plugin. Creating a parameter sweep # To perform a parameter sweep you will need to add an additional sweep section to your configuration file and specify the values to run with. [sweep] Tokamak . Interdependencies . MagnetPower . MagnetPF4 . RFeeder = [ 1E-8 , 1E-7 , 5E-8 ] Parameter addresses Parameters must be specified by their complete address within the Modelica model. There are two sweep modes: set : run in sequence (i.e. for run i use the i th element of all sweep parameter lists). combination : run all possible combinations of all sweep parameters.","title":"Global"},{"location":"API/configuration/#global-configuration-file","text":"The global config file contains options which are related to the API session as opposed to Modelica configurations. This configuration is validated before the session is started. The contents of the default configuration file are: models = [ \"Tokamak.Interdependencies\" ] # Default model parameters_directory = \"Default\" # Use built in simulation_options_file = \"simulation_options.toml\" # Opts TOML file plasma_scenario_file = \"plasma_scenario.toml\" # Opts TOML file structural_params_file = \"structural_parameters.toml\" # Opts TOML file profiles_directory = \"Default\" # Use built in modelica_file_directory = \"Default\" # Use built in Options with the value \"Default\" must still be specified, this option specifying to instead use the internal configurations. The default values can be viewed after a run within the output folder. Option Type Description Required Comments models List[str] List of models to run Make sure these are models and not model components. parameters_directory str Directory containing parameter files Defaults to internal parameter directory simulation_options_file str Identifier for the simulation options file in the parameters directory This is the relative filename not a path profiles_directory str Directory containing the .mat profiles Defaults to internal profile directory, is generated if it does not yet exist modelica_file_directory str Directory containing modelica model files Defaults to internal model directory sweep_mode str Type of sweep to perform (if sweep specified) See below structural_params_file str Identifier for the structural parameters file in the parameters directory Overrides the default structured parameters with the values provided (see here ) plugins Specify which plugins to run and the order in which to run them. By default all installed are used.","title":"Global Configuration File"},{"location":"API/configuration/#plugin-specification","text":"The key plugins is not included by default. All plugins will be run in the order given by os.listdir . You can specify which plugins to use and in what order by adding this key along with a list: plugins = [ 'My Plugin' ] this name should match that of the plugin itself, but is case insensitive. A full list of available plugins is given by running: powerbalance plugins Order is Important! Plugins can change the input arguments for Power Balance as such the order in which they are executed is important. Given plugins A , B and C which all setup arguments: A -> B -> C would not be equivalent to a run order of B -> C -> A etc. Therefore usage of plugins is recommended where a run will use more than one plugin.","title":"Plugin Specification"},{"location":"API/configuration/#creating-a-parameter-sweep","text":"To perform a parameter sweep you will need to add an additional sweep section to your configuration file and specify the values to run with. [sweep] Tokamak . Interdependencies . MagnetPower . MagnetPF4 . RFeeder = [ 1E-8 , 1E-7 , 5E-8 ] Parameter addresses Parameters must be specified by their complete address within the Modelica model. There are two sweep modes: set : run in sequence (i.e. for run i use the i th element of all sweep parameter lists). combination : run all possible combinations of all sweep parameters.","title":"Creating a parameter sweep"},{"location":"API/data_out/","text":"Analysing Outputs # Output File Structure # After running Power Balance Models (PBM) a new directory should be created either in the current working directory, or the manually specified location. This directory will have a name in the format pbm_results_<time-stamp> and contain a set of subdirectories with files pertaining to the run itself (presence of the html and directory may depend on whether the plot browser is set to open after the run): pbm_results_2021_06_18_12_59_22/ \u251c\u2500\u2500 configs \u2502 \u2514\u2500\u2500 configuration.toml \u251c\u2500\u2500 data \u2502 \u2514\u2500\u2500 session_data.h5 \u251c\u2500\u2500 parameters \u2502 \u251c\u2500\u2500 simulation_options.toml \u2502 \u2514\u2500\u2500 tokamak_interdependencies.toml \u251c\u2500\u2500 plots \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_air_gas_power.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_blanketdetritpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_coolantdetritpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_cryogenicpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_hcdsystem.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_magnetpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_netpowerconsumption.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_netpowergeneration.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_powergenerated.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_total_turbopump_power.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_wasteheatpower.jpg \u2502 \u2514\u2500\u2500 Tokamak_Interdependencies_water_detrit_power.jpg \u2514\u2500\u2500 profiles \u251c\u2500\u2500 NBI_Heat.mat \u251c\u2500\u2500 RF_Heat.mat \u251c\u2500\u2500 ThermalPowerOut.mat \u251c\u2500\u2500 currentCS.mat \u251c\u2500\u2500 currentPF1.mat \u251c\u2500\u2500 currentPF2.mat \u251c\u2500\u2500 currentPF3.mat \u251c\u2500\u2500 currentPF4.mat \u251c\u2500\u2500 currentPF5.mat \u251c\u2500\u2500 currentPF6.mat \u2514\u2500\u2500 currentTF.mat Directory Description configs Contains a saved copy of the API session configuration file used during the run. data Contains a single file containing all data frames from all models run during the session. html Contains the generated HTML file for viewing power data plots within the browser. parameters Contains all parameter start value configuration files and the simulation options file. plots Contains JPG versions of the plots generated during a run. profiles Contains copies of the .mat profiles used as inputs for the model run.","title":"Output Data Directory"},{"location":"API/data_out/#analysing-outputs","text":"","title":"Analysing Outputs"},{"location":"API/data_out/#output-file-structure","text":"After running Power Balance Models (PBM) a new directory should be created either in the current working directory, or the manually specified location. This directory will have a name in the format pbm_results_<time-stamp> and contain a set of subdirectories with files pertaining to the run itself (presence of the html and directory may depend on whether the plot browser is set to open after the run): pbm_results_2021_06_18_12_59_22/ \u251c\u2500\u2500 configs \u2502 \u2514\u2500\u2500 configuration.toml \u251c\u2500\u2500 data \u2502 \u2514\u2500\u2500 session_data.h5 \u251c\u2500\u2500 parameters \u2502 \u251c\u2500\u2500 simulation_options.toml \u2502 \u2514\u2500\u2500 tokamak_interdependencies.toml \u251c\u2500\u2500 plots \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_air_gas_power.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_blanketdetritpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_coolantdetritpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_cryogenicpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_hcdsystem.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_magnetpower.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_netpowerconsumption.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_netpowergeneration.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_powergenerated.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_total_turbopump_power.jpg \u2502 \u251c\u2500\u2500 Tokamak_Interdependencies_wasteheatpower.jpg \u2502 \u2514\u2500\u2500 Tokamak_Interdependencies_water_detrit_power.jpg \u2514\u2500\u2500 profiles \u251c\u2500\u2500 NBI_Heat.mat \u251c\u2500\u2500 RF_Heat.mat \u251c\u2500\u2500 ThermalPowerOut.mat \u251c\u2500\u2500 currentCS.mat \u251c\u2500\u2500 currentPF1.mat \u251c\u2500\u2500 currentPF2.mat \u251c\u2500\u2500 currentPF3.mat \u251c\u2500\u2500 currentPF4.mat \u251c\u2500\u2500 currentPF5.mat \u251c\u2500\u2500 currentPF6.mat \u2514\u2500\u2500 currentTF.mat Directory Description configs Contains a saved copy of the API session configuration file used during the run. data Contains a single file containing all data frames from all models run during the session. html Contains the generated HTML file for viewing power data plots within the browser. parameters Contains all parameter start value configuration files and the simulation options file. plots Contains JPG versions of the plots generated during a run. profiles Contains copies of the .mat profiles used as inputs for the model run.","title":"Output File Structure"},{"location":"API/development/","text":"Development # Contributions to the Power Balance Models (PBM) project can be broken down into model development and API development. Both should be performed under git version control with changes being committed to a personal development branch, and any conflicts being resolved before merging into the main develop branch takes place. It is recommended you develop and test PBM using Poetry, instructions on how to install and run the project this way are given here . The terms \"backend\" and \"frontend\" are used to refer to the OpenModelica and Python code respectively. Model Development # When updating revisions of the model components make sure to add the revision to the documentation page for that component, e.g. for Tokamak.Magnets.TF_Magnet here . Model Merge Conflicts Special care should be taken to ensure any conflicts raised during a git merge are addressed. If such conflicts appear within the Modelica files it is strongly recommended that you either use the script view in OMEdit or another editor to address them. API Development # Where possible any new features should either be placed within a relevant existing location, or should form a new subdirectory in the python module. For example, any additions relating to compatibility with external data sources could be added to a new location power_balance/external_data . A unit/regression test for each new feature should be added to the tests directory (See Testing ). The code should be documented sensibly. As a tip, imagine you are returning to the code after a year, what comments would help you remember how to use your code? Try to use typing in your functions. Not only does this improve readability, but if you run poetry run mypy it will tell you if the object type a function is returning matches your expectation. An example typed function would be: from typing import Dict from string import ascii_lowercase def my_useless_function ( a : int , b : int ) -> str : temp_var_ : Dict [ int , str ] = {} for i in range ( a , b ): temp_var_ [ i ] = ascii_lowercase [ i % 3 ] return '' . join ( temp_var_ . values ()) more information on mypy can be found here . Testing # Unit and Regression Testing # Testing is essential to ensuring the outputs from PBM are accurate and the code behaves as expected. Tests are performed using pytest and are usually of the following form: If the code addition is being added to an existing feature create a test in the tests script for that feature else create a new one within tests . Test files must start with the prefix test_ . Use pytest.mark to help categorise tests. Use pytest.fixture for test setup (e.g. creating an instance of a class that should be shared between all tests) As an example say we have a new feature \"User Greetings\", a test script would be created tests/unit_tests/test_user_greeting.py : import pytest from power_balance.greetings import Greeter # Create an instance of the fictional Greeting class # to be shared between all tests within this module (script) @pytest . fixture ( scope = \"module\" ) def greeter_instance (): return Greeter ( name = \"John\" ) # Add the test to the category \"greetings\" # pass fixture as argument @pytest . mark . greetings def test_greeter_message ( greeter_instance ): # Check that we get what we expect assert greeter_instance . message () == \"Hello John!\" We also need to add the new category to the pytest.ini file: [pytest] markers = greetings: tests related to the greetings submodule Unit or Regression? Unit tests and regression tests are very different things. A unit test is a test which asserts that the code behaves as we expect (usually as the literature/science dictates). For example: def adder ( a , b ): return a + b # We know 2+3 should equal 5 so we check our code # behaves as such def test_adder (): assert adder ( 2 , 3 ) == 5 However a regression test checks that the code behaves the same now as it did previously, in the case of PBM the folder baseline contains data collected during a run which is known to be correct. Using the previous example: def adder ( a , b ): return a + b def test_adder (): with open ( 'previous_run_data.npy' , 'rb' ) as f : assert adder ( 2 , 3 ) == np . load ( f ) Benchmark Testing # Performance of PBM is measured using airspeed-velocity (ASV) which allows the user to write tests for measuring properties such as the timing and memory usage during execution. These tests are grouped in \"suites\" which are classes containing similar category tests. For PBM these can be found in the benchmarks directory, the Python scripts containing tests which are grouped as either timing or memory tests. ASV identifies the type of test from the prefix, time_ for timing tests, mem_ for memory tests. For timing a function a simple test would be: from my_module import a_very_long_process # As these are timing tests we shall group them in the same class/suite class TimingSuite : def setup ( self ): # we can put any setup for the tests in here pass def time_long_process ( self ): a_very_long_process () See the ASV documentation for more details. Semantic Versioning # PBM where possible keeps to a strict following of the semantic versioning standard outlined here . It is strongly recommended you read these standards before creating a new release. The most important points being: \"Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\" The importance of numbering X.Y.Z representing MAJOR, MINOR, PATCH. A good illustration of the difference between these is shown here . Pre-Release Note versions prior to v1.0.0 may follow a looser standard. Using Git Prehooks # It is strongly recommended that the pre-commit git hooks be installed to catch any issues with code quality, file size and merge conflict remnants. In order to install the git hooks within the repository install pre-commit via pip (this is already present if using poetry to develop), and run: pre-commit install to update your local .git/hooks/pre-commit file. Whenever you create a commit if there are any issues with it these will be flagged before you are allowed to continue.","title":"Overview"},{"location":"API/development/#development","text":"Contributions to the Power Balance Models (PBM) project can be broken down into model development and API development. Both should be performed under git version control with changes being committed to a personal development branch, and any conflicts being resolved before merging into the main develop branch takes place. It is recommended you develop and test PBM using Poetry, instructions on how to install and run the project this way are given here . The terms \"backend\" and \"frontend\" are used to refer to the OpenModelica and Python code respectively.","title":"Development"},{"location":"API/development/#model-development","text":"When updating revisions of the model components make sure to add the revision to the documentation page for that component, e.g. for Tokamak.Magnets.TF_Magnet here . Model Merge Conflicts Special care should be taken to ensure any conflicts raised during a git merge are addressed. If such conflicts appear within the Modelica files it is strongly recommended that you either use the script view in OMEdit or another editor to address them.","title":"Model Development"},{"location":"API/development/#api-development","text":"Where possible any new features should either be placed within a relevant existing location, or should form a new subdirectory in the python module. For example, any additions relating to compatibility with external data sources could be added to a new location power_balance/external_data . A unit/regression test for each new feature should be added to the tests directory (See Testing ). The code should be documented sensibly. As a tip, imagine you are returning to the code after a year, what comments would help you remember how to use your code? Try to use typing in your functions. Not only does this improve readability, but if you run poetry run mypy it will tell you if the object type a function is returning matches your expectation. An example typed function would be: from typing import Dict from string import ascii_lowercase def my_useless_function ( a : int , b : int ) -> str : temp_var_ : Dict [ int , str ] = {} for i in range ( a , b ): temp_var_ [ i ] = ascii_lowercase [ i % 3 ] return '' . join ( temp_var_ . values ()) more information on mypy can be found here .","title":"API Development"},{"location":"API/development/#testing","text":"","title":"Testing"},{"location":"API/development/#unit-and-regression-testing","text":"Testing is essential to ensuring the outputs from PBM are accurate and the code behaves as expected. Tests are performed using pytest and are usually of the following form: If the code addition is being added to an existing feature create a test in the tests script for that feature else create a new one within tests . Test files must start with the prefix test_ . Use pytest.mark to help categorise tests. Use pytest.fixture for test setup (e.g. creating an instance of a class that should be shared between all tests) As an example say we have a new feature \"User Greetings\", a test script would be created tests/unit_tests/test_user_greeting.py : import pytest from power_balance.greetings import Greeter # Create an instance of the fictional Greeting class # to be shared between all tests within this module (script) @pytest . fixture ( scope = \"module\" ) def greeter_instance (): return Greeter ( name = \"John\" ) # Add the test to the category \"greetings\" # pass fixture as argument @pytest . mark . greetings def test_greeter_message ( greeter_instance ): # Check that we get what we expect assert greeter_instance . message () == \"Hello John!\" We also need to add the new category to the pytest.ini file: [pytest] markers = greetings: tests related to the greetings submodule Unit or Regression? Unit tests and regression tests are very different things. A unit test is a test which asserts that the code behaves as we expect (usually as the literature/science dictates). For example: def adder ( a , b ): return a + b # We know 2+3 should equal 5 so we check our code # behaves as such def test_adder (): assert adder ( 2 , 3 ) == 5 However a regression test checks that the code behaves the same now as it did previously, in the case of PBM the folder baseline contains data collected during a run which is known to be correct. Using the previous example: def adder ( a , b ): return a + b def test_adder (): with open ( 'previous_run_data.npy' , 'rb' ) as f : assert adder ( 2 , 3 ) == np . load ( f )","title":"Unit and Regression Testing"},{"location":"API/development/#benchmark-testing","text":"Performance of PBM is measured using airspeed-velocity (ASV) which allows the user to write tests for measuring properties such as the timing and memory usage during execution. These tests are grouped in \"suites\" which are classes containing similar category tests. For PBM these can be found in the benchmarks directory, the Python scripts containing tests which are grouped as either timing or memory tests. ASV identifies the type of test from the prefix, time_ for timing tests, mem_ for memory tests. For timing a function a simple test would be: from my_module import a_very_long_process # As these are timing tests we shall group them in the same class/suite class TimingSuite : def setup ( self ): # we can put any setup for the tests in here pass def time_long_process ( self ): a_very_long_process () See the ASV documentation for more details.","title":"Benchmark Testing"},{"location":"API/development/#semantic-versioning","text":"PBM where possible keeps to a strict following of the semantic versioning standard outlined here . It is strongly recommended you read these standards before creating a new release. The most important points being: \"Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\" The importance of numbering X.Y.Z representing MAJOR, MINOR, PATCH. A good illustration of the difference between these is shown here . Pre-Release Note versions prior to v1.0.0 may follow a looser standard.","title":"Semantic Versioning"},{"location":"API/development/#using-git-prehooks","text":"It is strongly recommended that the pre-commit git hooks be installed to catch any issues with code quality, file size and merge conflict remnants. In order to install the git hooks within the repository install pre-commit via pip (this is already present if using poetry to develop), and run: pre-commit install to update your local .git/hooks/pre-commit file. Whenever you create a commit if there are any issues with it these will be flagged before you are allowed to continue.","title":"Using Git Prehooks"},{"location":"API/getting_started/","text":"Getting Started # Power Balance Models (PBM) can be run via a command line interface (CLI) or by constructing scripts to access the API. Whichever case is chosen runs can be customised by the user as much (or as little) as required. Example run # As there are existing configurations within the API you can run PBM 'out the box' using the available CLI command: powerbalance run after the run is completed a new timestamped directory will be produced containing not only the results but a preserved copy of the configuration set to achieve them. This is useful for recreating runs. In addition your chosen browser should be launched to show a webpage displaying the power data plots as dynamic widgets which can be interacted with. Viewing existing plots # A new plot browser window can be opened on any results directory using the view-results command: powerbalance view-results <pbm_results_dir> Viewing the data # Data is written to a HDF5 file, with each model's output being written to the file as a single dataframe the key for which is the model name in lower case with any . being replaced with _ . The recommended method for accessing the data is using the Pandas module. In the case of the Tokamak.Interdependencies model: import pandas as pd import glob import os import argparse # Create a parser so we can select the result directory # we which to view from the command line parser = argparse . ArgumentParser () parser . add_argument ( 'result_dir' ) args = parser . parse_args () # Use glob to lazily find the HDF5 file hdf5_file = glob . glob ( os . path . join ( args . result_dir , 'data' , '*.hdf5' ) )[ 0 ] # Accessing the dataframe using the key within the file data_frame = pd . read_hdf ( hdf5_file , key = 'tokamak_interdependencies' ) print ( data_frame ) data frames are very powerful objects, you can apply cuts to them and perform operations on subsets, see the Pandas documentation for details. Creating your own scripts # The main class used to initialise and run a simulation via the OpenModelica backend within PBM is the PowerBalance class. It is recommended that the class be used via a context manager to ensure that model build directories are removed upon completion (this is done automatically when using the CLI). from power_balance.core import PowerBalance # Initialise the PBM class fetching parameters # and models from the default locations # Use context manager to ensure junk collection with PowerBalance () as pbm_instance : # Run the simulation with the configuration pbm_instance . run_simulation () # Open the plots in the browser window pbm_instance . launch_browser ()","title":"Getting Started"},{"location":"API/getting_started/#getting-started","text":"Power Balance Models (PBM) can be run via a command line interface (CLI) or by constructing scripts to access the API. Whichever case is chosen runs can be customised by the user as much (or as little) as required.","title":"Getting Started"},{"location":"API/getting_started/#example-run","text":"As there are existing configurations within the API you can run PBM 'out the box' using the available CLI command: powerbalance run after the run is completed a new timestamped directory will be produced containing not only the results but a preserved copy of the configuration set to achieve them. This is useful for recreating runs. In addition your chosen browser should be launched to show a webpage displaying the power data plots as dynamic widgets which can be interacted with.","title":"Example run"},{"location":"API/getting_started/#viewing-existing-plots","text":"A new plot browser window can be opened on any results directory using the view-results command: powerbalance view-results <pbm_results_dir>","title":"Viewing existing plots"},{"location":"API/getting_started/#viewing-the-data","text":"Data is written to a HDF5 file, with each model's output being written to the file as a single dataframe the key for which is the model name in lower case with any . being replaced with _ . The recommended method for accessing the data is using the Pandas module. In the case of the Tokamak.Interdependencies model: import pandas as pd import glob import os import argparse # Create a parser so we can select the result directory # we which to view from the command line parser = argparse . ArgumentParser () parser . add_argument ( 'result_dir' ) args = parser . parse_args () # Use glob to lazily find the HDF5 file hdf5_file = glob . glob ( os . path . join ( args . result_dir , 'data' , '*.hdf5' ) )[ 0 ] # Accessing the dataframe using the key within the file data_frame = pd . read_hdf ( hdf5_file , key = 'tokamak_interdependencies' ) print ( data_frame ) data frames are very powerful objects, you can apply cuts to them and perform operations on subsets, see the Pandas documentation for details.","title":"Viewing the data"},{"location":"API/getting_started/#creating-your-own-scripts","text":"The main class used to initialise and run a simulation via the OpenModelica backend within PBM is the PowerBalance class. It is recommended that the class be used via a context manager to ensure that model build directories are removed upon completion (this is done automatically when using the CLI). from power_balance.core import PowerBalance # Initialise the PBM class fetching parameters # and models from the default locations # Use context manager to ensure junk collection with PowerBalance () as pbm_instance : # Run the simulation with the configuration pbm_instance . run_simulation () # Open the plots in the browser window pbm_instance . launch_browser ()","title":"Creating your own scripts"},{"location":"API/installation/","text":"Supported Environments # Power Balance Models (PBM) has been confirmed to work on: Ubuntu 20.04 - 21.10 Windows 7 SP1* Windows 10* * using Python for Windows and CMD. The PBM is not tested on Mac systems. The software requires: Python >= 3.8.6 . Recommended version is 3.9.9 , which you can download from the bottom of the page here ); OpenModelica >= 1.14.4 . Recommended version is 1.17.0 , which you can download from here (Windows) or here (Unix) (instructions in https://www.openmodelica.org/download/download-linux). Installation on Mac (not stable) can be found here ; It is recommended you run the software from within a virtual environment system such as PyEnv or the built-in venv module, this ensures there is no interference with your system python installation. Alternatively you can install it under the current user. Installation for UNIX and Windows # Downloads are available here . You can install the package using pip on the wheels file: pip install power_balance-<version>-py3-none-any.whl To install this package you will firstly need to install OpenModelica to your system. The module works by either finding the location of an omc installation (in the case of UNIX) or using the environment variable %OPENMODELICAHOME% in the case of Windows. Installing OpenModelica Compiler # For Windows users will need to install the complete OpenModelica application using the dedicated installer found on the project website . Linux users only require omc and the Modelica Standard Library: echo \"deb https://build.openmodelica.org/apt `lsb_release -cs` stable\" | sudo tee /etc/apt/sources.list.d/openmodelica.list wget -q http://build.openmodelica.org/apt/openmodelica.asc -O- | sudo apt-key add - sudo apt update sudo apt install -y omlib-modelica-3.2.3 omc Installation on Mac is not tested and not supported by the Power Balance team, primarily because of the difficulty associated with installing OpenModelica on Mac. Updating PowerBalance Installation Note, if updating your version of powerbalance , it is strongly recommended that you re-generate the model profiles in case changes have been made which affect them: powerbalance generate-profiles Modelica Standard Library version The Power Balance Models API is not compatible with Modelica Standard Library >=4.0.0 . Significant changes have been implemented in these versions. Latest known working environment is OpenModelica 1.18.0 with MSL 3.2.3 . Testing # You can verify your install is working correctly by either running the default configuration using the powerbalance command, or by running the included tests using pytest : pytest -s tests/","title":"Installation"},{"location":"API/installation/#supported-environments","text":"Power Balance Models (PBM) has been confirmed to work on: Ubuntu 20.04 - 21.10 Windows 7 SP1* Windows 10* * using Python for Windows and CMD. The PBM is not tested on Mac systems. The software requires: Python >= 3.8.6 . Recommended version is 3.9.9 , which you can download from the bottom of the page here ); OpenModelica >= 1.14.4 . Recommended version is 1.17.0 , which you can download from here (Windows) or here (Unix) (instructions in https://www.openmodelica.org/download/download-linux). Installation on Mac (not stable) can be found here ; It is recommended you run the software from within a virtual environment system such as PyEnv or the built-in venv module, this ensures there is no interference with your system python installation. Alternatively you can install it under the current user.","title":"Supported Environments"},{"location":"API/installation/#installation-for-unix-and-windows","text":"Downloads are available here . You can install the package using pip on the wheels file: pip install power_balance-<version>-py3-none-any.whl To install this package you will firstly need to install OpenModelica to your system. The module works by either finding the location of an omc installation (in the case of UNIX) or using the environment variable %OPENMODELICAHOME% in the case of Windows.","title":"Installation for UNIX and Windows"},{"location":"API/installation/#installing-openmodelica-compiler","text":"For Windows users will need to install the complete OpenModelica application using the dedicated installer found on the project website . Linux users only require omc and the Modelica Standard Library: echo \"deb https://build.openmodelica.org/apt `lsb_release -cs` stable\" | sudo tee /etc/apt/sources.list.d/openmodelica.list wget -q http://build.openmodelica.org/apt/openmodelica.asc -O- | sudo apt-key add - sudo apt update sudo apt install -y omlib-modelica-3.2.3 omc Installation on Mac is not tested and not supported by the Power Balance team, primarily because of the difficulty associated with installing OpenModelica on Mac. Updating PowerBalance Installation Note, if updating your version of powerbalance , it is strongly recommended that you re-generate the model profiles in case changes have been made which affect them: powerbalance generate-profiles Modelica Standard Library version The Power Balance Models API is not compatible with Modelica Standard Library >=4.0.0 . Significant changes have been implemented in these versions. Latest known working environment is OpenModelica 1.18.0 with MSL 3.2.3 .","title":"Installing OpenModelica Compiler"},{"location":"API/installation/#testing","text":"You can verify your install is working correctly by either running the default configuration using the powerbalance command, or by running the included tests using pytest : pytest -s tests/","title":"Testing"},{"location":"API/parameters/","text":"Parameter Values # Model Parameters # Initial mutable Modelica model parameter values are specified in TOML files with a file existing for each model executed. These files are placed together in a parameter directory. The naming convention of these files should follow that of: the model name in lower case where . is replaced with _ . For example for the model Tokamak.Interdependencies the relevant parameter file is named tokamak_interdependencies.toml . In TOML files hierarchy is specified via headers [...] . Example The parameter Tokamak.Interdependencies.hcdsystem.NINI1.__beamEnergy would be found in the file tokamak_interdependencies.toml and be modified as: [hcdsystem.NINI1] beamEnergy = 1 Editable values Only parameters with the prefix __ can be modified within PBM as such this prefix is omitted from the parameter TOML file specification. If a non-modifiable parameter is specified in a parameter configuration file it will be ignored. In the case of the default parameters the internal file parameters/tokamak_interdependencies.toml contains: PrimaryCoolantType = \"CO2_NC\" # Can be CO2_C, CO2_NC, He_C, He_NC, H2O, FLiBe, LiPb SecondaryCoolantType = \"H2O\" # Can be CO2, H2O RatioType = \"1.5\" # Can be 1.5, 2, 2.5 SystemPressure = \"90\" # Can be 50, 90, 200 VacuumType = true # True or false ThermalPower = 1000 # Default value 1 GW # ========================== HCD SYSTEM ================================ # [hcdsystem] RFEfficiency = 0.4 HeatToAir = 0.20 [hcdsystem.negativeIonNeutralInjector] beamEnergy = 1 efficiencyNeutralization = 0.58 NBIThermalPowerMaxMW = 109 # ======================= CRYOGENIC POWER ============================== # [cryogenicpower] HeatToAir = 0.20 cryoFlow_HydrogenFreezing = 3.5 cryoTemp_TF = 20 cryoTemp_PF = 4 PFcrMW = 0.0007 [cryogenicpower.CD] FBCol_2 = 0.0003902222222222223 FBCol_3 = 0.0001944444444444444 InputFlowRateCol_1 = 0.0002737777777777778 InputFlowRateCol_2 = 0.0002755555555555556 OutputStreamRateCol_1 = 8.638888888888889e-05 OutputStreamRateCol_2 = 0.0001803333333333333 OutputStreamRateCol_3 = 5.555555555555556e-05 OutputStreamRateCol_4 = 0.0001411944444444444 # ====================== WASTE HEAT POWER ============================== # [wasteheatpower.wasteHeatCryo] Height = 3.0 Length = 120.0 SystemEfficiency = 0.8 Width = 45.0 [wasteheatpower.wasteHeatHCD] Height = 70.0 Length = 120.0 SystemEfficiency = 0.8 Width = 100.0 [wasteheatpower.WasteHeatMagnets] Height = 3.0 Length = 150.0 SystemEfficiency = 0.8 Width = 30.0 # ========================== MAGNET POWER ============================== # [magnetpower.magnetPF1] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF2] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF3] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF4] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF5] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF6] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetTF] numCoils = 12 Vdrop = 1.45 Rfeeder = 1.9e-7 nTurn = 5.0 maxCurrent = 60e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 magEnergy = 2.139e9 Rtot = 4.253e-7 Roleg = 1.948e-8 # ========================== POWER GENERATION ============================== # [powergenerated] powergenOutletTemp = 500 Examining TOML Files TOML files can be loaded into Python as a dictionary using the toml module: import toml import os # If parameters located at ./parameters/parameters.toml params_path = os . path . join ( os . getcwd (), 'parameters' , 'parameters.toml' ) # Load the TOML file into a dictionary params_dict = toml . load ( open ( params_path )) # Retrieve parameter 'model.component.var' from dictionary print ( params_dict [ 'model' ][ 'component' ][ 'var' ]) Model Expansion # The \"Magnets\" component of Power Balance can be expanded to include additional PF magnets within the model. By default the model is run with the defined 6 PF magnet configuration, in order to define additional magnets extra statements can be added to the parameters file, e.g. including: [magnetpower.magnetPF7] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 combiTimeTable = 2 will create one additional magnet. The optional parameter combiTimeTable is not a Modelica parameter in this case, but rather an additional variable used to select which existing combiTimeTable instance to use for creating the magnet instance. In this case we are using PF2 as the template. Note also you can provide as many or as little parameters as you like to add a new magnet definition, the minimum being one (we recommend setting at least combiTimeTable in this case). As the number of magnets is deduced from the maximum PF stated within the parameters file to have for example 20 magnets, you need only explicitly define the 20th (i.e. magnetpower.magnetPF20 ). Structural Parameters # Structural parameters for the Modelica models are not mutable and can only be changed by altering the code itself. As such changes to these are handled independent of the main model parameters. In order to make alterations you need to provide the structural_params_file key within your configuration file. By default the file power_balance/parameters/structural_parameters.toml is read. If no key is provided then the substitutions are not made and the original unmodified model code is used. The default substitution file contains the following: # ========================== MAGNETS =================================== # [Magnets] isMagnetTFSuperconCoil = false isMagnetTFSuperconFeeder = false isMagnetPF1SuperconCoil = false isMagnetPF1SuperconFeeder = false isMagnetPF2SuperconCoil = false isMagnetPF2SuperconFeeder = false isMagnetPF3SuperconCoil = false isMagnetPF3SuperconFeeder = false isMagnetPF4SuperconCoil = false isMagnetPF4SuperconFeeder = false isMagnetPF5SuperconCoil = false isMagnetPF5SuperconFeeder = false isMagnetPF6SuperconCoil = false isMagnetPF6SuperconFeeder = false [CryogenicPlant] FOM4K = 30 # Figure of merit for the cryoplant at 4 K FOM20K = 30 # Figure of merit for the cryoplant at 20 K FOM80K = 30 # Figure of merit for the cryoplant at 80 K # ========================== Tokamak ====================================== # [Tokamak] PrimaryCoolantType = \"CO2_NC\" # Can be CO2_C, CO2_NC, He_C, He_NC, H2O, FLiBe, LiPb SecondaryCoolantType = \"H2O\" # Can be CO2, H2O RatioType = \"1.5\" # Can be 1.5, 2, 2.5 SystemPressure = \"90\" # Can be 50, 90, 200 # ========================== PowerGenCaseByCase========================== # [PowerGenEquations] powergenOutletTemp = 500 # temperature related to the exchange of heat between the tokamak and the power generation system (Celsius) Structural Parameter Substitution Such substitutions can cause code compilation failures if not performed correctly, therefore caution should be taken when using configurations different to the defaults.","title":"Parameters"},{"location":"API/parameters/#parameter-values","text":"","title":"Parameter Values"},{"location":"API/parameters/#model-parameters","text":"Initial mutable Modelica model parameter values are specified in TOML files with a file existing for each model executed. These files are placed together in a parameter directory. The naming convention of these files should follow that of: the model name in lower case where . is replaced with _ . For example for the model Tokamak.Interdependencies the relevant parameter file is named tokamak_interdependencies.toml . In TOML files hierarchy is specified via headers [...] . Example The parameter Tokamak.Interdependencies.hcdsystem.NINI1.__beamEnergy would be found in the file tokamak_interdependencies.toml and be modified as: [hcdsystem.NINI1] beamEnergy = 1 Editable values Only parameters with the prefix __ can be modified within PBM as such this prefix is omitted from the parameter TOML file specification. If a non-modifiable parameter is specified in a parameter configuration file it will be ignored. In the case of the default parameters the internal file parameters/tokamak_interdependencies.toml contains: PrimaryCoolantType = \"CO2_NC\" # Can be CO2_C, CO2_NC, He_C, He_NC, H2O, FLiBe, LiPb SecondaryCoolantType = \"H2O\" # Can be CO2, H2O RatioType = \"1.5\" # Can be 1.5, 2, 2.5 SystemPressure = \"90\" # Can be 50, 90, 200 VacuumType = true # True or false ThermalPower = 1000 # Default value 1 GW # ========================== HCD SYSTEM ================================ # [hcdsystem] RFEfficiency = 0.4 HeatToAir = 0.20 [hcdsystem.negativeIonNeutralInjector] beamEnergy = 1 efficiencyNeutralization = 0.58 NBIThermalPowerMaxMW = 109 # ======================= CRYOGENIC POWER ============================== # [cryogenicpower] HeatToAir = 0.20 cryoFlow_HydrogenFreezing = 3.5 cryoTemp_TF = 20 cryoTemp_PF = 4 PFcrMW = 0.0007 [cryogenicpower.CD] FBCol_2 = 0.0003902222222222223 FBCol_3 = 0.0001944444444444444 InputFlowRateCol_1 = 0.0002737777777777778 InputFlowRateCol_2 = 0.0002755555555555556 OutputStreamRateCol_1 = 8.638888888888889e-05 OutputStreamRateCol_2 = 0.0001803333333333333 OutputStreamRateCol_3 = 5.555555555555556e-05 OutputStreamRateCol_4 = 0.0001411944444444444 # ====================== WASTE HEAT POWER ============================== # [wasteheatpower.wasteHeatCryo] Height = 3.0 Length = 120.0 SystemEfficiency = 0.8 Width = 45.0 [wasteheatpower.wasteHeatHCD] Height = 70.0 Length = 120.0 SystemEfficiency = 0.8 Width = 100.0 [wasteheatpower.WasteHeatMagnets] Height = 3.0 Length = 150.0 SystemEfficiency = 0.8 Width = 30.0 # ========================== MAGNET POWER ============================== # [magnetpower.magnetPF1] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF2] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF3] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF4] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF5] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetPF6] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 [magnetpower.magnetTF] numCoils = 12 Vdrop = 1.45 Rfeeder = 1.9e-7 nTurn = 5.0 maxCurrent = 60e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 magEnergy = 2.139e9 Rtot = 4.253e-7 Roleg = 1.948e-8 # ========================== POWER GENERATION ============================== # [powergenerated] powergenOutletTemp = 500 Examining TOML Files TOML files can be loaded into Python as a dictionary using the toml module: import toml import os # If parameters located at ./parameters/parameters.toml params_path = os . path . join ( os . getcwd (), 'parameters' , 'parameters.toml' ) # Load the TOML file into a dictionary params_dict = toml . load ( open ( params_path )) # Retrieve parameter 'model.component.var' from dictionary print ( params_dict [ 'model' ][ 'component' ][ 'var' ])","title":"Model Parameters"},{"location":"API/parameters/#model-expansion","text":"The \"Magnets\" component of Power Balance can be expanded to include additional PF magnets within the model. By default the model is run with the defined 6 PF magnet configuration, in order to define additional magnets extra statements can be added to the parameters file, e.g. including: [magnetpower.magnetPF7] numCoils = 1 Vdrop = 1.45 Rfeeder = 3.7e-9 nTurn = 200.0 maxCurrent = 50e3 coilLength = 40 Feeder_Qk = 0.198 Feeder_m = 0.069 L = 0.02 combiTimeTable = 2 will create one additional magnet. The optional parameter combiTimeTable is not a Modelica parameter in this case, but rather an additional variable used to select which existing combiTimeTable instance to use for creating the magnet instance. In this case we are using PF2 as the template. Note also you can provide as many or as little parameters as you like to add a new magnet definition, the minimum being one (we recommend setting at least combiTimeTable in this case). As the number of magnets is deduced from the maximum PF stated within the parameters file to have for example 20 magnets, you need only explicitly define the 20th (i.e. magnetpower.magnetPF20 ).","title":"Model Expansion"},{"location":"API/parameters/#structural-parameters","text":"Structural parameters for the Modelica models are not mutable and can only be changed by altering the code itself. As such changes to these are handled independent of the main model parameters. In order to make alterations you need to provide the structural_params_file key within your configuration file. By default the file power_balance/parameters/structural_parameters.toml is read. If no key is provided then the substitutions are not made and the original unmodified model code is used. The default substitution file contains the following: # ========================== MAGNETS =================================== # [Magnets] isMagnetTFSuperconCoil = false isMagnetTFSuperconFeeder = false isMagnetPF1SuperconCoil = false isMagnetPF1SuperconFeeder = false isMagnetPF2SuperconCoil = false isMagnetPF2SuperconFeeder = false isMagnetPF3SuperconCoil = false isMagnetPF3SuperconFeeder = false isMagnetPF4SuperconCoil = false isMagnetPF4SuperconFeeder = false isMagnetPF5SuperconCoil = false isMagnetPF5SuperconFeeder = false isMagnetPF6SuperconCoil = false isMagnetPF6SuperconFeeder = false [CryogenicPlant] FOM4K = 30 # Figure of merit for the cryoplant at 4 K FOM20K = 30 # Figure of merit for the cryoplant at 20 K FOM80K = 30 # Figure of merit for the cryoplant at 80 K # ========================== Tokamak ====================================== # [Tokamak] PrimaryCoolantType = \"CO2_NC\" # Can be CO2_C, CO2_NC, He_C, He_NC, H2O, FLiBe, LiPb SecondaryCoolantType = \"H2O\" # Can be CO2, H2O RatioType = \"1.5\" # Can be 1.5, 2, 2.5 SystemPressure = \"90\" # Can be 50, 90, 200 # ========================== PowerGenCaseByCase========================== # [PowerGenEquations] powergenOutletTemp = 500 # temperature related to the exchange of heat between the tokamak and the power generation system (Celsius) Structural Parameter Substitution Such substitutions can cause code compilation failures if not performed correctly, therefore caution should be taken when using configurations different to the defaults.","title":"Structural Parameters"},{"location":"API/plasma/","text":"Plasma Scenario # The Power Balance Model may take in a plasma scenario. This scenario is used for the generation of input profiles, such as the plasma heating and magnet currents. The values of each stage must be in ascending order and smaller than the end of the simulation at stopTime . Name Description Default value (s) plasma_ramp_up_start The end of the premagnetization stage, and when the plasma current begins to be ramped up 10 plasma_flat_top_start The plasma current is at its highest, and flat-top operation begins 20 plasma_flat_top_end Flat-top ends, and the plasma current starts to be ramped down 40 plasma_ramp_up_end The plasma current is now 0 A, end of plasma. Demagnetizaiton begins 50","title":"Plasma"},{"location":"API/plasma/#plasma-scenario","text":"The Power Balance Model may take in a plasma scenario. This scenario is used for the generation of input profiles, such as the plasma heating and magnet currents. The values of each stage must be in ascending order and smaller than the end of the simulation at stopTime . Name Description Default value (s) plasma_ramp_up_start The end of the premagnetization stage, and when the plasma current begins to be ramped up 10 plasma_flat_top_start The plasma current is at its highest, and flat-top operation begins 20 plasma_flat_top_end Flat-top ends, and the plasma current starts to be ramped down 40 plasma_ramp_up_end The plasma current is now 0 A, end of plasma. Demagnetizaiton begins 50","title":"Plasma Scenario"},{"location":"API/plugins/","text":"Plugins # Power Balance Models (PBM) supports extensions or \"plugins\" which act as wrappers preparing parameters and arguments before execution of the core API. These plugins may add additional commands to the CLI, or create the requirement input files to initialise a run. Managing Plugins # Plugin are installed by running: powerbalance plugins install <plugin-directory> and removed using the command: powerbalance plugins remove <plugin-name> you can view all currently installed plugins by running: powerbalance plugins list which will display the plugin name (used to remove plugins), and the path of the plugin relative to the power_balance/plugins internal directory. Plugin Development # Plugins are placed in the power_balance/plugins folder in order to be recognised by the central API, this process is automated by the powerbalance plugins install command when it is run on the plugin root directory. The command will search for the metadata file, plugin.toml , the location of which is taken to be the root of the plugin structure, and then create a new directory using the name of the plugin, as defined within the metadata file (e.g. if the key name in the plugin.toml file is \"My Project\", the plugin would be installed to power_balance/plugins/my_project ). All files within the root location and descending directories are copied during the installation. The plugin root directory must be importable, containing a __init__.py file: . \u251c\u2500\u2500 commands.py \u251c\u2500\u2500 plugin_functions.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 plugin.toml \u251c\u2500\u2500 my_plugin_tab_template.jinja \u2514\u2500\u2500 tests Verify your plugin is recognised by running powerbalance plugins to list those available. For configuration options see the relevant section here . The plugin.toml File # Plugins are defined within a TOML file which is placed in the root directory for that plugin. An example file may look like the following: name = \"My Plugin\" commands = [ \"commands:convert_data\" ] pre_run_script = \"plugin_setup:prepare_args\" [options.run.select_myplugin_mode] param_decls = [ \"--myplugin-mode\" ] help = \"Run mode for My Plugin\" [options.run.verbose] param_decls = [ \"--verbose/--not-verbose\" ] help = \"Run in higher verbosity\" [options.run.myplugin_outfile] param_decls = [ \"--myplugin-out\" , \"-b\" , \"mpout\" ] help = \"Output name for my plugin\" Key Description name Name of the plugin. commands List of additional click commmands to attach to the CLI (see below ) pre_run_script Script to run before pbm_main , the PBM main function call. options A dictionary of additional options to append to the main powerbalance subcommands, currently only modifications to run is supported. Appending Commands # To append additional commands to the powerbalance command group you must provide the path to the commands as a list the format module_path:command_function . In the example above the commands are defined in a file power_balance/plugins/my_plugin/commands.py : import click import os from .plugin_commands import demo_func @click . command () @click . argument ( \"input_file\" ) @click . option ( \"--format\" , \"-f\" , \"fmt\" , default = \"toml\" , help = \"Output file format: yaml, pickle, json, toml\" , ) @click . option ( \"--output-dir\" , \"-o\" , default = os . getcwd (), help = \"Output directory\" ) def convert_data ( fmt : str , output_dir : str ) -> None : demo_func ( fmt , output_dir ) the plugin.toml statement: commands = [ \"commands:convert_data\" ] then pointing to this click command. Appending Options # Further options can be added to the powerbalance run command, under the options.run key. These are defined with the same arguments given to click.option , where param_decls defines the flags and variable name for an option: [options.run.myplugin_outfile] param_decls = [ \"--myplugin-out\" , \"-b\" , \"mpout\" ] help = \"Output name for my plugin\" Modifying Parameters Before Setup # If your plugin prepares parameters for a PBM run you will want to modify the inputs given during powerbalance run to use those prepared instead. The key pre_run_script can be given the path of a function. This function must take a dictionary as an argument, this dictionary being the arguments given by the user to the CLI and thus the cli.session:pbm_main function. Your function should then update/add to this dictionary, and hence modify the inputs as required. Argument Modification Clashes Be very careful when modifying inputs, remember if running a simulation with more than one plugin each of these will modify the arguments. This may mean your plugin is not receiving the inputs you expect. Displaying Plugin Outputs # Plugins can themselves have displays, these are shown as additional tabs within the PBM browser. Displays are created as additional HTML content held within a Jinja template file. To get the correct expected name for your plugin template file consider loading your plugin.toml file into a variable to ensure the same name is used: plugins/my_plugin/__init__.py import toml import path PLUGIN_METADATA = toml . load ( os . path . join ( os . path . dirname ( __file__ ), \"plugin.toml\" ) ) plugins/my_plugin/results.py ... _display_file = get_plugin_display_filename ( PLUGIN_METADATA [ \"name\" ]) with open ( _display_file , 'w' ) as out_html : out_html . write ( plugin_html_str ) ... If your display requires extra HTML files make sure they have a name unique to the plugin and copy them to the correct location using the PLUGIN_DISPLAY_DIR variable: import shutil from power_balance.plugins import get_plugin_display_filename , PLUGIN_DISPLAY_DIR ... my_plugin_extra_html = \"my_plugin_extras.html\" component_file = os . path . join ( PLUGIN_DISPLAY_DIR , my_plugin_extra_html ) shutil . copy ( my_plugin_extra_html , component_file ) ...","title":"Plugin Creation"},{"location":"API/plugins/#plugins","text":"Power Balance Models (PBM) supports extensions or \"plugins\" which act as wrappers preparing parameters and arguments before execution of the core API. These plugins may add additional commands to the CLI, or create the requirement input files to initialise a run.","title":"Plugins"},{"location":"API/plugins/#managing-plugins","text":"Plugin are installed by running: powerbalance plugins install <plugin-directory> and removed using the command: powerbalance plugins remove <plugin-name> you can view all currently installed plugins by running: powerbalance plugins list which will display the plugin name (used to remove plugins), and the path of the plugin relative to the power_balance/plugins internal directory.","title":"Managing Plugins"},{"location":"API/plugins/#plugin-development","text":"Plugins are placed in the power_balance/plugins folder in order to be recognised by the central API, this process is automated by the powerbalance plugins install command when it is run on the plugin root directory. The command will search for the metadata file, plugin.toml , the location of which is taken to be the root of the plugin structure, and then create a new directory using the name of the plugin, as defined within the metadata file (e.g. if the key name in the plugin.toml file is \"My Project\", the plugin would be installed to power_balance/plugins/my_project ). All files within the root location and descending directories are copied during the installation. The plugin root directory must be importable, containing a __init__.py file: . \u251c\u2500\u2500 commands.py \u251c\u2500\u2500 plugin_functions.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 plugin.toml \u251c\u2500\u2500 my_plugin_tab_template.jinja \u2514\u2500\u2500 tests Verify your plugin is recognised by running powerbalance plugins to list those available. For configuration options see the relevant section here .","title":"Plugin Development"},{"location":"API/plugins/#the-plugintoml-file","text":"Plugins are defined within a TOML file which is placed in the root directory for that plugin. An example file may look like the following: name = \"My Plugin\" commands = [ \"commands:convert_data\" ] pre_run_script = \"plugin_setup:prepare_args\" [options.run.select_myplugin_mode] param_decls = [ \"--myplugin-mode\" ] help = \"Run mode for My Plugin\" [options.run.verbose] param_decls = [ \"--verbose/--not-verbose\" ] help = \"Run in higher verbosity\" [options.run.myplugin_outfile] param_decls = [ \"--myplugin-out\" , \"-b\" , \"mpout\" ] help = \"Output name for my plugin\" Key Description name Name of the plugin. commands List of additional click commmands to attach to the CLI (see below ) pre_run_script Script to run before pbm_main , the PBM main function call. options A dictionary of additional options to append to the main powerbalance subcommands, currently only modifications to run is supported.","title":"The plugin.toml File"},{"location":"API/plugins/#appending-commands","text":"To append additional commands to the powerbalance command group you must provide the path to the commands as a list the format module_path:command_function . In the example above the commands are defined in a file power_balance/plugins/my_plugin/commands.py : import click import os from .plugin_commands import demo_func @click . command () @click . argument ( \"input_file\" ) @click . option ( \"--format\" , \"-f\" , \"fmt\" , default = \"toml\" , help = \"Output file format: yaml, pickle, json, toml\" , ) @click . option ( \"--output-dir\" , \"-o\" , default = os . getcwd (), help = \"Output directory\" ) def convert_data ( fmt : str , output_dir : str ) -> None : demo_func ( fmt , output_dir ) the plugin.toml statement: commands = [ \"commands:convert_data\" ] then pointing to this click command.","title":"Appending Commands"},{"location":"API/plugins/#appending-options","text":"Further options can be added to the powerbalance run command, under the options.run key. These are defined with the same arguments given to click.option , where param_decls defines the flags and variable name for an option: [options.run.myplugin_outfile] param_decls = [ \"--myplugin-out\" , \"-b\" , \"mpout\" ] help = \"Output name for my plugin\"","title":"Appending Options"},{"location":"API/plugins/#modifying-parameters-before-setup","text":"If your plugin prepares parameters for a PBM run you will want to modify the inputs given during powerbalance run to use those prepared instead. The key pre_run_script can be given the path of a function. This function must take a dictionary as an argument, this dictionary being the arguments given by the user to the CLI and thus the cli.session:pbm_main function. Your function should then update/add to this dictionary, and hence modify the inputs as required. Argument Modification Clashes Be very careful when modifying inputs, remember if running a simulation with more than one plugin each of these will modify the arguments. This may mean your plugin is not receiving the inputs you expect.","title":"Modifying Parameters Before Setup"},{"location":"API/plugins/#displaying-plugin-outputs","text":"Plugins can themselves have displays, these are shown as additional tabs within the PBM browser. Displays are created as additional HTML content held within a Jinja template file. To get the correct expected name for your plugin template file consider loading your plugin.toml file into a variable to ensure the same name is used: plugins/my_plugin/__init__.py import toml import path PLUGIN_METADATA = toml . load ( os . path . join ( os . path . dirname ( __file__ ), \"plugin.toml\" ) ) plugins/my_plugin/results.py ... _display_file = get_plugin_display_filename ( PLUGIN_METADATA [ \"name\" ]) with open ( _display_file , 'w' ) as out_html : out_html . write ( plugin_html_str ) ... If your display requires extra HTML files make sure they have a name unique to the plugin and copy them to the correct location using the PLUGIN_DISPLAY_DIR variable: import shutil from power_balance.plugins import get_plugin_display_filename , PLUGIN_DISPLAY_DIR ... my_plugin_extra_html = \"my_plugin_extras.html\" component_file = os . path . join ( PLUGIN_DISPLAY_DIR , my_plugin_extra_html ) shutil . copy ( my_plugin_extra_html , component_file ) ...","title":"Displaying Plugin Outputs"},{"location":"API/poetry/","text":"Using Poetry # The easiest method for developing PBM is to use the tool poetry which combines handling of python dependencies, virtual environment, deployment and versioning. Installing PBM with Poetry # Poetry can be installed using pip : pip install --user poetry you can now install the development version of PBM by running: poetry install within the repository directory. This will create a virtual environment containing all Python modules required to run the project as defined within the pyproject.toml file. Any changes made within the repository will be picked up by poetry whenever the code is run. Running PBM with Poetry # There are two ways in which you can run the included powerbalance command. Either open a new shall within the created virtual environment: poetry shell then run: powerbalance or if you do not wish to leave the current shell prefix any command you want to run within the virtual environment with poetry run : poetry run powerbalance Troubleshooting # Troubleshooting # If you encounter issues with numpy as a dependency, this can usually fixed by installing it manually beforehand: poetry run pip install numpy Another problem encountered on Windows systems is with the installation of PyTables, the error usually states that HDF5 libraries could not be located and is due to there being no built wheels in the PyPi database for the user's Python version and system architecture (when this is the case Python attempts to build the module itself). A working solution is to download the relevant pytables wheels for Windows from here , then install them with pip: poetry run pip install <path-to-wheels-file> If you are using Poetry and the command poetry is not recognised after it has been installed, make sure the location of your poetry installation is added to PATH, to find the installation try running python -m poetry shell and noting the address given during the initialisation. For example for the case of a prefix of C:\\Users\\<user>\\AppData\\Local\\pypoetry , poetry was found in C:\\Users\\<user>\\AppData\\Local\\Packages\\PythonSoftwareFoundation.<python_version_string>\\LocalCache\\local-packages\\Python<version-num>\\Scripts . This location is then added to the PATH variable as described here or temporarily In the case of Windows: set \"PATH=%PATH%;<location-of-poetry.exe>\" for Linux/macOS: export PATH = <location-of-poetry>: $PATH If the command powerbalance is not available after install, you can also run the program via Python as normal: python <path-to-cloned-repo>/power_balance/cli/__init__.py","title":"Poetry"},{"location":"API/poetry/#using-poetry","text":"The easiest method for developing PBM is to use the tool poetry which combines handling of python dependencies, virtual environment, deployment and versioning.","title":"Using Poetry"},{"location":"API/poetry/#installing-pbm-with-poetry","text":"Poetry can be installed using pip : pip install --user poetry you can now install the development version of PBM by running: poetry install within the repository directory. This will create a virtual environment containing all Python modules required to run the project as defined within the pyproject.toml file. Any changes made within the repository will be picked up by poetry whenever the code is run.","title":"Installing PBM with Poetry"},{"location":"API/poetry/#running-pbm-with-poetry","text":"There are two ways in which you can run the included powerbalance command. Either open a new shall within the created virtual environment: poetry shell then run: powerbalance or if you do not wish to leave the current shell prefix any command you want to run within the virtual environment with poetry run : poetry run powerbalance","title":"Running PBM with Poetry"},{"location":"API/poetry/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"API/poetry/#troubleshooting_1","text":"If you encounter issues with numpy as a dependency, this can usually fixed by installing it manually beforehand: poetry run pip install numpy Another problem encountered on Windows systems is with the installation of PyTables, the error usually states that HDF5 libraries could not be located and is due to there being no built wheels in the PyPi database for the user's Python version and system architecture (when this is the case Python attempts to build the module itself). A working solution is to download the relevant pytables wheels for Windows from here , then install them with pip: poetry run pip install <path-to-wheels-file> If you are using Poetry and the command poetry is not recognised after it has been installed, make sure the location of your poetry installation is added to PATH, to find the installation try running python -m poetry shell and noting the address given during the initialisation. For example for the case of a prefix of C:\\Users\\<user>\\AppData\\Local\\pypoetry , poetry was found in C:\\Users\\<user>\\AppData\\Local\\Packages\\PythonSoftwareFoundation.<python_version_string>\\LocalCache\\local-packages\\Python<version-num>\\Scripts . This location is then added to the PATH variable as described here or temporarily In the case of Windows: set \"PATH=%PATH%;<location-of-poetry.exe>\" for Linux/macOS: export PATH = <location-of-poetry>: $PATH If the command powerbalance is not available after install, you can also run the program via Python as normal: python <path-to-cloned-repo>/power_balance/cli/__init__.py","title":"Troubleshooting"},{"location":"API/result_output/","text":"Data Output # Results of power generation and consumption modelling are saved to a dataframe object for each model executed. These data frames are stored to a Hierarchical Data Format 5 (HDF5) file which has the advantage of allowing for metadata to be saved alongside numerical values. The data frames can be easily retrieved using the Python module pandas , and provide a quick and easy way to perform analysis allowing the analyser to apply cuts to extract subsets they are interested in. This data format can also be loaded into other languages including R. Each dataframe is stored under a key matching its lower case name with . replaced by _ , e.g. Tokamak.Interdependencies \\(\\rightarrow\\) tokamak_interdependencies . iPython The Python module ipython provides an interactive Python session which has more features than the conventional Python prompt including better command history preservation. It is recommended for quickly checking a HDF5 output on the fly. Example: Plotting Cryogenic Power Consumption in the last 20 seconds As a case study, let us say we are only interested in the power consumption of the Cryogenic system ( \\(P_{cryo}\\) ) at \\(40 \\lt t \\leq 60\\) s. import pandas as pd import matplotlib.pyplot as plt import os from typing import Tuple def plot_pcryo ( data_frame : pd . DataFrame , time_interval : Tuple [ int , int ]) -> None : \"\"\"Plot Cryogenic power consumption within a time interval Parameters ---------- data_frame: pandas.DataFrame dataframe to plot time_interval: Tuple[int, int] time range as tuple \"\"\" # Apply cut to dataframe, could apply in one step but lets # do it in two for tidyness. Here we apply a cut to the 'time' variable _sub_df = data_frame [ data_frame [ 'time' ] > time_interval [ 0 ] ] # t1 < t _sub_df = _sub_df [ _sub_df [ 'time' ] <= time_interval [ 1 ] ] # t1 < t <= t2 # Now we can just directly specify which columns we want to plot X-Y plt . plot ( _sub_df [ 'time' ], _sub_df [ 'cryogenicpower' ] ) plt . xlabel ( 'Time/s' ) plt . ylabel ( '$P_ {cryo} /W$' ) plt . title ( 'Cryogenic Power Consumption' ) plt . show () if __name__ in \"__main__\" : # System path to output HDF5 file _file_path = 'pbm_results_2021_03_24_10_07_30/data/session_data.h5' # Key for model in file _df_key = 'tokamak_interdependencies' # Read the dataframe from the given file _data_frame = pd . read_hdf ( _file_path , key = _df_key ) plot_pcryo ( _data_frame , ( 40 , 60 ) ) HDF5 browser There are many applications and utilities that let you browse HDF5 files, some of these include: hdf5dump : a CLI tool which is part of HDF5 tools. HDFCompass : GUI based browser.","title":"Power Data"},{"location":"API/result_output/#data-output","text":"Results of power generation and consumption modelling are saved to a dataframe object for each model executed. These data frames are stored to a Hierarchical Data Format 5 (HDF5) file which has the advantage of allowing for metadata to be saved alongside numerical values. The data frames can be easily retrieved using the Python module pandas , and provide a quick and easy way to perform analysis allowing the analyser to apply cuts to extract subsets they are interested in. This data format can also be loaded into other languages including R. Each dataframe is stored under a key matching its lower case name with . replaced by _ , e.g. Tokamak.Interdependencies \\(\\rightarrow\\) tokamak_interdependencies . iPython The Python module ipython provides an interactive Python session which has more features than the conventional Python prompt including better command history preservation. It is recommended for quickly checking a HDF5 output on the fly. Example: Plotting Cryogenic Power Consumption in the last 20 seconds As a case study, let us say we are only interested in the power consumption of the Cryogenic system ( \\(P_{cryo}\\) ) at \\(40 \\lt t \\leq 60\\) s. import pandas as pd import matplotlib.pyplot as plt import os from typing import Tuple def plot_pcryo ( data_frame : pd . DataFrame , time_interval : Tuple [ int , int ]) -> None : \"\"\"Plot Cryogenic power consumption within a time interval Parameters ---------- data_frame: pandas.DataFrame dataframe to plot time_interval: Tuple[int, int] time range as tuple \"\"\" # Apply cut to dataframe, could apply in one step but lets # do it in two for tidyness. Here we apply a cut to the 'time' variable _sub_df = data_frame [ data_frame [ 'time' ] > time_interval [ 0 ] ] # t1 < t _sub_df = _sub_df [ _sub_df [ 'time' ] <= time_interval [ 1 ] ] # t1 < t <= t2 # Now we can just directly specify which columns we want to plot X-Y plt . plot ( _sub_df [ 'time' ], _sub_df [ 'cryogenicpower' ] ) plt . xlabel ( 'Time/s' ) plt . ylabel ( '$P_ {cryo} /W$' ) plt . title ( 'Cryogenic Power Consumption' ) plt . show () if __name__ in \"__main__\" : # System path to output HDF5 file _file_path = 'pbm_results_2021_03_24_10_07_30/data/session_data.h5' # Key for model in file _df_key = 'tokamak_interdependencies' # Read the dataframe from the given file _data_frame = pd . read_hdf ( _file_path , key = _df_key ) plot_pcryo ( _data_frame , ( 40 , 60 ) ) HDF5 browser There are many applications and utilities that let you browse HDF5 files, some of these include: hdf5dump : a CLI tool which is part of HDF5 tools. HDFCompass : GUI based browser.","title":"Data Output"},{"location":"API/setup_overview/","text":"Configuring a Run # Properties for a Power Balance Models (PBM) are set via configuration files which are in the TOML format. These are parsed as inputs and used to specify model selection and parameter values. TOML files TOML files can be commented! Do take advantage of this when writing your PBM configs for future reference by yourself or others. For more information on how to write TOML files see the documentation site . Configuration priority If an option is specified within the configuration file AND on the command line interface, the latter is prioritised.","title":"Overview"},{"location":"API/setup_overview/#configuring-a-run","text":"Properties for a Power Balance Models (PBM) are set via configuration files which are in the TOML format. These are parsed as inputs and used to specify model selection and parameter values. TOML files TOML files can be commented! Do take advantage of this when writing your PBM configs for future reference by yourself or others. For more information on how to write TOML files see the documentation site . Configuration priority If an option is specified within the configuration file AND on the command line interface, the latter is prioritised.","title":"Configuring a Run"},{"location":"API/simulation_opts/","text":"Simulation Options # Simulation options are those found within Modelica itself and determine the time interval, solver choice etc. The options are written in a TOML file placed in the same directory as parameter options . The name of this file should be specified within the API configuration file via the simulation_options_file key. This configuration is validated before the session is run. The default file parameters/simulation_options.toml contained within the PBM module has the contents: startTime = 0 stopTime = 60 stepSize = 0.01 tolerance = 1e-012 solver = \"dassl\" these options being defined as: Option Description startTime Simulation data record start time in seconds stopTime Simulation data record stop time in seconds stepSize Frequency of data collection tolerance Tolerance of the solver solver Choice of solver Case sensitivity These options are case sensitive, make sure to correctly specify the keys above. Solver Types # Recognised solver types: dassl ida cvode impeuler trapezoid imprungekutta euler heun rungekutta rungekuttaSsc irksco symSolver symSolverSsc qss","title":"Simulation"},{"location":"API/simulation_opts/#simulation-options","text":"Simulation options are those found within Modelica itself and determine the time interval, solver choice etc. The options are written in a TOML file placed in the same directory as parameter options . The name of this file should be specified within the API configuration file via the simulation_options_file key. This configuration is validated before the session is run. The default file parameters/simulation_options.toml contained within the PBM module has the contents: startTime = 0 stopTime = 60 stepSize = 0.01 tolerance = 1e-012 solver = \"dassl\" these options being defined as: Option Description startTime Simulation data record start time in seconds stopTime Simulation data record stop time in seconds stepSize Frequency of data collection tolerance Tolerance of the solver solver Choice of solver Case sensitivity These options are case sensitive, make sure to correctly specify the keys above.","title":"Simulation Options"},{"location":"API/simulation_opts/#solver-types","text":"Recognised solver types: dassl ida cvode impeuler trapezoid imprungekutta euler heun rungekutta rungekuttaSsc irksco symSolver symSolverSsc qss","title":"Solver Types"},{"location":"API/troubleshooting/","text":"Troubleshooting # Numpy dependency # You may encounter issues with numpy as a dependency, this can usually fixed by installing it manually beforehand: pip install numpy if you are using Poetry make sure to run this command within the virtual environment: poetry run pip install numpy PyTables build # Releases of PyTables for the latest version of Python are often not yet available. When an existing build is not downloadable pip will attempt to build the module locally. If required libraries are unavailable this build will likely fail and prevent installation. To fix this you should find a pytables wheels file appropriate to your system and Python installation here . Install this file by running: pip install <path-to-wheels-file> or if using Poetry: poetry run pip install <path-to-wheels-file> Command poetry is not recognised # If you are using Poetry and the command poetry is not recognised after installation make sure the location of your poetry installation is added to the PATH environment variable. To find your local installation run: python -m poetry shell and note the location given during the initialisation. For example in the case of the prefix C:\\Users\\<user>\\AppData\\Local\\pypoetry on Windows, poetry was found in C:\\Users\\<user>\\AppData\\Local\\Packages\\PythonSoftwareFoundation.<python_version_string>\\LocalCache\\local-packages\\Python<version-num>\\Scripts and this location is added to the PATH variable as described here or temporarily by running: set \"PATH=%PATH%;<location-of-poetry.exe>\" Command powerbalance is not recognised # If the command powerbalance is not recognised an alternative method for running Power Balance Models is to run the Python script: python <path-to-clone-repo>/power_balance/cli/__init__.py","title":"Troubleshooting"},{"location":"API/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"API/troubleshooting/#numpy-dependency","text":"You may encounter issues with numpy as a dependency, this can usually fixed by installing it manually beforehand: pip install numpy if you are using Poetry make sure to run this command within the virtual environment: poetry run pip install numpy","title":"Numpy dependency"},{"location":"API/troubleshooting/#pytables-build","text":"Releases of PyTables for the latest version of Python are often not yet available. When an existing build is not downloadable pip will attempt to build the module locally. If required libraries are unavailable this build will likely fail and prevent installation. To fix this you should find a pytables wheels file appropriate to your system and Python installation here . Install this file by running: pip install <path-to-wheels-file> or if using Poetry: poetry run pip install <path-to-wheels-file>","title":"PyTables build"},{"location":"API/troubleshooting/#command-poetry-is-not-recognised","text":"If you are using Poetry and the command poetry is not recognised after installation make sure the location of your poetry installation is added to the PATH environment variable. To find your local installation run: python -m poetry shell and note the location given during the initialisation. For example in the case of the prefix C:\\Users\\<user>\\AppData\\Local\\pypoetry on Windows, poetry was found in C:\\Users\\<user>\\AppData\\Local\\Packages\\PythonSoftwareFoundation.<python_version_string>\\LocalCache\\local-packages\\Python<version-num>\\Scripts and this location is added to the PATH variable as described here or temporarily by running: set \"PATH=%PATH%;<location-of-poetry.exe>\"","title":"Command poetry is not recognised"},{"location":"API/troubleshooting/#command-powerbalance-is-not-recognised","text":"If the command powerbalance is not recognised an alternative method for running Power Balance Models is to run the Python script: python <path-to-clone-repo>/power_balance/cli/__init__.py","title":"Command powerbalance is not recognised"},{"location":"API/validation/","text":"Validation of Inputs # Validation of inputs is performed using pydantic and is based on model representations of the different configuration files, these models being classes within the source code. The attributes for these classes coincide with the keys for the relevant dictionary to be tested, in the case of Power Balance Models these are dictionaries read from TOML files. The current schemas are loose but demonstrate the process for possible tightening of constraints in future. API Configuration Validation # The global configuration or API configuration input is validated with the following rules: Key Rule Required models Must be of type List[str] and contain models defined within the specified models directory.* parameters_directory Must be a filename, not a path. simulation_options_file Must be a filename, not a path.. plasma_scenario_file Must be a filename, not a path. structural_params_file Must be a filename, not a path. profiles_directory Must be the path to an existing directory. parameters_directory Must be the path to an existing directory. modelica_file_directory Must be the path to an existing directory. sweep Must be of type Dict[str, List[T]] . Where all items in list are the same type. sweep_mode Must be one of set or combinations . * This rule does not apply if add_model is used within the API to add a model after the configuration. Simulation Options Validation # The Modelica simulation options configuration is validated with the following rules: Key Rule Required stopTime Must be of type int and be above 1. startTime Must be of type int and be positive. stepSize Must be of type int or float , and be positive. solver Must be either of type string and recognised tolerance Must be of type float and positive. A check is also applied to ensure that the startTime is before the stopTime , and that the stepSize is less than the stopTime . Plasma Scenario Validation # The plasma scenario configuration is validated with the following rules: Key Rule Required plasma_ramp_up_start Must be a positive integer. plasma_flat_top_start Must be a positive integer. plasma_flat_top_end Must be a positive integer. plasma_ramp_down_end Must be a positive integer. A check is also applied to ensure that the above are in the given order of increasing magnitude.","title":"Input Validation"},{"location":"API/validation/#validation-of-inputs","text":"Validation of inputs is performed using pydantic and is based on model representations of the different configuration files, these models being classes within the source code. The attributes for these classes coincide with the keys for the relevant dictionary to be tested, in the case of Power Balance Models these are dictionaries read from TOML files. The current schemas are loose but demonstrate the process for possible tightening of constraints in future.","title":"Validation of Inputs"},{"location":"API/validation/#api-configuration-validation","text":"The global configuration or API configuration input is validated with the following rules: Key Rule Required models Must be of type List[str] and contain models defined within the specified models directory.* parameters_directory Must be a filename, not a path. simulation_options_file Must be a filename, not a path.. plasma_scenario_file Must be a filename, not a path. structural_params_file Must be a filename, not a path. profiles_directory Must be the path to an existing directory. parameters_directory Must be the path to an existing directory. modelica_file_directory Must be the path to an existing directory. sweep Must be of type Dict[str, List[T]] . Where all items in list are the same type. sweep_mode Must be one of set or combinations . * This rule does not apply if add_model is used within the API to add a model after the configuration.","title":"API Configuration Validation"},{"location":"API/validation/#simulation-options-validation","text":"The Modelica simulation options configuration is validated with the following rules: Key Rule Required stopTime Must be of type int and be above 1. startTime Must be of type int and be positive. stepSize Must be of type int or float , and be positive. solver Must be either of type string and recognised tolerance Must be of type float and positive. A check is also applied to ensure that the startTime is before the stopTime , and that the stepSize is less than the stopTime .","title":"Simulation Options Validation"},{"location":"API/validation/#plasma-scenario-validation","text":"The plasma scenario configuration is validated with the following rules: Key Rule Required plasma_ramp_up_start Must be a positive integer. plasma_flat_top_start Must be a positive integer. plasma_flat_top_end Must be a positive integer. plasma_ramp_down_end Must be a positive integer. A check is also applied to ensure that the above are in the given order of increasing magnitude.","title":"Plasma Scenario Validation"},{"location":"Reference/power_balance/","text":"power_balance # Source: power_balance/__init__.py","title":"power_balance"},{"location":"Reference/power_balance/#power_balance","text":"Source: power_balance/__init__.py","title":"power_balance"},{"location":"Reference/power_balance/core/","text":"power_balance.core # Source: power_balance/core.py Class PowerBalance # PowerBalance ( config : str = '/home/runner/work/powerbalance/powerbalance/power_balance/configs/default_config.toml' , no_browser : bool = False , modelica_file_dir : str = 'Default' , profiles_directory : str = 'Default' , parameter_directory : str = 'Default' , print_intro : bool = False ) -> None Source: power_balance/core.py Main Power Balance class for running the Modelica models contained within the 'models' submodule. This class handles compiling and running, as well as the setting of parameter values. Attributes # power_data : Dict[str, pd.DataFrame] , typing. power data stored after a simulation run (else None) configuration : Dict[str, typing.Any] , typing. current configuration options as dictionary Methods # add_models # add_models ( self , model_path : str , model_names : List [ str ] = None ) -> None Source: power_balance/core.py Read model(s) from a given OM file and add to simulation list. Parameters # model_path : str file address of the modelica file containing the models model_names : typing.List , default None list of models to import by name, by default all apply_model_configuration # apply_model_configuration ( self , model_name : str ) -> None Source: power_balance/core.py Applies the configuration within the configuration options provided. Parameters # model_name : str name of model to apply configuration to clear_cache # clear_cache ( self ) -> None Source: power_balance/core.py Clear the PyDelica session cache As we do not use pydelica.Session as a context manager we need to do the cache clear manually (else risking leaving a lot of temporary directories on Windows) get_parameters # get_parameters ( self , model : str = None , include_undefined : bool = False ) -> Any Source: power_balance/core.py Retrieve all model parameters including those that cannot be modified Parameters # model : str , default None name of model to retrieve parameters from, by default first compiled include_undefined : bool , default False include parameters with a value of 'None', by default False Returns # typing.Any a dictionary of the model parameters and their values get_power # get_power ( self , model_name : str ) -> pandas . core . frame . DataFrame Source: power_balance/core.py Retrieve the power results from a Modelica model after simulation Parameters # model_name : str name of the Modelica model Returns # pandas.core.frame.DataFrame dataframe containing the power values for each of the subsystems launch_browser # launch_browser ( self ) -> None Source: power_balance/core.py Opens local web browser to view result plots load_parameters # load_parameters ( self , directory : str ) -> None Source: power_balance/core.py Load parameters from a given directory specifying which file is the simulation options file Parameters # directory : str directory containing all parameter TOML files modifiable_parameters # modifiable_parameters ( self ) -> List [ str ] Source: power_balance/core.py Get a list of parameters that can be modified by the user Returns # typing.List list of parameters which can be modified plot_results # plot_results ( self , output_directory : str ) -> List [ str ] Source: power_balance/core.py Create all plots images for all power variables. Parameters # output_directory : str directory to save created images. Returns # typing.List list of output plot file names read_models_from_directory # read_models_from_directory ( self ) -> None Source: power_balance/core.py Read all Modelica '.mo' files from the directory given Reads the models from the directory given within the configuration this directory is changed to a temporary directory if any templating of the Modelica models is required (e.g. addition of PF magnets) remove_models # remove_models ( self , model_names : List [ str ]) -> None Source: power_balance/core.py Remove models from the power_balance.PowerBalance instance so they are not run during simulation Parameters # model_names : typing.List list of names of models to remove run_simulation # run_simulation ( self , output_directory : str = '' , sweep_dict : Optional [ Dict [ str , Any ]] = None ) -> None Source: power_balance/core.py Acts as a driver for the back end functions handling the interface with OpenModelica Parameters # output_directory : str , default ```` directory for output files sweep_dict : typing.Optional , default None perform sweep for the given parameters using a dictionary containing range information, by default None (no sweep) save_configuration # save_configuration ( self , output_directory : str ) -> None Source: power_balance/core.py Save configuration for the session so it can be loaded later Parameters # output_directory : str directory to save the config folder to save_parameters # save_parameters ( self , output_directory : str ) -> None Source: power_balance/core.py Save parameters for the session so they can be loaded later Parameters # output_directory : str directory to save the parameter sets to save_profiles # save_profiles ( self , output_directory : str ) -> None Source: power_balance/core.py Save profiles for the session so they can be loaded later Parameters # output_directory : str directory to save the profile folder to set_model_parameters # set_model_parameters ( self , model_name : str , allow_param_failure : bool = False ) -> None Source: power_balance/core.py Read parameters from the parameter set object within the API and then assign them to the given Modelica System Parameters # model_name : str the name of the model allow_param_failure : bool , default False whether or not a failed parameter search during assignment throws an exception, by default False set_parameter_value # set_parameter_value ( self , parameter_name : str , value : Any ) -> Any Source: power_balance/core.py typing.Tuple a parameter within the parameter set to a given value. Parameters # parameter_name : str name of the parameter to be modified value : typing.Any new value to assign to that parameter Returns # typing.Any the value read from the parameter after it has been set update_model_input_paths # update_model_input_paths ( self ) -> None Source: power_balance/core.py Replace all variables defined as 'Path' variables with an absolute path in order to correctly read in the required inputs. write_data # write_data ( self , output_directory : str ) -> None Source: power_balance/core.py Write the resulting data frames to a HDF5 file which allows inclusion of various key metadata alongside the datasets Parameters # output_directory : str location to write output data files get_plugins # get_plugins ( plugin_order_list : List [ str ] = None ) -> Tuple [ str , ... ] Source: power_balance/core.py save_plugin_displays # save_plugin_displays ( output_directory : str ) -> None Source: power_balance/core.py Save the plugin display files so they can be loaded later Parameters # output_directory : str directory to save the display folder to","title":"core"},{"location":"Reference/power_balance/core/#power_balancecore","text":"Source: power_balance/core.py","title":"power_balance.core"},{"location":"Reference/power_balance/core/#class-powerbalance","text":"PowerBalance ( config : str = '/home/runner/work/powerbalance/powerbalance/power_balance/configs/default_config.toml' , no_browser : bool = False , modelica_file_dir : str = 'Default' , profiles_directory : str = 'Default' , parameter_directory : str = 'Default' , print_intro : bool = False ) -> None Source: power_balance/core.py Main Power Balance class for running the Modelica models contained within the 'models' submodule. This class handles compiling and running, as well as the setting of parameter values.","title":"Class PowerBalance"},{"location":"Reference/power_balance/core/#attributes","text":"power_data : Dict[str, pd.DataFrame] , typing. power data stored after a simulation run (else None) configuration : Dict[str, typing.Any] , typing. current configuration options as dictionary","title":"Attributes"},{"location":"Reference/power_balance/core/#methods","text":"","title":"Methods"},{"location":"Reference/power_balance/core/#add_models","text":"add_models ( self , model_path : str , model_names : List [ str ] = None ) -> None Source: power_balance/core.py Read model(s) from a given OM file and add to simulation list.","title":"add_models"},{"location":"Reference/power_balance/core/#parameters","text":"model_path : str file address of the modelica file containing the models model_names : typing.List , default None list of models to import by name, by default all","title":"Parameters"},{"location":"Reference/power_balance/core/#apply_model_configuration","text":"apply_model_configuration ( self , model_name : str ) -> None Source: power_balance/core.py Applies the configuration within the configuration options provided.","title":"apply_model_configuration"},{"location":"Reference/power_balance/core/#parameters_1","text":"model_name : str name of model to apply configuration to","title":"Parameters"},{"location":"Reference/power_balance/core/#clear_cache","text":"clear_cache ( self ) -> None Source: power_balance/core.py Clear the PyDelica session cache As we do not use pydelica.Session as a context manager we need to do the cache clear manually (else risking leaving a lot of temporary directories on Windows)","title":"clear_cache"},{"location":"Reference/power_balance/core/#get_parameters","text":"get_parameters ( self , model : str = None , include_undefined : bool = False ) -> Any Source: power_balance/core.py Retrieve all model parameters including those that cannot be modified","title":"get_parameters"},{"location":"Reference/power_balance/core/#parameters_2","text":"model : str , default None name of model to retrieve parameters from, by default first compiled include_undefined : bool , default False include parameters with a value of 'None', by default False","title":"Parameters"},{"location":"Reference/power_balance/core/#returns","text":"typing.Any a dictionary of the model parameters and their values","title":"Returns"},{"location":"Reference/power_balance/core/#get_power","text":"get_power ( self , model_name : str ) -> pandas . core . frame . DataFrame Source: power_balance/core.py Retrieve the power results from a Modelica model after simulation","title":"get_power"},{"location":"Reference/power_balance/core/#parameters_3","text":"model_name : str name of the Modelica model","title":"Parameters"},{"location":"Reference/power_balance/core/#returns_1","text":"pandas.core.frame.DataFrame dataframe containing the power values for each of the subsystems","title":"Returns"},{"location":"Reference/power_balance/core/#launch_browser","text":"launch_browser ( self ) -> None Source: power_balance/core.py Opens local web browser to view result plots","title":"launch_browser"},{"location":"Reference/power_balance/core/#load_parameters","text":"load_parameters ( self , directory : str ) -> None Source: power_balance/core.py Load parameters from a given directory specifying which file is the simulation options file","title":"load_parameters"},{"location":"Reference/power_balance/core/#parameters_4","text":"directory : str directory containing all parameter TOML files","title":"Parameters"},{"location":"Reference/power_balance/core/#modifiable_parameters","text":"modifiable_parameters ( self ) -> List [ str ] Source: power_balance/core.py Get a list of parameters that can be modified by the user","title":"modifiable_parameters"},{"location":"Reference/power_balance/core/#returns_2","text":"typing.List list of parameters which can be modified","title":"Returns"},{"location":"Reference/power_balance/core/#plot_results","text":"plot_results ( self , output_directory : str ) -> List [ str ] Source: power_balance/core.py Create all plots images for all power variables.","title":"plot_results"},{"location":"Reference/power_balance/core/#parameters_5","text":"output_directory : str directory to save created images.","title":"Parameters"},{"location":"Reference/power_balance/core/#returns_3","text":"typing.List list of output plot file names","title":"Returns"},{"location":"Reference/power_balance/core/#read_models_from_directory","text":"read_models_from_directory ( self ) -> None Source: power_balance/core.py Read all Modelica '.mo' files from the directory given Reads the models from the directory given within the configuration this directory is changed to a temporary directory if any templating of the Modelica models is required (e.g. addition of PF magnets)","title":"read_models_from_directory"},{"location":"Reference/power_balance/core/#remove_models","text":"remove_models ( self , model_names : List [ str ]) -> None Source: power_balance/core.py Remove models from the power_balance.PowerBalance instance so they are not run during simulation","title":"remove_models"},{"location":"Reference/power_balance/core/#parameters_6","text":"model_names : typing.List list of names of models to remove","title":"Parameters"},{"location":"Reference/power_balance/core/#run_simulation","text":"run_simulation ( self , output_directory : str = '' , sweep_dict : Optional [ Dict [ str , Any ]] = None ) -> None Source: power_balance/core.py Acts as a driver for the back end functions handling the interface with OpenModelica","title":"run_simulation"},{"location":"Reference/power_balance/core/#parameters_7","text":"output_directory : str , default ```` directory for output files sweep_dict : typing.Optional , default None perform sweep for the given parameters using a dictionary containing range information, by default None (no sweep)","title":"Parameters"},{"location":"Reference/power_balance/core/#save_configuration","text":"save_configuration ( self , output_directory : str ) -> None Source: power_balance/core.py Save configuration for the session so it can be loaded later","title":"save_configuration"},{"location":"Reference/power_balance/core/#parameters_8","text":"output_directory : str directory to save the config folder to","title":"Parameters"},{"location":"Reference/power_balance/core/#save_parameters","text":"save_parameters ( self , output_directory : str ) -> None Source: power_balance/core.py Save parameters for the session so they can be loaded later","title":"save_parameters"},{"location":"Reference/power_balance/core/#parameters_9","text":"output_directory : str directory to save the parameter sets to","title":"Parameters"},{"location":"Reference/power_balance/core/#save_profiles","text":"save_profiles ( self , output_directory : str ) -> None Source: power_balance/core.py Save profiles for the session so they can be loaded later","title":"save_profiles"},{"location":"Reference/power_balance/core/#parameters_10","text":"output_directory : str directory to save the profile folder to","title":"Parameters"},{"location":"Reference/power_balance/core/#set_model_parameters","text":"set_model_parameters ( self , model_name : str , allow_param_failure : bool = False ) -> None Source: power_balance/core.py Read parameters from the parameter set object within the API and then assign them to the given Modelica System","title":"set_model_parameters"},{"location":"Reference/power_balance/core/#parameters_11","text":"model_name : str the name of the model allow_param_failure : bool , default False whether or not a failed parameter search during assignment throws an exception, by default False","title":"Parameters"},{"location":"Reference/power_balance/core/#set_parameter_value","text":"set_parameter_value ( self , parameter_name : str , value : Any ) -> Any Source: power_balance/core.py typing.Tuple a parameter within the parameter set to a given value.","title":"set_parameter_value"},{"location":"Reference/power_balance/core/#parameters_12","text":"parameter_name : str name of the parameter to be modified value : typing.Any new value to assign to that parameter","title":"Parameters"},{"location":"Reference/power_balance/core/#returns_4","text":"typing.Any the value read from the parameter after it has been set","title":"Returns"},{"location":"Reference/power_balance/core/#update_model_input_paths","text":"update_model_input_paths ( self ) -> None Source: power_balance/core.py Replace all variables defined as 'Path' variables with an absolute path in order to correctly read in the required inputs.","title":"update_model_input_paths"},{"location":"Reference/power_balance/core/#write_data","text":"write_data ( self , output_directory : str ) -> None Source: power_balance/core.py Write the resulting data frames to a HDF5 file which allows inclusion of various key metadata alongside the datasets","title":"write_data"},{"location":"Reference/power_balance/core/#parameters_13","text":"output_directory : str location to write output data files","title":"Parameters"},{"location":"Reference/power_balance/core/#get_plugins","text":"get_plugins ( plugin_order_list : List [ str ] = None ) -> Tuple [ str , ... ] Source: power_balance/core.py","title":"get_plugins"},{"location":"Reference/power_balance/core/#save_plugin_displays","text":"save_plugin_displays ( output_directory : str ) -> None Source: power_balance/core.py Save the plugin display files so they can be loaded later","title":"save_plugin_displays"},{"location":"Reference/power_balance/core/#parameters_14","text":"output_directory : str directory to save the display folder to","title":"Parameters"},{"location":"Reference/power_balance/utilities/","text":"power_balance.utilities # Source: power_balance/utilities.py Utilities for PowerBalance API Contains assorted utility functions used within the Power Balance API convert_to_value # convert_to_value ( value_str : Any ) -> Any Source: power_balance/utilities.py expand_dictionary # expand_dictionary ( input_dict : Dict [ str , Any ], output_dict : Dict [ str , Any ] = None , separator : str = '.' ) -> Dict [ str , Any ] Source: power_balance/utilities.py Convert a single level dictionary with keys containing a separator into a nested dictionary. Parameters # input_dict : typing.Dict dictionary to expand separator : str , default . character which defines dictionary levels in key Other arguments are for internal use. Returns # typing.Dict expanded dictionary with nested levels flatten_dictionary # flatten_dictionary ( input_dict : Dict [ str , Any ], output_dict : Dict [ str , Any ] = None , parent_key : str = None , separator : str = '.' ) -> Dict [ str , Any ] Source: power_balance/utilities.py Convert a dictionary of dictionaries into a single level dictionary with keys in the form A{separator}B . Parameters # input_dict : typing.Dict input dictionary object to flatten separator : str , default . character to use for key address, by default \".\" Other arguments are for internal use. Returns # typing.Dict flattened single level dictionary representation of input dictionary with levels represented by the given separator","title":"utilities"},{"location":"Reference/power_balance/utilities/#power_balanceutilities","text":"Source: power_balance/utilities.py Utilities for PowerBalance API Contains assorted utility functions used within the Power Balance API","title":"power_balance.utilities"},{"location":"Reference/power_balance/utilities/#convert_to_value","text":"convert_to_value ( value_str : Any ) -> Any Source: power_balance/utilities.py","title":"convert_to_value"},{"location":"Reference/power_balance/utilities/#expand_dictionary","text":"expand_dictionary ( input_dict : Dict [ str , Any ], output_dict : Dict [ str , Any ] = None , separator : str = '.' ) -> Dict [ str , Any ] Source: power_balance/utilities.py Convert a single level dictionary with keys containing a separator into a nested dictionary.","title":"expand_dictionary"},{"location":"Reference/power_balance/utilities/#parameters","text":"input_dict : typing.Dict dictionary to expand separator : str , default . character which defines dictionary levels in key Other arguments are for internal use.","title":"Parameters"},{"location":"Reference/power_balance/utilities/#returns","text":"typing.Dict expanded dictionary with nested levels","title":"Returns"},{"location":"Reference/power_balance/utilities/#flatten_dictionary","text":"flatten_dictionary ( input_dict : Dict [ str , Any ], output_dict : Dict [ str , Any ] = None , parent_key : str = None , separator : str = '.' ) -> Dict [ str , Any ] Source: power_balance/utilities.py Convert a dictionary of dictionaries into a single level dictionary with keys in the form A{separator}B .","title":"flatten_dictionary"},{"location":"Reference/power_balance/utilities/#parameters_1","text":"input_dict : typing.Dict input dictionary object to flatten separator : str , default . character to use for key address, by default \".\" Other arguments are for internal use.","title":"Parameters"},{"location":"Reference/power_balance/utilities/#returns_1","text":"typing.Dict flattened single level dictionary representation of input dictionary with levels represented by the given separator","title":"Returns"},{"location":"Reference/power_balance/browser/","text":"power_balance.browser # Source: power_balance/browser/__init__.py Class PBMBrowser # PBMBrowser ( session_dir : str ) -> None Source: power_balance/browser/__init__.py Class for creation of native browser window for plot display Methods # build # build ( self , plasma_scenario : dict ) -> None Source: power_balance/browser/__init__.py Build the main webpage for plot display. launch # launch ( self ) -> None Source: power_balance/browser/__init__.py Open the plot page in the native web browser.","title":"browser"},{"location":"Reference/power_balance/browser/#power_balancebrowser","text":"Source: power_balance/browser/__init__.py","title":"power_balance.browser"},{"location":"Reference/power_balance/browser/#class-pbmbrowser","text":"PBMBrowser ( session_dir : str ) -> None Source: power_balance/browser/__init__.py Class for creation of native browser window for plot display","title":"Class PBMBrowser"},{"location":"Reference/power_balance/browser/#methods","text":"","title":"Methods"},{"location":"Reference/power_balance/browser/#build","text":"build ( self , plasma_scenario : dict ) -> None Source: power_balance/browser/__init__.py Build the main webpage for plot display.","title":"build"},{"location":"Reference/power_balance/browser/#launch","text":"launch ( self ) -> None Source: power_balance/browser/__init__.py Open the plot page in the native web browser.","title":"launch"},{"location":"Reference/power_balance/browser/html_templates/","text":"power_balance.browser.html_templates # Source: power_balance/browser/html_templates/__init__.py jinja_func_dict_items # jinja_func_dict_items ( dictionary ) Source: power_balance/browser/html_templates/__init__.py jinja_func_is_dict # jinja_func_is_dict ( obj ) Source: power_balance/browser/html_templates/__init__.py jinja_group_header # jinja_group_header ( group_label ) Source: power_balance/browser/html_templates/__init__.py render_parameter_table # render_parameter_table ( parameter_set ) -> str Source: power_balance/browser/html_templates/__init__.py Create the HTML for the parameter set table Parameters # parameter_set parameter set object to be displayed Returns # str HTML for tabular representation","title":"html_templates"},{"location":"Reference/power_balance/browser/html_templates/#power_balancebrowserhtml_templates","text":"Source: power_balance/browser/html_templates/__init__.py","title":"power_balance.browser.html_templates"},{"location":"Reference/power_balance/browser/html_templates/#jinja_func_dict_items","text":"jinja_func_dict_items ( dictionary ) Source: power_balance/browser/html_templates/__init__.py","title":"jinja_func_dict_items"},{"location":"Reference/power_balance/browser/html_templates/#jinja_func_is_dict","text":"jinja_func_is_dict ( obj ) Source: power_balance/browser/html_templates/__init__.py","title":"jinja_func_is_dict"},{"location":"Reference/power_balance/browser/html_templates/#jinja_group_header","text":"jinja_group_header ( group_label ) Source: power_balance/browser/html_templates/__init__.py","title":"jinja_group_header"},{"location":"Reference/power_balance/browser/html_templates/#render_parameter_table","text":"render_parameter_table ( parameter_set ) -> str Source: power_balance/browser/html_templates/__init__.py Create the HTML for the parameter set table","title":"render_parameter_table"},{"location":"Reference/power_balance/browser/html_templates/#parameters","text":"parameter_set parameter set object to be displayed","title":"Parameters"},{"location":"Reference/power_balance/browser/html_templates/#returns","text":"str HTML for tabular representation","title":"Returns"},{"location":"Reference/power_balance/calc/","text":"power_balance.calc # Source: power_balance/calc/__init__.py Class Efficiency # Efficiency ( name : str , numerator_name : str , denominator_name : str , description : str = '' ) -> None Source: power_balance/calc/__init__.py Methods # calculate # calculate ( self , numerator : Union [ float , numpy . ndarray ], denominator : Union [ float , numpy . ndarray ]) -> float Source: power_balance/calc/__init__.py Calculate an efficiency from the given values and save it If the specified arguments are arrays the average of each is used. Parameters # numerator : typing.Union numerator value denominator : typing.Union denominator value Returns # float efficiency value construct_html_form # construct_html_form ( self ) -> str Source: power_balance/calc/__init__.py value # value ( self ) Source: power_balance/calc/__init__.py Retrieve Efficiency value","title":"calc"},{"location":"Reference/power_balance/calc/#power_balancecalc","text":"Source: power_balance/calc/__init__.py","title":"power_balance.calc"},{"location":"Reference/power_balance/calc/#class-efficiency","text":"Efficiency ( name : str , numerator_name : str , denominator_name : str , description : str = '' ) -> None Source: power_balance/calc/__init__.py","title":"Class Efficiency"},{"location":"Reference/power_balance/calc/#methods","text":"","title":"Methods"},{"location":"Reference/power_balance/calc/#calculate","text":"calculate ( self , numerator : Union [ float , numpy . ndarray ], denominator : Union [ float , numpy . ndarray ]) -> float Source: power_balance/calc/__init__.py Calculate an efficiency from the given values and save it If the specified arguments are arrays the average of each is used.","title":"calculate"},{"location":"Reference/power_balance/calc/#parameters","text":"numerator : typing.Union numerator value denominator : typing.Union denominator value","title":"Parameters"},{"location":"Reference/power_balance/calc/#returns","text":"float efficiency value","title":"Returns"},{"location":"Reference/power_balance/calc/#construct_html_form","text":"construct_html_form ( self ) -> str Source: power_balance/calc/__init__.py","title":"construct_html_form"},{"location":"Reference/power_balance/calc/#value","text":"value ( self ) Source: power_balance/calc/__init__.py Retrieve Efficiency value","title":"value"},{"location":"Reference/power_balance/calc/efficiencies/","text":"power_balance.calc.efficiencies # Source: power_balance/calc/efficiencies.py calc_heating_to_elec_eff # calc_heating_to_elec_eff ( heating_profile : str , sim_time : numpy . ndarray , elec_in : numpy . ndarray , plasma_scenario : dict ) -> power_balance . calc . Efficiency Source: power_balance/calc/efficiencies.py Calculate the thermal to electric efficiency Uses the heating in profile and HCD electrical power array to calculate the heating to electric efficiency. Parameters # heating_profile : str path of MAT file containing profile of heating power input to the plasma elec_in : numpy.ndarray electrical power consumed Returns # power_balance.calc.Efficiency thermal to electric efficiency value calc_thermal_to_elec_eff # calc_thermal_to_elec_eff ( thermal_in_profile : str , sim_time : numpy . ndarray , total_generated : numpy . ndarray , plasma_scenario : dict ) -> power_balance . calc . Efficiency Source: power_balance/calc/efficiencies.py Calculate the thermal to electric efficiency Uses the thermal out profile and total generated power array to calculate the thermal to electric efficiency. Parameters # thermal_in_profile : str path of MAT file containing profile of thermal output energy from the tokamak total_generated : numpy.ndarray total power generated Returns # power_balance.calc.Efficiency thermal to electric efficiency value","title":"efficiencies"},{"location":"Reference/power_balance/calc/efficiencies/#power_balancecalcefficiencies","text":"Source: power_balance/calc/efficiencies.py","title":"power_balance.calc.efficiencies"},{"location":"Reference/power_balance/calc/efficiencies/#calc_heating_to_elec_eff","text":"calc_heating_to_elec_eff ( heating_profile : str , sim_time : numpy . ndarray , elec_in : numpy . ndarray , plasma_scenario : dict ) -> power_balance . calc . Efficiency Source: power_balance/calc/efficiencies.py Calculate the thermal to electric efficiency Uses the heating in profile and HCD electrical power array to calculate the heating to electric efficiency.","title":"calc_heating_to_elec_eff"},{"location":"Reference/power_balance/calc/efficiencies/#parameters","text":"heating_profile : str path of MAT file containing profile of heating power input to the plasma elec_in : numpy.ndarray electrical power consumed","title":"Parameters"},{"location":"Reference/power_balance/calc/efficiencies/#returns","text":"power_balance.calc.Efficiency thermal to electric efficiency value","title":"Returns"},{"location":"Reference/power_balance/calc/efficiencies/#calc_thermal_to_elec_eff","text":"calc_thermal_to_elec_eff ( thermal_in_profile : str , sim_time : numpy . ndarray , total_generated : numpy . ndarray , plasma_scenario : dict ) -> power_balance . calc . Efficiency Source: power_balance/calc/efficiencies.py Calculate the thermal to electric efficiency Uses the thermal out profile and total generated power array to calculate the thermal to electric efficiency.","title":"calc_thermal_to_elec_eff"},{"location":"Reference/power_balance/calc/efficiencies/#parameters_1","text":"thermal_in_profile : str path of MAT file containing profile of thermal output energy from the tokamak total_generated : numpy.ndarray total power generated","title":"Parameters"},{"location":"Reference/power_balance/calc/efficiencies/#returns_1","text":"power_balance.calc.Efficiency thermal to electric efficiency value","title":"Returns"},{"location":"Reference/power_balance/cli/","text":"power_balance.cli # Source: power_balance/cli/__init__.py Power Balance Models CLI Command line interface for running Power Balance Models, or generating and viewing profile files used as inputs.","title":"cli"},{"location":"Reference/power_balance/cli/#power_balancecli","text":"Source: power_balance/cli/__init__.py Power Balance Models CLI Command line interface for running Power Balance Models, or generating and viewing profile files used as inputs.","title":"power_balance.cli"},{"location":"Reference/power_balance/cli/session/","text":"power_balance.cli.session # Source: power_balance/cli/session.py Power Balance Models Session This script launches the full Power Balance Models system running the models specified within the given configuration file using any parameters specified in the given parameter directory, or model defaults. pbm_main # pbm_main ( config : str , verbose : bool = False , no_browser : bool = False , outputdir : str = '/home/runner/work/powerbalance/powerbalance' , param_dir : str = 'Default' , model_dir : str = 'Default' , profiles_dir : str = 'Default' , from_session : Optional [ str ] = '' , ** kwargs ) -> None Source: power_balance/cli/session.py Runs a Power Balance Models session Parameters # config : str address/path of configuration file verbose : bool , default False increase verbosity of output, by default False no_browser : bool , default False do not open browser on completion, by default False outputdir : str , default /home/runner/work/powerbalance/powerbalance output data directory, by default current directory param_dir : str , default Default location of model parameter files, defaults to internal parameters model_dir : str , default Default location of models, defaults to internal model directory profiles_dir : str , default Default location of profiles, defaults to internal profile directory from_session : typing.Optional , default ```` start a new run from the output of a previous run, by default None","title":"session"},{"location":"Reference/power_balance/cli/session/#power_balanceclisession","text":"Source: power_balance/cli/session.py Power Balance Models Session This script launches the full Power Balance Models system running the models specified within the given configuration file using any parameters specified in the given parameter directory, or model defaults.","title":"power_balance.cli.session"},{"location":"Reference/power_balance/cli/session/#pbm_main","text":"pbm_main ( config : str , verbose : bool = False , no_browser : bool = False , outputdir : str = '/home/runner/work/powerbalance/powerbalance' , param_dir : str = 'Default' , model_dir : str = 'Default' , profiles_dir : str = 'Default' , from_session : Optional [ str ] = '' , ** kwargs ) -> None Source: power_balance/cli/session.py Runs a Power Balance Models session","title":"pbm_main"},{"location":"Reference/power_balance/cli/session/#parameters","text":"config : str address/path of configuration file verbose : bool , default False increase verbosity of output, by default False no_browser : bool , default False do not open browser on completion, by default False outputdir : str , default /home/runner/work/powerbalance/powerbalance output data directory, by default current directory param_dir : str , default Default location of model parameter files, defaults to internal parameters model_dir : str , default Default location of models, defaults to internal model directory profiles_dir : str , default Default location of profiles, defaults to internal profile directory from_session : typing.Optional , default ```` start a new run from the output of a previous run, by default None","title":"Parameters"},{"location":"Reference/power_balance/configs/","text":"power_balance.configs # Source: power_balance/configs/__init__.py read_options_from_config # read_options_from_config ( config_file : str ) -> MutableMapping [ str , Any ] Source: power_balance/configs/__init__.py Read in options for this PBM instance from config file Parameters # config_file : str address of input configuration file Returns # typing.MutableMapping validated dictionary containing the configurations","title":"configs"},{"location":"Reference/power_balance/configs/#power_balanceconfigs","text":"Source: power_balance/configs/__init__.py","title":"power_balance.configs"},{"location":"Reference/power_balance/configs/#read_options_from_config","text":"read_options_from_config ( config_file : str ) -> MutableMapping [ str , Any ] Source: power_balance/configs/__init__.py Read in options for this PBM instance from config file","title":"read_options_from_config"},{"location":"Reference/power_balance/configs/#parameters","text":"config_file : str address of input configuration file","title":"Parameters"},{"location":"Reference/power_balance/configs/#returns","text":"typing.MutableMapping validated dictionary containing the configurations","title":"Returns"},{"location":"Reference/power_balance/environment/","text":"power_balance.environment #","title":"environment"},{"location":"Reference/power_balance/environment/#power_balanceenvironment","text":"","title":"power_balance.environment"},{"location":"Reference/power_balance/exceptions/","text":"power_balance.exceptions # Source: power_balance/exceptions/__init__.py Class InternalError # InternalError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for errors relating to internal setup, processes etc Class InvalidConfigurationError # InvalidConfigurationError ( msg ) -> None Source: power_balance/exceptions/__init__.py Exception for invalid PowerBalance configuration Class InvalidInputError # InvalidInputError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where specified argument is not valid Class ModelicaParameterError # ModelicaParameterError ( parameter_name : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where parameter is not found within the OpenModelica server session itself Class PluginError # PluginError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for errors relating to plugin setup/modification Class TranslationError # TranslationError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where parameter exchange between API and Modelica server session failed Class UnidentifiedParameterError # UnidentifiedParameterError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where parameter is not recognised Class ValidationError # ValidationError ( info : str , label : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where validation via a Pydantic validator fails","title":"exceptions"},{"location":"Reference/power_balance/exceptions/#power_balanceexceptions","text":"Source: power_balance/exceptions/__init__.py","title":"power_balance.exceptions"},{"location":"Reference/power_balance/exceptions/#class-internalerror","text":"InternalError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for errors relating to internal setup, processes etc","title":"Class InternalError"},{"location":"Reference/power_balance/exceptions/#class-invalidconfigurationerror","text":"InvalidConfigurationError ( msg ) -> None Source: power_balance/exceptions/__init__.py Exception for invalid PowerBalance configuration","title":"Class InvalidConfigurationError"},{"location":"Reference/power_balance/exceptions/#class-invalidinputerror","text":"InvalidInputError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where specified argument is not valid","title":"Class InvalidInputError"},{"location":"Reference/power_balance/exceptions/#class-modelicaparametererror","text":"ModelicaParameterError ( parameter_name : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where parameter is not found within the OpenModelica server session itself","title":"Class ModelicaParameterError"},{"location":"Reference/power_balance/exceptions/#class-pluginerror","text":"PluginError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for errors relating to plugin setup/modification","title":"Class PluginError"},{"location":"Reference/power_balance/exceptions/#class-translationerror","text":"TranslationError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where parameter exchange between API and Modelica server session failed","title":"Class TranslationError"},{"location":"Reference/power_balance/exceptions/#class-unidentifiedparametererror","text":"UnidentifiedParameterError ( msg : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where parameter is not recognised","title":"Class UnidentifiedParameterError"},{"location":"Reference/power_balance/exceptions/#class-validationerror","text":"ValidationError ( info : str , label : str ) -> None Source: power_balance/exceptions/__init__.py Exception for cases where validation via a Pydantic validator fails","title":"Class ValidationError"},{"location":"Reference/power_balance/modelica_templating/","text":"power_balance.modelica_templating # Source: power_balance/modelica_templating/__init__.py Power Balance Models Model Modification Modifies the modelica sources for more easy API based object creation load_model_as_template # load_model_as_template ( model_file : str ) -> jinja2 . environment . Template Source: power_balance/modelica_templating/__init__.py Loads the specified model into a Jinja template Modelica models containing Jinja statements are loaded into a Jinja template which can then be filled. Parameters # model_file : str name of the model file to load (not path) without suffix, e.g. Magnets Returns # jinja2.environment.Template a Jinja template which can be rendered with values","title":"modelica_templating"},{"location":"Reference/power_balance/modelica_templating/#power_balancemodelica_templating","text":"Source: power_balance/modelica_templating/__init__.py Power Balance Models Model Modification Modifies the modelica sources for more easy API based object creation","title":"power_balance.modelica_templating"},{"location":"Reference/power_balance/modelica_templating/#load_model_as_template","text":"load_model_as_template ( model_file : str ) -> jinja2 . environment . Template Source: power_balance/modelica_templating/__init__.py Loads the specified model into a Jinja template Modelica models containing Jinja statements are loaded into a Jinja template which can then be filled.","title":"load_model_as_template"},{"location":"Reference/power_balance/modelica_templating/#parameters","text":"model_file : str name of the model file to load (not path) without suffix, e.g. Magnets","title":"Parameters"},{"location":"Reference/power_balance/modelica_templating/#returns","text":"jinja2.environment.Template a Jinja template which can be rendered with values","title":"Returns"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/","text":"power_balance.modelica_templating.pfmagnets # Source: power_balance/modelica_templating/pfmagnets.py Power Balance Models PFMagnet Templating Creates template entries for multiple PF Magnets in Magnets model using parameter sets generate_pfmagnets # generate_pfmagnets ( parameter_set : power_balance . parameters . PBMParameterSet ) -> str Source: power_balance/modelica_templating/pfmagnets.py Generate a new script for the Magnets model using templating In cases where the number of PF magnets specified exceeds the default 6, this function generates a new Modelica script appending these additional magnets to the model. Parameters # parameter_set : power_balance.parameters.PBMParameterSet parameter set to read PF magnet specifications from Returns # str rendered magnet model Modelica script get_pfmagnet_ids_from_params # get_pfmagnet_ids_from_params ( parameter_set : power_balance . parameters . PBMParameterSet ) -> List [ int ] Source: power_balance/modelica_templating/pfmagnets.py Extracts the IDs of PF magnets within the current parameter set Parameters # parameter_set : power_balance.parameters.PBMParameterSet parameter set containing PF magnet parameters Returns # typing.List list of IDs for PF magnet parameters in the parameter set","title":"pfmagnets"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/#power_balancemodelica_templatingpfmagnets","text":"Source: power_balance/modelica_templating/pfmagnets.py Power Balance Models PFMagnet Templating Creates template entries for multiple PF Magnets in Magnets model using parameter sets","title":"power_balance.modelica_templating.pfmagnets"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/#generate_pfmagnets","text":"generate_pfmagnets ( parameter_set : power_balance . parameters . PBMParameterSet ) -> str Source: power_balance/modelica_templating/pfmagnets.py Generate a new script for the Magnets model using templating In cases where the number of PF magnets specified exceeds the default 6, this function generates a new Modelica script appending these additional magnets to the model.","title":"generate_pfmagnets"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/#parameters","text":"parameter_set : power_balance.parameters.PBMParameterSet parameter set to read PF magnet specifications from","title":"Parameters"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/#returns","text":"str rendered magnet model Modelica script","title":"Returns"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/#get_pfmagnet_ids_from_params","text":"get_pfmagnet_ids_from_params ( parameter_set : power_balance . parameters . PBMParameterSet ) -> List [ int ] Source: power_balance/modelica_templating/pfmagnets.py Extracts the IDs of PF magnets within the current parameter set","title":"get_pfmagnet_ids_from_params"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/#parameters_1","text":"parameter_set : power_balance.parameters.PBMParameterSet parameter set containing PF magnet parameters","title":"Parameters"},{"location":"Reference/power_balance/modelica_templating/pfmagnets/#returns_1","text":"typing.List list of IDs for PF magnet parameters in the parameter set","title":"Returns"},{"location":"Reference/power_balance/modelica_templating/structures/","text":"power_balance.modelica_templating.structures # Source: power_balance/modelica_templating/structures.py Power Balance Models Python Structures Python models for use when filling modelica model files containing templates. Class PFMagModel # PFMagModel ( ID , profile_id )","title":"structures"},{"location":"Reference/power_balance/modelica_templating/structures/#power_balancemodelica_templatingstructures","text":"Source: power_balance/modelica_templating/structures.py Power Balance Models Python Structures Python models for use when filling modelica model files containing templates.","title":"power_balance.modelica_templating.structures"},{"location":"Reference/power_balance/modelica_templating/structures/#class-pfmagmodel","text":"PFMagModel ( ID , profile_id )","title":"Class PFMagModel"},{"location":"Reference/power_balance/models/","text":"power_balance.models # Source: power_balance/models/__init__.py Power Balance Models model objects Creates an importable Python dictionary giving the addresses of the models contained within the power_balance/models directory. Class Model # Model ( name , location , package , submodels , binary_folder , compiled ) named tuple object containing properties for a given model Attributes # name : str model name location : str file address of model source package : str package in source containing model submodels : Dict[str, List[str]] dictionary of submodel type instances (if any) which form part of this model sorted by submodel type name binary_folder : str location of compiled binary (may be temporary) extract_models_from_file # extract_models_from_file ( input_file : str , profile_dir : str , original_model_dir : str , parameter_set : power_balance . parameters . PBMParameterSet = None , session : pydelica . Session = None , model_name_list : List [ str ] = None , names_only : bool = False , quiet : bool = False ) -> Dict [ str , power_balance . models . Model ] Source: power_balance/models/__init__.py Extracts all models from a Modelica '.mo' file Parameters # input_file : str name of OpenModelica input file with suffix '.mo' profile_dir : str location of input files original_model_dir : str directory containing models to parse parameter_set : power_balance.parameters.PBMParameterSet , default None PowerBalance Models session parameter set session : pydelica.Session , default None PyDelica session instance model_name_list : typing.List , default None specify which models of all of those within the file should be compiled and imported, by default all names_only : bool , default False do not compile the models just return a list of names, by default False quiet : bool , default False suppress printouts, by default False Returns # typing.Dict a dictionary of tuples each containing: - name - package name - submodels submodels for this model - compiled (for later storage of compiled object) get_local_models # get_local_models ( model_file_dir : str , parameter_set : power_balance . parameters . PBMParameterSet = None , session : pydelica . Session = None , profile_dir : str = '' , model_name_list : List [ str ] = None , names_only : bool = False , quiet : bool = False ) -> Dict [ str , power_balance . models . Model ] Source: power_balance/models/__init__.py Retrieve list of models from this directory to create an importable Python dictionary object. Models are stored as namedtuples Parameters # model_file_dir : str directory containing Modelica model files parameter_set : power_balance.parameters.PBMParameterSet , default None PowerBalance Models session parameter set session : pydelica.Session , default None PyDelica Modelica session profile_dir : str , default ```` profile inputs directory model_name_list : typing.List , default None specify which models of all of those within the file should be compiled and imported, by default all names_only : bool , default False do not compile the models just return a list of names, by default False quiet : bool , default False suppress printouts, by default False Returns # typing.Dict a dictionary of tuples each containing: - name - package name - submodels submodels for this model - compiled (for later storage of compiled object)","title":"models"},{"location":"Reference/power_balance/models/#power_balancemodels","text":"Source: power_balance/models/__init__.py Power Balance Models model objects Creates an importable Python dictionary giving the addresses of the models contained within the power_balance/models directory.","title":"power_balance.models"},{"location":"Reference/power_balance/models/#class-model","text":"Model ( name , location , package , submodels , binary_folder , compiled ) named tuple object containing properties for a given model","title":"Class Model"},{"location":"Reference/power_balance/models/#attributes","text":"name : str model name location : str file address of model source package : str package in source containing model submodels : Dict[str, List[str]] dictionary of submodel type instances (if any) which form part of this model sorted by submodel type name binary_folder : str location of compiled binary (may be temporary)","title":"Attributes"},{"location":"Reference/power_balance/models/#extract_models_from_file","text":"extract_models_from_file ( input_file : str , profile_dir : str , original_model_dir : str , parameter_set : power_balance . parameters . PBMParameterSet = None , session : pydelica . Session = None , model_name_list : List [ str ] = None , names_only : bool = False , quiet : bool = False ) -> Dict [ str , power_balance . models . Model ] Source: power_balance/models/__init__.py Extracts all models from a Modelica '.mo' file","title":"extract_models_from_file"},{"location":"Reference/power_balance/models/#parameters","text":"input_file : str name of OpenModelica input file with suffix '.mo' profile_dir : str location of input files original_model_dir : str directory containing models to parse parameter_set : power_balance.parameters.PBMParameterSet , default None PowerBalance Models session parameter set session : pydelica.Session , default None PyDelica session instance model_name_list : typing.List , default None specify which models of all of those within the file should be compiled and imported, by default all names_only : bool , default False do not compile the models just return a list of names, by default False quiet : bool , default False suppress printouts, by default False","title":"Parameters"},{"location":"Reference/power_balance/models/#returns","text":"typing.Dict a dictionary of tuples each containing: - name - package name - submodels submodels for this model - compiled (for later storage of compiled object)","title":"Returns"},{"location":"Reference/power_balance/models/#get_local_models","text":"get_local_models ( model_file_dir : str , parameter_set : power_balance . parameters . PBMParameterSet = None , session : pydelica . Session = None , profile_dir : str = '' , model_name_list : List [ str ] = None , names_only : bool = False , quiet : bool = False ) -> Dict [ str , power_balance . models . Model ] Source: power_balance/models/__init__.py Retrieve list of models from this directory to create an importable Python dictionary object. Models are stored as namedtuples","title":"get_local_models"},{"location":"Reference/power_balance/models/#parameters_1","text":"model_file_dir : str directory containing Modelica model files parameter_set : power_balance.parameters.PBMParameterSet , default None PowerBalance Models session parameter set session : pydelica.Session , default None PyDelica Modelica session profile_dir : str , default ```` profile inputs directory model_name_list : typing.List , default None specify which models of all of those within the file should be compiled and imported, by default all names_only : bool , default False do not compile the models just return a list of names, by default False quiet : bool , default False suppress printouts, by default False","title":"Parameters"},{"location":"Reference/power_balance/models/#returns_1","text":"typing.Dict a dictionary of tuples each containing: - name - package name - submodels submodels for this model - compiled (for later storage of compiled object)","title":"Returns"},{"location":"Reference/power_balance/models/Resources/","text":"power_balance.models.Resources #","title":"Resources"},{"location":"Reference/power_balance/models/Resources/#power_balancemodelsresources","text":"","title":"power_balance.models.Resources"},{"location":"Reference/power_balance/models/Resources/Include/","text":"power_balance.models.Resources.Include #","title":"Include"},{"location":"Reference/power_balance/models/Resources/Include/#power_balancemodelsresourcesinclude","text":"","title":"power_balance.models.Resources.Include"},{"location":"Reference/power_balance/parameters/","text":"power_balance.parameters # Source: power_balance/parameters/__init__.py Class PBMParameterSet # PBMParameterSet ( parameters_directory : str , simulation_options_file : str , plasma_scenario_file : str , structural_params_file : str = '' , modelica_file_directory : str = '' , ** kwargs ) -> None Source: power_balance/parameters/__init__.py Class for storing all parameter values read from TOML files within a directory, these then being the inputs to the Power Balance models within Modelica. The parameters are stored as a 'flattened' dictionary, for example: model1.toml -- toml --> dict_1[{'X': 'Y', 'Z': {'W': 'V'}}] model2.toml -- toml --> dict_2[{'A': {'B': 'C'}}] would become: {'model1.X': 'Y', 'model1.Z.W': 'V', 'model2.A.B': 'C'} when saving the parameters, the dictionary is re-expanded and each TOML file written. Parameter sets are initialised using TOML files from a given directory and defining one file as the Modelica internal parameters (i.e. containing variables such as 'stepSize' etc. which are embedded into all Modelica model runs) Methods # add_non_modelica_parameter # add_non_modelica_parameter ( self , parameter_name : str , value : Any ) -> None Source: power_balance/parameters/__init__.py Add a parameter which is used for templating but not in Modelica sources Parameters # parameter_name : str name of parameter to add value : typing.Any value to assign to the parameter append # append ( self , parameter_name : str , value : Any ) Source: power_balance/parameters/__init__.py Add a parameter to the parameter set. This will occur AFTER the models have been initialised and exists simply to dump the value in the parameter list at the end of the run. i.e. this is for values that the user did not specify in their chosen parameter input file. Parameters # parameter_name : str name of parameter to add value : typing.Any value assigned to that parameter get_file_location # get_file_location ( self , file_label : str ) -> Optional [ str ] Source: power_balance/parameters/__init__.py Return input file path Parameters # file_label : str label of input file Returns # typing.Optional input file path for given label get_parameter # get_parameter ( self , param_name : str ) -> Any Source: power_balance/parameters/__init__.py Retrieve a parameter by name from the whole parameter set. Parameters # param_name : str name of parameter from which to retrieve value Returns # typing.Any current value of the specified parameter get_plasma_scenario # get_plasma_scenario ( self , param_names : Union [ str , List [ str ]] = None ) -> Any Source: power_balance/parameters/__init__.py Retrieve timings from the plasma scenario set Parameters # param_names : typing.Union , default None names of plasma scenario timings to retrieve, by default all Returns # typing.Any either a single option value or all options get_simulation_options # get_simulation_options ( self , param_names : Union [ str , List [ str ]] = None ) -> Any Source: power_balance/parameters/__init__.py Retrieve simulation options from the parameter set Parameters # param_names : typing.Union , default None names of simulation options to retrieve, by default all Returns # typing.Any either a single option value or all options is_valid_non_modelica_param # is_valid_non_modelica_param ( self , parameter_name : str ) -> bool Source: power_balance/parameters/__init__.py Returns if the specified name is a recognised non-modelica parameter Non-Modelica parameters are used during the templating of modelica code they allow the user to specify additional options relating model construction, for example in the case of PF magnets specification of what combitimetable to use. This property is used for templating, but not in Modelica itself. Parameters # parameter_name : str name of parameter to check Returns # bool whether the parameter is a recognised non-modelica parameter items # items ( self ) Source: power_balance/parameters/__init__.py D.items() -> a set-like object providing a view on D's items keys # keys ( self ) Source: power_balance/parameters/__init__.py D.keys() -> a set-like object providing a view on D's keys load_from_directory # load_from_directory ( self , parameter_directory : str ) -> None Source: power_balance/parameters/__init__.py Load parameters from an alternative directory Parameters # parameter_directory : str parameter directory path load_modelica_parameters # load_modelica_parameters ( self ) -> Dict [ str , Any ] Source: power_balance/parameters/__init__.py Load all parameter sets from TOML files in the specified directory Returns # typing.Dict dictionary containing all parameters read from the input files load_plasma_scenario # load_plasma_scenario ( self ) -> MutableMapping [ str , Any ] Source: power_balance/parameters/__init__.py Read plasma scenario from the specified file. The values must be in ascending order. Returns # typing.MutableMapping load_simulation_options # load_simulation_options ( self ) -> MutableMapping [ str , Any ] Source: power_balance/parameters/__init__.py Read simulation options from the specified file. These options are special Modelica variables which must be of a given name so this method also corrects closely matching names if required Returns # typing.MutableMapping load_structural_parameters # load_structural_parameters ( self ) -> MutableMapping Source: power_balance/parameters/__init__.py Load the structural parameters if file given Returns # typing.MutableMapping typing.Dictionary containing structural parameter substitutions save_to_directory # save_to_directory ( self , output_directory : str ) -> None Source: power_balance/parameters/__init__.py Save parameters to a given directory ensuring they are in a form in which they can later be reimported if needed to ensure consistency between runs and storage of conditions. Parameters # output_directory : str location to store the generated TOML files search # search ( self , search_str : str ) -> List [ str ] Source: power_balance/parameters/__init__.py Search for parameters matching a given search string Parameters # search_str : str search term to use for finding parameters Returns # typing.List list of parameters matching search by name set_parameter # set_parameter ( self , param_name : str , value : Any ) -> Any Source: power_balance/parameters/__init__.py Set a parameter by name to a given value. Parameters # param_name : str parameter to apply new value to value : typing.Any value to assign Returns # typing.Any value retrieved from parameter after the assign set_struct_parameters # set_struct_parameters ( self , model_file : str , dependency_files : Optional [ List [ str ]] = None ) -> str Source: power_balance/parameters/__init__.py Set values of structural parameters in Modelica models. This edits the hardcoded values in a modelica model allowing certain hardcoded parameters to be changed. A dictionary containing the original Modelica models' code is returned at the end. This enables the Models to be restored to their original state after the build stage. Parameters # model_file : str Modelica model file dependency_files : typing.Optional , default None Additional Modelica files containing dependencies Returns # str filepath to temporary file containing modified model update_from_model # update_from_model ( self , model_name : str , pyd_session : pydelica . Session ) -> None Source: power_balance/parameters/__init__.py Update the parameters using information obtained from the pydelica parameters. Parameters # model_name : str model name as string pyd_session : pydelica.Session pydelica session values # values ( self ) Source: power_balance/parameters/__init__.py D.values() -> an object providing a view on D's values remove_do_not_edit_header # remove_do_not_edit_header ( parameter_file : str , output_file : str ) -> None Source: power_balance/parameters/__init__.py Removes the DO NOT EDIT header when copying a parameter file","title":"parameters"},{"location":"Reference/power_balance/parameters/#power_balanceparameters","text":"Source: power_balance/parameters/__init__.py","title":"power_balance.parameters"},{"location":"Reference/power_balance/parameters/#class-pbmparameterset","text":"PBMParameterSet ( parameters_directory : str , simulation_options_file : str , plasma_scenario_file : str , structural_params_file : str = '' , modelica_file_directory : str = '' , ** kwargs ) -> None Source: power_balance/parameters/__init__.py Class for storing all parameter values read from TOML files within a directory, these then being the inputs to the Power Balance models within Modelica. The parameters are stored as a 'flattened' dictionary, for example: model1.toml -- toml --> dict_1[{'X': 'Y', 'Z': {'W': 'V'}}] model2.toml -- toml --> dict_2[{'A': {'B': 'C'}}] would become: {'model1.X': 'Y', 'model1.Z.W': 'V', 'model2.A.B': 'C'} when saving the parameters, the dictionary is re-expanded and each TOML file written. Parameter sets are initialised using TOML files from a given directory and defining one file as the Modelica internal parameters (i.e. containing variables such as 'stepSize' etc. which are embedded into all Modelica model runs)","title":"Class PBMParameterSet"},{"location":"Reference/power_balance/parameters/#methods","text":"","title":"Methods"},{"location":"Reference/power_balance/parameters/#add_non_modelica_parameter","text":"add_non_modelica_parameter ( self , parameter_name : str , value : Any ) -> None Source: power_balance/parameters/__init__.py Add a parameter which is used for templating but not in Modelica sources","title":"add_non_modelica_parameter"},{"location":"Reference/power_balance/parameters/#parameters","text":"parameter_name : str name of parameter to add value : typing.Any value to assign to the parameter","title":"Parameters"},{"location":"Reference/power_balance/parameters/#append","text":"append ( self , parameter_name : str , value : Any ) Source: power_balance/parameters/__init__.py Add a parameter to the parameter set. This will occur AFTER the models have been initialised and exists simply to dump the value in the parameter list at the end of the run. i.e. this is for values that the user did not specify in their chosen parameter input file.","title":"append"},{"location":"Reference/power_balance/parameters/#parameters_1","text":"parameter_name : str name of parameter to add value : typing.Any value assigned to that parameter","title":"Parameters"},{"location":"Reference/power_balance/parameters/#get_file_location","text":"get_file_location ( self , file_label : str ) -> Optional [ str ] Source: power_balance/parameters/__init__.py Return input file path","title":"get_file_location"},{"location":"Reference/power_balance/parameters/#parameters_2","text":"file_label : str label of input file","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns","text":"typing.Optional input file path for given label","title":"Returns"},{"location":"Reference/power_balance/parameters/#get_parameter","text":"get_parameter ( self , param_name : str ) -> Any Source: power_balance/parameters/__init__.py Retrieve a parameter by name from the whole parameter set.","title":"get_parameter"},{"location":"Reference/power_balance/parameters/#parameters_3","text":"param_name : str name of parameter from which to retrieve value","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns_1","text":"typing.Any current value of the specified parameter","title":"Returns"},{"location":"Reference/power_balance/parameters/#get_plasma_scenario","text":"get_plasma_scenario ( self , param_names : Union [ str , List [ str ]] = None ) -> Any Source: power_balance/parameters/__init__.py Retrieve timings from the plasma scenario set","title":"get_plasma_scenario"},{"location":"Reference/power_balance/parameters/#parameters_4","text":"param_names : typing.Union , default None names of plasma scenario timings to retrieve, by default all","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns_2","text":"typing.Any either a single option value or all options","title":"Returns"},{"location":"Reference/power_balance/parameters/#get_simulation_options","text":"get_simulation_options ( self , param_names : Union [ str , List [ str ]] = None ) -> Any Source: power_balance/parameters/__init__.py Retrieve simulation options from the parameter set","title":"get_simulation_options"},{"location":"Reference/power_balance/parameters/#parameters_5","text":"param_names : typing.Union , default None names of simulation options to retrieve, by default all","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns_3","text":"typing.Any either a single option value or all options","title":"Returns"},{"location":"Reference/power_balance/parameters/#is_valid_non_modelica_param","text":"is_valid_non_modelica_param ( self , parameter_name : str ) -> bool Source: power_balance/parameters/__init__.py Returns if the specified name is a recognised non-modelica parameter Non-Modelica parameters are used during the templating of modelica code they allow the user to specify additional options relating model construction, for example in the case of PF magnets specification of what combitimetable to use. This property is used for templating, but not in Modelica itself.","title":"is_valid_non_modelica_param"},{"location":"Reference/power_balance/parameters/#parameters_6","text":"parameter_name : str name of parameter to check","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns_4","text":"bool whether the parameter is a recognised non-modelica parameter","title":"Returns"},{"location":"Reference/power_balance/parameters/#items","text":"items ( self ) Source: power_balance/parameters/__init__.py D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"Reference/power_balance/parameters/#keys","text":"keys ( self ) Source: power_balance/parameters/__init__.py D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"Reference/power_balance/parameters/#load_from_directory","text":"load_from_directory ( self , parameter_directory : str ) -> None Source: power_balance/parameters/__init__.py Load parameters from an alternative directory","title":"load_from_directory"},{"location":"Reference/power_balance/parameters/#parameters_7","text":"parameter_directory : str parameter directory path","title":"Parameters"},{"location":"Reference/power_balance/parameters/#load_modelica_parameters","text":"load_modelica_parameters ( self ) -> Dict [ str , Any ] Source: power_balance/parameters/__init__.py Load all parameter sets from TOML files in the specified directory","title":"load_modelica_parameters"},{"location":"Reference/power_balance/parameters/#returns_5","text":"typing.Dict dictionary containing all parameters read from the input files","title":"Returns"},{"location":"Reference/power_balance/parameters/#load_plasma_scenario","text":"load_plasma_scenario ( self ) -> MutableMapping [ str , Any ] Source: power_balance/parameters/__init__.py Read plasma scenario from the specified file. The values must be in ascending order.","title":"load_plasma_scenario"},{"location":"Reference/power_balance/parameters/#returns_6","text":"typing.MutableMapping","title":"Returns"},{"location":"Reference/power_balance/parameters/#load_simulation_options","text":"load_simulation_options ( self ) -> MutableMapping [ str , Any ] Source: power_balance/parameters/__init__.py Read simulation options from the specified file. These options are special Modelica variables which must be of a given name so this method also corrects closely matching names if required","title":"load_simulation_options"},{"location":"Reference/power_balance/parameters/#returns_7","text":"typing.MutableMapping","title":"Returns"},{"location":"Reference/power_balance/parameters/#load_structural_parameters","text":"load_structural_parameters ( self ) -> MutableMapping Source: power_balance/parameters/__init__.py Load the structural parameters if file given","title":"load_structural_parameters"},{"location":"Reference/power_balance/parameters/#returns_8","text":"typing.MutableMapping typing.Dictionary containing structural parameter substitutions","title":"Returns"},{"location":"Reference/power_balance/parameters/#save_to_directory","text":"save_to_directory ( self , output_directory : str ) -> None Source: power_balance/parameters/__init__.py Save parameters to a given directory ensuring they are in a form in which they can later be reimported if needed to ensure consistency between runs and storage of conditions.","title":"save_to_directory"},{"location":"Reference/power_balance/parameters/#parameters_8","text":"output_directory : str location to store the generated TOML files","title":"Parameters"},{"location":"Reference/power_balance/parameters/#search","text":"search ( self , search_str : str ) -> List [ str ] Source: power_balance/parameters/__init__.py Search for parameters matching a given search string","title":"search"},{"location":"Reference/power_balance/parameters/#parameters_9","text":"search_str : str search term to use for finding parameters","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns_9","text":"typing.List list of parameters matching search by name","title":"Returns"},{"location":"Reference/power_balance/parameters/#set_parameter","text":"set_parameter ( self , param_name : str , value : Any ) -> Any Source: power_balance/parameters/__init__.py Set a parameter by name to a given value.","title":"set_parameter"},{"location":"Reference/power_balance/parameters/#parameters_10","text":"param_name : str parameter to apply new value to value : typing.Any value to assign","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns_10","text":"typing.Any value retrieved from parameter after the assign","title":"Returns"},{"location":"Reference/power_balance/parameters/#set_struct_parameters","text":"set_struct_parameters ( self , model_file : str , dependency_files : Optional [ List [ str ]] = None ) -> str Source: power_balance/parameters/__init__.py Set values of structural parameters in Modelica models. This edits the hardcoded values in a modelica model allowing certain hardcoded parameters to be changed. A dictionary containing the original Modelica models' code is returned at the end. This enables the Models to be restored to their original state after the build stage.","title":"set_struct_parameters"},{"location":"Reference/power_balance/parameters/#parameters_11","text":"model_file : str Modelica model file dependency_files : typing.Optional , default None Additional Modelica files containing dependencies","title":"Parameters"},{"location":"Reference/power_balance/parameters/#returns_11","text":"str filepath to temporary file containing modified model","title":"Returns"},{"location":"Reference/power_balance/parameters/#update_from_model","text":"update_from_model ( self , model_name : str , pyd_session : pydelica . Session ) -> None Source: power_balance/parameters/__init__.py Update the parameters using information obtained from the pydelica parameters.","title":"update_from_model"},{"location":"Reference/power_balance/parameters/#parameters_12","text":"model_name : str model name as string pyd_session : pydelica.Session pydelica session","title":"Parameters"},{"location":"Reference/power_balance/parameters/#values","text":"values ( self ) Source: power_balance/parameters/__init__.py D.values() -> an object providing a view on D's values","title":"values"},{"location":"Reference/power_balance/parameters/#remove_do_not_edit_header","text":"remove_do_not_edit_header ( parameter_file : str , output_file : str ) -> None Source: power_balance/parameters/__init__.py Removes the DO NOT EDIT header when copying a parameter file","title":"remove_do_not_edit_header"},{"location":"Reference/power_balance/plotting/","text":"power_balance.plotting # Source: power_balance/plotting/__init__.py launch_viewer # launch_viewer ( results_directory : str ) Source: power_balance/plotting/__init__.py Launch the browser window with the plot webpage Parameters # results_directory : str directory containing output files","title":"plotting"},{"location":"Reference/power_balance/plotting/#power_balanceplotting","text":"Source: power_balance/plotting/__init__.py","title":"power_balance.plotting"},{"location":"Reference/power_balance/plotting/#launch_viewer","text":"launch_viewer ( results_directory : str ) Source: power_balance/plotting/__init__.py Launch the browser window with the plot webpage","title":"launch_viewer"},{"location":"Reference/power_balance/plotting/#parameters","text":"results_directory : str directory containing output files","title":"Parameters"},{"location":"Reference/power_balance/plotting/common/","text":"power_balance.plotting.common # Source: power_balance/plotting/common.py add_plot_objects # add_plot_objects ( figure : < function figure at 0x7f31187479a0 > , x_array : numpy . ndarray , y_array : numpy . ndarray , x_label : str , y_label : str , point_threshold : int = 100 ) -> None Source: power_balance/plotting/common.py Create a Bokeh plot source Parameters # x_array : numpy.ndarray independent variable array y_array : numpy.ndarray dependent variable array x_label : str label for independent data array y_label : str label for dependent data array point_threshold : int , default 100 threshold on number of data points to display, default is 100 make_hover_tool # make_hover_tool ( x_label : str , y_label : str , dec_places : int = 4 ) -> bokeh . models . tools . HoverTool Source: power_balance/plotting/common.py Create a HoverTool instance for a variable plot. This allows the interface user to hover over data points and see info. Parameters # x_label : str name of independent variable y_label : str name of dependent variable dec_places : int , default 4 number of decimal places before the exponent, default is 4 Returns # bokeh.models.tools.HoverTool instance of hover tool to be added to Bokeh plot plot_to_image # plot_to_image ( x_array : Iterable , y_array : Iterable , x_label : str , y_label : str , file_name : str , dpi : int = 900 , filetype : str = 'jpeg' ) -> None Source: power_balance/plotting/common.py Plots graph of power against time and saves to the given file address. Parameters # x_array : typing.Iterable x axis array y_array : typing.Iterable y array x_label : str independent variable label y_label : str dependent variable label file_name : str output file name (should match filetype ) dpi : int , default 900 image resolution, by default 900 filetype : str , default jpeg file format, by default \"jpeg\"","title":"common"},{"location":"Reference/power_balance/plotting/common/#power_balanceplottingcommon","text":"Source: power_balance/plotting/common.py","title":"power_balance.plotting.common"},{"location":"Reference/power_balance/plotting/common/#add_plot_objects","text":"add_plot_objects ( figure : < function figure at 0x7f31187479a0 > , x_array : numpy . ndarray , y_array : numpy . ndarray , x_label : str , y_label : str , point_threshold : int = 100 ) -> None Source: power_balance/plotting/common.py Create a Bokeh plot source","title":"add_plot_objects"},{"location":"Reference/power_balance/plotting/common/#parameters","text":"x_array : numpy.ndarray independent variable array y_array : numpy.ndarray dependent variable array x_label : str label for independent data array y_label : str label for dependent data array point_threshold : int , default 100 threshold on number of data points to display, default is 100","title":"Parameters"},{"location":"Reference/power_balance/plotting/common/#make_hover_tool","text":"make_hover_tool ( x_label : str , y_label : str , dec_places : int = 4 ) -> bokeh . models . tools . HoverTool Source: power_balance/plotting/common.py Create a HoverTool instance for a variable plot. This allows the interface user to hover over data points and see info.","title":"make_hover_tool"},{"location":"Reference/power_balance/plotting/common/#parameters_1","text":"x_label : str name of independent variable y_label : str name of dependent variable dec_places : int , default 4 number of decimal places before the exponent, default is 4","title":"Parameters"},{"location":"Reference/power_balance/plotting/common/#returns","text":"bokeh.models.tools.HoverTool instance of hover tool to be added to Bokeh plot","title":"Returns"},{"location":"Reference/power_balance/plotting/common/#plot_to_image","text":"plot_to_image ( x_array : Iterable , y_array : Iterable , x_label : str , y_label : str , file_name : str , dpi : int = 900 , filetype : str = 'jpeg' ) -> None Source: power_balance/plotting/common.py Plots graph of power against time and saves to the given file address.","title":"plot_to_image"},{"location":"Reference/power_balance/plotting/common/#parameters_2","text":"x_array : typing.Iterable x axis array y_array : typing.Iterable y array x_label : str independent variable label y_label : str dependent variable label file_name : str output file name (should match filetype ) dpi : int , default 900 image resolution, by default 900 filetype : str , default jpeg file format, by default \"jpeg\"","title":"Parameters"},{"location":"Reference/power_balance/plotting/profile_plotting/","text":"power_balance.plotting.profile_plotting # Source: power_balance/plotting/profile_plotting.py Class ProfilePlotBuilder # ProfilePlotBuilder ( profiles_dir : str ) Source: power_balance/plotting/profile_plotting.py Builds page content for displaying the plots of input profiles Methods # get_plots # get_plots ( self ) -> str Source: power_balance/plotting/profile_plotting.py Retrieve plot string objects Returns # str plot object strings get_scripts # get_scripts ( self ) -> Any Source: power_balance/plotting/profile_plotting.py Retrieve plot script objects Returns # typing.Any plot script objects get_profiles_data # get_profiles_data ( profile_dir : str ) -> Dict [ str , numpy . ndarray ] Source: power_balance/plotting/profile_plotting.py Retrieve profiles for plotting Returns # typing.Dict dictionary of profile data","title":"profile_plotting"},{"location":"Reference/power_balance/plotting/profile_plotting/#power_balanceplottingprofile_plotting","text":"Source: power_balance/plotting/profile_plotting.py","title":"power_balance.plotting.profile_plotting"},{"location":"Reference/power_balance/plotting/profile_plotting/#class-profileplotbuilder","text":"ProfilePlotBuilder ( profiles_dir : str ) Source: power_balance/plotting/profile_plotting.py Builds page content for displaying the plots of input profiles","title":"Class ProfilePlotBuilder"},{"location":"Reference/power_balance/plotting/profile_plotting/#methods","text":"","title":"Methods"},{"location":"Reference/power_balance/plotting/profile_plotting/#get_plots","text":"get_plots ( self ) -> str Source: power_balance/plotting/profile_plotting.py Retrieve plot string objects","title":"get_plots"},{"location":"Reference/power_balance/plotting/profile_plotting/#returns","text":"str plot object strings","title":"Returns"},{"location":"Reference/power_balance/plotting/profile_plotting/#get_scripts","text":"get_scripts ( self ) -> Any Source: power_balance/plotting/profile_plotting.py Retrieve plot script objects","title":"get_scripts"},{"location":"Reference/power_balance/plotting/profile_plotting/#returns_1","text":"typing.Any plot script objects","title":"Returns"},{"location":"Reference/power_balance/plotting/profile_plotting/#get_profiles_data","text":"get_profiles_data ( profile_dir : str ) -> Dict [ str , numpy . ndarray ] Source: power_balance/plotting/profile_plotting.py Retrieve profiles for plotting","title":"get_profiles_data"},{"location":"Reference/power_balance/plotting/profile_plotting/#returns_2","text":"typing.Dict dictionary of profile data","title":"Returns"},{"location":"Reference/power_balance/plotting/result_plotting/","text":"power_balance.plotting.result_plotting # Source: power_balance/plotting/result_plotting.py Class OutputPlotBuilder # OutputPlotBuilder ( configuration : MutableMapping [ str , Any ], output_data : Dict , npoint_threshold : int = 100 ) -> None Source: power_balance/plotting/result_plotting.py Constructs plots from a set of model run outputs Methods # get_cuts # get_cuts ( self ) -> Dict [ str , Any ] Source: power_balance/plotting/result_plotting.py Retrieve dictionary of sweep cuts Returns # typing.Dict get_plots # get_plots ( self ) -> Dict [ str , Any ] Source: power_balance/plotting/result_plotting.py Retrieve plot dictionary Returns # typing.Dict get_scripts # get_scripts ( self ) -> List [ str ] Source: power_balance/plotting/result_plotting.py Retrieve Bokeh plot scripts Returns # typing.List has_sweep # has_sweep ( self ) -> bool Source: power_balance/plotting/result_plotting.py Output has parameter sweep Returns # bool","title":"result_plotting"},{"location":"Reference/power_balance/plotting/result_plotting/#power_balanceplottingresult_plotting","text":"Source: power_balance/plotting/result_plotting.py","title":"power_balance.plotting.result_plotting"},{"location":"Reference/power_balance/plotting/result_plotting/#class-outputplotbuilder","text":"OutputPlotBuilder ( configuration : MutableMapping [ str , Any ], output_data : Dict , npoint_threshold : int = 100 ) -> None Source: power_balance/plotting/result_plotting.py Constructs plots from a set of model run outputs","title":"Class OutputPlotBuilder"},{"location":"Reference/power_balance/plotting/result_plotting/#methods","text":"","title":"Methods"},{"location":"Reference/power_balance/plotting/result_plotting/#get_cuts","text":"get_cuts ( self ) -> Dict [ str , Any ] Source: power_balance/plotting/result_plotting.py Retrieve dictionary of sweep cuts","title":"get_cuts"},{"location":"Reference/power_balance/plotting/result_plotting/#returns","text":"typing.Dict","title":"Returns"},{"location":"Reference/power_balance/plotting/result_plotting/#get_plots","text":"get_plots ( self ) -> Dict [ str , Any ] Source: power_balance/plotting/result_plotting.py Retrieve plot dictionary","title":"get_plots"},{"location":"Reference/power_balance/plotting/result_plotting/#returns_1","text":"typing.Dict","title":"Returns"},{"location":"Reference/power_balance/plotting/result_plotting/#get_scripts","text":"get_scripts ( self ) -> List [ str ] Source: power_balance/plotting/result_plotting.py Retrieve Bokeh plot scripts","title":"get_scripts"},{"location":"Reference/power_balance/plotting/result_plotting/#returns_2","text":"typing.List","title":"Returns"},{"location":"Reference/power_balance/plotting/result_plotting/#has_sweep","text":"has_sweep ( self ) -> bool Source: power_balance/plotting/result_plotting.py Output has parameter sweep","title":"has_sweep"},{"location":"Reference/power_balance/plotting/result_plotting/#returns_3","text":"bool","title":"Returns"},{"location":"Reference/power_balance/plugins/","text":"power_balance.plugins # Source: power_balance/plugins/__init__.py Power Balance Models Plugins Adds support for external plugins, these plugins can provide extra options to the main CLI, as well as setup arguments before they are then read by the main core functionality. add_plugin_commands # add_plugin_commands ( parent_command : click . core . Group ) -> None Source: power_balance/plugins/__init__.py Append CLI commands from plugin to main PBM CLI Power Balance Models assumes a plugin is defined by the presence of a plugin metadata file 'plugin.toml' Parameters # parent_command : click.core.Group the main command group to append additional subcommands to apply_modifications_to # apply_modifications_to ( name : str , function : click . core . Command ) -> None Source: power_balance/plugins/__init__.py Applies modifications to the given CLI function extract_commands # extract_commands ( plugin_metadata : Dict ) -> List [ click . core . Command ] Source: power_balance/plugins/__init__.py Extracts all commands from a given plugin metadata file Parameters # plugin_metadata : typing.Dict plugin metadata Returns # typing.List list of command objects initialised from the definitions get_plugin_display_filename # get_plugin_display_filename ( plugin_name : str ) -> str Source: power_balance/plugins/__init__.py Returns the expected display template file for a given plugin Returns # str get_plugin_listing # get_plugin_listing () -> Dict Source: power_balance/plugins/__init__.py Get list of available plugins Returns # typing.Dict install_plugin # install_plugin ( plugin_directory : str ) -> None Source: power_balance/plugins/__init__.py Install a plugin from a plugin directory Parameters # plugin_directory : str directory containing required PLUGIN_FILE file prepare_from_plugins # prepare_from_plugins ( pbmmain_call_args : Dict ) -> List [ str ] Source: power_balance/plugins/__init__.py Prepare the main method of PBM updating from any plugin modifications Returns # typing.List remove_plugin # remove_plugin ( plugin_name : str ) -> None Source: power_balance/plugins/__init__.py Uninstall a plugin from the plugins directory Parameters # plugin_name : str name of plugin to remove","title":"plugins"},{"location":"Reference/power_balance/plugins/#power_balanceplugins","text":"Source: power_balance/plugins/__init__.py Power Balance Models Plugins Adds support for external plugins, these plugins can provide extra options to the main CLI, as well as setup arguments before they are then read by the main core functionality.","title":"power_balance.plugins"},{"location":"Reference/power_balance/plugins/#add_plugin_commands","text":"add_plugin_commands ( parent_command : click . core . Group ) -> None Source: power_balance/plugins/__init__.py Append CLI commands from plugin to main PBM CLI Power Balance Models assumes a plugin is defined by the presence of a plugin metadata file 'plugin.toml'","title":"add_plugin_commands"},{"location":"Reference/power_balance/plugins/#parameters","text":"parent_command : click.core.Group the main command group to append additional subcommands to","title":"Parameters"},{"location":"Reference/power_balance/plugins/#apply_modifications_to","text":"apply_modifications_to ( name : str , function : click . core . Command ) -> None Source: power_balance/plugins/__init__.py Applies modifications to the given CLI function","title":"apply_modifications_to"},{"location":"Reference/power_balance/plugins/#extract_commands","text":"extract_commands ( plugin_metadata : Dict ) -> List [ click . core . Command ] Source: power_balance/plugins/__init__.py Extracts all commands from a given plugin metadata file","title":"extract_commands"},{"location":"Reference/power_balance/plugins/#parameters_1","text":"plugin_metadata : typing.Dict plugin metadata","title":"Parameters"},{"location":"Reference/power_balance/plugins/#returns","text":"typing.List list of command objects initialised from the definitions","title":"Returns"},{"location":"Reference/power_balance/plugins/#get_plugin_display_filename","text":"get_plugin_display_filename ( plugin_name : str ) -> str Source: power_balance/plugins/__init__.py Returns the expected display template file for a given plugin","title":"get_plugin_display_filename"},{"location":"Reference/power_balance/plugins/#returns_1","text":"str","title":"Returns"},{"location":"Reference/power_balance/plugins/#get_plugin_listing","text":"get_plugin_listing () -> Dict Source: power_balance/plugins/__init__.py Get list of available plugins","title":"get_plugin_listing"},{"location":"Reference/power_balance/plugins/#returns_2","text":"typing.Dict","title":"Returns"},{"location":"Reference/power_balance/plugins/#install_plugin","text":"install_plugin ( plugin_directory : str ) -> None Source: power_balance/plugins/__init__.py Install a plugin from a plugin directory","title":"install_plugin"},{"location":"Reference/power_balance/plugins/#parameters_2","text":"plugin_directory : str directory containing required PLUGIN_FILE file","title":"Parameters"},{"location":"Reference/power_balance/plugins/#prepare_from_plugins","text":"prepare_from_plugins ( pbmmain_call_args : Dict ) -> List [ str ] Source: power_balance/plugins/__init__.py Prepare the main method of PBM updating from any plugin modifications","title":"prepare_from_plugins"},{"location":"Reference/power_balance/plugins/#returns_3","text":"typing.List","title":"Returns"},{"location":"Reference/power_balance/plugins/#remove_plugin","text":"remove_plugin ( plugin_name : str ) -> None Source: power_balance/plugins/__init__.py Uninstall a plugin from the plugins directory","title":"remove_plugin"},{"location":"Reference/power_balance/plugins/#parameters_3","text":"plugin_name : str name of plugin to remove","title":"Parameters"},{"location":"Reference/power_balance/profiles/","text":"power_balance.profiles # Source: power_balance/profiles/__init__.py gen_cscoil_current_profile # gen_cscoil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns a Central Solenoid coil current value for each step in the given time array the result is saved by default for usage in the modelica models. Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 50 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and cscoil current values gen_nbiheat_profile # gen_nbiheat_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_power : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Creates an array of neutral beam injection heat values for the given time array Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_power : float , default None maximum power in Watts, default is 60 MW label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory. Returns # numpy.ndarray transposed numpy array of time and plasma heat values gen_pf1coil_current_profile # gen_pf1coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the first Poloidal Field for each step in the given time array the result is saved by default for usage in the modelica models. Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 10 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and pf1coil current values gen_pf2coil_current_profile # gen_pf2coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the second Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models. Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 5 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and pf2coil current values gen_pf3coil_current_profile # gen_pf3coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the third Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models. Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 2 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and pf3coil current values gen_pf4coil_current_profile # gen_pf4coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the fourth Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models. Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 5 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and pf4coil current values gen_pf5coil_current_profile # gen_pf5coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the fifth Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models. Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 3 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and pf5coil current values gen_pf6coil_current_profile # gen_pf6coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the sixth Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models. Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 5 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and pf6coil current values gen_rfheat_profile # gen_rfheat_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_power : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Creates an array of radio frequency heat values for the given time array Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_power : float , default None maximum power in Watts, default is 60 MW label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory. Returns # numpy.ndarray transposed numpy array of time and plasma heat values gen_tfcoil_current_profile # gen_tfcoil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns a Toroidal Field coil current value to each time step within the given time array Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 60 kA label : str , default ```` extra indentifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory Returns # numpy.ndarray transposed numpy array of time and tfcoil current values gen_thermalpowerout_profile # gen_thermalpowerout_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_power : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Creates an array of thermal power output values for the given time array Parameters # stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_power : float , default None maximum power in Watts, default is 1000 MW label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory. Returns # numpy.ndarray transposed numpy array of time and plasma heat values generate_all # generate_all ( output_directory : str , time_range : Tuple [ float , ... ] = None , stop_time : int = None , time_step : int = None , max_values : Optional [ Dict ] = None ) -> None Source: power_balance/profiles/__init__.py Generate all the current profiles in the given directory using _time_array_default and _time_range_default, and also using the max currents and powers specified in the input to the Power Balance Parameters # output_directory : str location to save the profile '.mat' files time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : int , default None the difference in seconds between each individual step, typically matching the time step of the simulation max_values : typing.Optional , default None a dictionary containing information about the maximum currents and powers for each profile in the format {'system name': value} read_profile_to_df # read_profile_to_df ( filename : str ) -> pandas . core . frame . DataFrame Source: power_balance/profiles/__init__.py Open a '.mat' profile file and write contents to a Pandas dataframe for easy access Parameters # filename : str address of the '.mat' file Returns # pandas.core.frame.DataFrame dataframe containing time series data for the given profile","title":"profiles"},{"location":"Reference/power_balance/profiles/#power_balanceprofiles","text":"Source: power_balance/profiles/__init__.py","title":"power_balance.profiles"},{"location":"Reference/power_balance/profiles/#gen_cscoil_current_profile","text":"gen_cscoil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns a Central Solenoid coil current value for each step in the given time array the result is saved by default for usage in the modelica models.","title":"gen_cscoil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 50 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns","text":"numpy.ndarray transposed numpy array of time and cscoil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_nbiheat_profile","text":"gen_nbiheat_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_power : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Creates an array of neutral beam injection heat values for the given time array","title":"gen_nbiheat_profile"},{"location":"Reference/power_balance/profiles/#parameters_1","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_power : float , default None maximum power in Watts, default is 60 MW label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory.","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_1","text":"numpy.ndarray transposed numpy array of time and plasma heat values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_pf1coil_current_profile","text":"gen_pf1coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the first Poloidal Field for each step in the given time array the result is saved by default for usage in the modelica models.","title":"gen_pf1coil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters_2","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 10 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_2","text":"numpy.ndarray transposed numpy array of time and pf1coil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_pf2coil_current_profile","text":"gen_pf2coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the second Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models.","title":"gen_pf2coil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters_3","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 5 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_3","text":"numpy.ndarray transposed numpy array of time and pf2coil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_pf3coil_current_profile","text":"gen_pf3coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the third Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models.","title":"gen_pf3coil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters_4","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 2 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_4","text":"numpy.ndarray transposed numpy array of time and pf3coil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_pf4coil_current_profile","text":"gen_pf4coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the fourth Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models.","title":"gen_pf4coil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters_5","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 5 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_5","text":"numpy.ndarray transposed numpy array of time and pf4coil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_pf5coil_current_profile","text":"gen_pf5coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the fifth Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models.","title":"gen_pf5coil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters_6","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 3 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_6","text":"numpy.ndarray transposed numpy array of time and pf5coil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_pf6coil_current_profile","text":"gen_pf6coil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns current value for the sixth Poloidal Field (PF) for each step in the given time array the result is saved by default for usage in the modelica models.","title":"gen_pf6coil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters_7","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 5 kA label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_7","text":"numpy.ndarray transposed numpy array of time and pf6coil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_rfheat_profile","text":"gen_rfheat_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_power : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Creates an array of radio frequency heat values for the given time array","title":"gen_rfheat_profile"},{"location":"Reference/power_balance/profiles/#parameters_8","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_power : float , default None maximum power in Watts, default is 60 MW label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory.","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_8","text":"numpy.ndarray transposed numpy array of time and plasma heat values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_tfcoil_current_profile","text":"gen_tfcoil_current_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_current : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Assigns a Toroidal Field coil current value to each time step within the given time array","title":"gen_tfcoil_current_profile"},{"location":"Reference/power_balance/profiles/#parameters_9","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_current : float , default None maximum current in Amperes, default is 60 kA label : str , default ```` extra indentifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_9","text":"numpy.ndarray transposed numpy array of time and tfcoil current values","title":"Returns"},{"location":"Reference/power_balance/profiles/#gen_thermalpowerout_profile","text":"gen_thermalpowerout_profile ( stop_time : int = None , time_step : float = None , time_range : Tuple [ float , ... ] = None , max_power : float = None , label : str = '' , output_directory : str = '/home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files' ) -> numpy . ndarray Source: power_balance/profiles/__init__.py Creates an array of thermal power output values for the given time array","title":"gen_thermalpowerout_profile"},{"location":"Reference/power_balance/profiles/#parameters_10","text":"stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : float , default None the difference in seconds between each individual step, typically matching the time step of the simulation time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) max_power : float , default None maximum power in Watts, default is 1000 MW label : str , default ```` extra identifier for this profile output_directory : str , default /home/runner/work/powerbalance/powerbalance/power_balance/profiles/mat_profile_files name of directory to save the dataset to. If set to None, data is not saved, by default uses the module internal profile directory.","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_10","text":"numpy.ndarray transposed numpy array of time and plasma heat values","title":"Returns"},{"location":"Reference/power_balance/profiles/#generate_all","text":"generate_all ( output_directory : str , time_range : Tuple [ float , ... ] = None , stop_time : int = None , time_step : int = None , max_values : Optional [ Dict ] = None ) -> None Source: power_balance/profiles/__init__.py Generate all the current profiles in the given directory using _time_array_default and _time_range_default, and also using the max currents and powers specified in the input to the Power Balance","title":"generate_all"},{"location":"Reference/power_balance/profiles/#parameters_11","text":"output_directory : str location to save the profile '.mat' files time_range : typing.Tuple , default None the tuple containing information about the plasma scenario. typically (ramp-up start, flat-top start, flat-top end, ramp-down end) stop_time : int , default None the time in seconds at which the profile stops, typically the end of the simulation time_step : int , default None the difference in seconds between each individual step, typically matching the time step of the simulation max_values : typing.Optional , default None a dictionary containing information about the maximum currents and powers for each profile in the format {'system name': value}","title":"Parameters"},{"location":"Reference/power_balance/profiles/#read_profile_to_df","text":"read_profile_to_df ( filename : str ) -> pandas . core . frame . DataFrame Source: power_balance/profiles/__init__.py Open a '.mat' profile file and write contents to a Pandas dataframe for easy access","title":"read_profile_to_df"},{"location":"Reference/power_balance/profiles/#parameters_12","text":"filename : str address of the '.mat' file","title":"Parameters"},{"location":"Reference/power_balance/profiles/#returns_11","text":"pandas.core.frame.DataFrame dataframe containing time series data for the given profile","title":"Returns"},{"location":"Reference/power_balance/profiles/mat_profile_files/","text":"power_balance.profiles.mat_profile_files #","title":"mat_profile_files"},{"location":"Reference/power_balance/profiles/mat_profile_files/#power_balanceprofilesmat_profile_files","text":"","title":"power_balance.profiles.mat_profile_files"},{"location":"Reference/power_balance/validation/","text":"power_balance.validation # Source: power_balance/validation/__init__.py Class ModelConfig # ModelConfig () Source: power_balance/validation/__init__.py","title":"validation"},{"location":"Reference/power_balance/validation/#power_balancevalidation","text":"Source: power_balance/validation/__init__.py","title":"power_balance.validation"},{"location":"Reference/power_balance/validation/#class-modelconfig","text":"ModelConfig () Source: power_balance/validation/__init__.py","title":"Class ModelConfig"},{"location":"Reference/power_balance/validation/config/","text":"power_balance.validation.config # Source: power_balance/validation/config.py Enum AssertLevels # AssertLevels Source: power_balance/validation/config.py An enumeration. Members # NEVER : never ERROR : error WARNING : warning INFO : info DEBUG : debug Enum SweepMode # SweepMode Source: power_balance/validation/config.py An enumeration. Members # SET : set COMBINATIONS : combinations Class ConfigModel # ConfigModel ( * , models : List [ str ], modelica_file_directory : pydantic . types . DirectoryPath , parameters_directory : pydantic . types . DirectoryPath , profiles_directory : pydantic . types . DirectoryPath , simulation_options_file : power_balance . validation . config . ConstrainedStrValue , plasma_scenario_file : power_balance . validation . config . ConstrainedStrValue , structural_params_file : power_balance . validation . config . ConstrainedStrValue , sweep_mode : power_balance . validation . config . SweepMode = < SweepMode . SET : 'set' > , sweep : Dict [ str , Any ] = None ) -> None Source: power_balance/validation/config.py","title":"config"},{"location":"Reference/power_balance/validation/config/#power_balancevalidationconfig","text":"Source: power_balance/validation/config.py","title":"power_balance.validation.config"},{"location":"Reference/power_balance/validation/config/#enum-assertlevels","text":"AssertLevels Source: power_balance/validation/config.py An enumeration.","title":"Enum AssertLevels"},{"location":"Reference/power_balance/validation/config/#members","text":"NEVER : never ERROR : error WARNING : warning INFO : info DEBUG : debug","title":"Members"},{"location":"Reference/power_balance/validation/config/#enum-sweepmode","text":"SweepMode Source: power_balance/validation/config.py An enumeration.","title":"Enum SweepMode"},{"location":"Reference/power_balance/validation/config/#members_1","text":"SET : set COMBINATIONS : combinations","title":"Members"},{"location":"Reference/power_balance/validation/config/#class-configmodel","text":"ConfigModel ( * , models : List [ str ], modelica_file_directory : pydantic . types . DirectoryPath , parameters_directory : pydantic . types . DirectoryPath , profiles_directory : pydantic . types . DirectoryPath , simulation_options_file : power_balance . validation . config . ConstrainedStrValue , plasma_scenario_file : power_balance . validation . config . ConstrainedStrValue , structural_params_file : power_balance . validation . config . ConstrainedStrValue , sweep_mode : power_balance . validation . config . SweepMode = < SweepMode . SET : 'set' > , sweep : Dict [ str , Any ] = None ) -> None Source: power_balance/validation/config.py","title":"Class ConfigModel"},{"location":"Reference/power_balance/validation/modelica_simulation_options/","text":"power_balance.validation.modelica_simulation_options # Source: power_balance/validation/modelica_simulation_options.py Enum Solver # Solver Source: power_balance/validation/modelica_simulation_options.py An enumeration. Members # DASSL : dassl IDA : ida CVODE : cvode IMPEULER : impeuler TRAPEZOID : trapezoid IMPRUNGEKUTTA : imprungekutta EULER : euler HEUN : heun RUNGEKUTTA : rungekutta RUNGEKUTTASSC : rungekuttaSsc IRKSCO : irksco SYMSOLVER : symSolver SYMSOLVERSSC : symSolverSsc QSS : qss Class FromUnityInt # Source: power_balance/validation/modelica_simulation_options.py int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4 Class FromZeroInt # Source: power_balance/validation/modelica_simulation_options.py int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4 Class PlasmaScenario # PlasmaScenario ( * , plasma_ramp_up_start : power_balance . validation . modelica_simulation_options . FromZeroInt , plasma_flat_top_start : power_balance . validation . modelica_simulation_options . FromZeroInt , plasma_flat_top_end : power_balance . validation . modelica_simulation_options . FromZeroInt , plasma_ramp_down_end : power_balance . validation . modelica_simulation_options . FromZeroInt ) -> None Source: power_balance/validation/modelica_simulation_options.py Class SimOptsModel # SimOptsModel ( * , stopTime : power_balance . validation . modelica_simulation_options . FromUnityInt , startTime : power_balance . validation . modelica_simulation_options . FromZeroInt , stepSize : Union [ power_balance . validation . modelica_simulation_options . SmallestFloat , power_balance . validation . modelica_simulation_options . FromUnityInt ], solver : power_balance . validation . modelica_simulation_options . Solver = < Solver . DASSL : 'dassl' > , tolerance : power_balance . validation . modelica_simulation_options . SmallestFloat ) -> None Source: power_balance/validation/modelica_simulation_options.py Class SmallestFloat # SmallestFloat ( x = 0 , / ) Source: power_balance/validation/modelica_simulation_options.py Convert a string or number to a floating point number, if possible.","title":"modelica_simulation_options"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#power_balancevalidationmodelica_simulation_options","text":"Source: power_balance/validation/modelica_simulation_options.py","title":"power_balance.validation.modelica_simulation_options"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#enum-solver","text":"Solver Source: power_balance/validation/modelica_simulation_options.py An enumeration.","title":"Enum Solver"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#members","text":"DASSL : dassl IDA : ida CVODE : cvode IMPEULER : impeuler TRAPEZOID : trapezoid IMPRUNGEKUTTA : imprungekutta EULER : euler HEUN : heun RUNGEKUTTA : rungekutta RUNGEKUTTASSC : rungekuttaSsc IRKSCO : irksco SYMSOLVER : symSolver SYMSOLVERSSC : symSolverSsc QSS : qss","title":"Members"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#class-fromunityint","text":"Source: power_balance/validation/modelica_simulation_options.py int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4","title":"Class FromUnityInt"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#class-fromzeroint","text":"Source: power_balance/validation/modelica_simulation_options.py int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4","title":"Class FromZeroInt"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#class-plasmascenario","text":"PlasmaScenario ( * , plasma_ramp_up_start : power_balance . validation . modelica_simulation_options . FromZeroInt , plasma_flat_top_start : power_balance . validation . modelica_simulation_options . FromZeroInt , plasma_flat_top_end : power_balance . validation . modelica_simulation_options . FromZeroInt , plasma_ramp_down_end : power_balance . validation . modelica_simulation_options . FromZeroInt ) -> None Source: power_balance/validation/modelica_simulation_options.py","title":"Class PlasmaScenario"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#class-simoptsmodel","text":"SimOptsModel ( * , stopTime : power_balance . validation . modelica_simulation_options . FromUnityInt , startTime : power_balance . validation . modelica_simulation_options . FromZeroInt , stepSize : Union [ power_balance . validation . modelica_simulation_options . SmallestFloat , power_balance . validation . modelica_simulation_options . FromUnityInt ], solver : power_balance . validation . modelica_simulation_options . Solver = < Solver . DASSL : 'dassl' > , tolerance : power_balance . validation . modelica_simulation_options . SmallestFloat ) -> None Source: power_balance/validation/modelica_simulation_options.py","title":"Class SimOptsModel"},{"location":"Reference/power_balance/validation/modelica_simulation_options/#class-smallestfloat","text":"SmallestFloat ( x = 0 , / ) Source: power_balance/validation/modelica_simulation_options.py Convert a string or number to a floating point number, if possible.","title":"Class SmallestFloat"},{"location":"modelica/airgasdetrit/airgasdetrit_package/","text":"AirGasDetrit.mo # Information # The input is the thermal power, and the output is the electrical power required. Description and Method # The Air gas detrit package includes the Recombination and post dryer sections. There are 5 models included in the airgas detritiation package: Low and High Temperature Heating Heating load (kW) = Flowrate (kg/s) * Average heat capacity (kJ/kg.\u00b0C ) * (Required second stage temperature (\u00b0C) - Ambient temperature (\u00b0C)) Compression of feed gas Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) Regen heating Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - ambient air regen temperature) * turnaround time (hour) / 3600 Compression of regen gas Compressor energy (kW) = compressor work (kJ/kg) * air flowrate (kg/s) Total Contingency factor Electrolysis Power + Water heating + compressor work Assumptions # Thermal Power exiting the reactor - 1 GW Worst case assumptions Regen heating - Upstream knock out pot operating temperature - 40\u00b0C Regen heating - Pressure of air from KOP - 3 bara Comp regen gas - 'Mol sieve bed 1 turnaround operational time (from regen to saturation during operation) - 1 hr. This assumption is based off operational experience","title":"Air Gas Detritiation"},{"location":"modelica/airgasdetrit/airgasdetrit_package/#airgasdetritmo","text":"","title":"AirGasDetrit.mo"},{"location":"modelica/airgasdetrit/airgasdetrit_package/#information","text":"The input is the thermal power, and the output is the electrical power required.","title":"Information"},{"location":"modelica/airgasdetrit/airgasdetrit_package/#description-and-method","text":"The Air gas detrit package includes the Recombination and post dryer sections. There are 5 models included in the airgas detritiation package: Low and High Temperature Heating Heating load (kW) = Flowrate (kg/s) * Average heat capacity (kJ/kg.\u00b0C ) * (Required second stage temperature (\u00b0C) - Ambient temperature (\u00b0C)) Compression of feed gas Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) Regen heating Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - ambient air regen temperature) * turnaround time (hour) / 3600 Compression of regen gas Compressor energy (kW) = compressor work (kJ/kg) * air flowrate (kg/s) Total Contingency factor Electrolysis Power + Water heating + compressor work","title":"Description and Method"},{"location":"modelica/airgasdetrit/airgasdetrit_package/#assumptions","text":"Thermal Power exiting the reactor - 1 GW Worst case assumptions Regen heating - Upstream knock out pot operating temperature - 40\u00b0C Regen heating - Pressure of air from KOP - 3 bara Comp regen gas - 'Mol sieve bed 1 turnaround operational time (from regen to saturation during operation) - 1 hr. This assumption is based off operational experience","title":"Assumptions"},{"location":"modelica/blanketdetrit/power/","text":"BlanketDetrit.mo # Information # Applies to both Power_NonCarrier and Power_CarrierBreeder . The input is the thermal power, and the output is electrical power required. Description # Removal of tritium from helium (or any inert) can be performed either via recombination and water absorption or via getter material usage. Getter technology was used in this instance as this is more appropriate for smaller gas flows and high concentrations. The power implication of a getter or a recomb + dryer technology is not expected to be very different. Getter technology considers the concept of selectively absorbing tritium onto a getter type sorbent. These can function in a wide window from 200-700\u00b0C according to ST 707 brochures and the DEMO CPS study. The getter material will need to be regenerated to remove the tritium from the sorbents. This will be done be adding heat to the getter material, effectively creating a Temperature Swing Ad/Absorbent. A very small purge may be used during regen in the event the tritium content is to be diluted due to permeation concerns, however this is slightly counter intuitive as a high concentration of tritium is prefered from a purification and tritium refining perspective. Separated into the following models with these major equations for the molten Salt/liquid Coolant: Tritium breeding rate tritium Breeding Rate (mol/sec) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio He Stream calc Loss of heat He gas compression Compressor energy (kW) = compressor work (kJ/kg) * coolant flowrate (kg/s) Electrical heating cost Using the highest bed volume, either capacity limited or contact time limited Capacity limited - Bed volume = T flowrate (g/s) * 3600 / 1000 * turnaround time (hours) / saturation capacity (%) / Density (kg/m 3 ) Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara)) Constant Heating of ceramic energy (kW) = Mass of getter in one vessel (kg) * getter heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - initial regen temperature) / (Turnaround time (hr)) * 3600) Pure HeGas Compression Compressor energy (kW) = compressor work (kJ/kg) * coolant flowrate (kg/s) Total contingency factor Gas compression calc (added 20 bar) + regen heating + regen compression + hydrogen from water electrolysis","title":"Blanket Detritiation"},{"location":"modelica/blanketdetrit/power/#blanketdetritmo","text":"","title":"BlanketDetrit.mo"},{"location":"modelica/blanketdetrit/power/#information","text":"Applies to both Power_NonCarrier and Power_CarrierBreeder . The input is the thermal power, and the output is electrical power required.","title":"Information"},{"location":"modelica/blanketdetrit/power/#description","text":"Removal of tritium from helium (or any inert) can be performed either via recombination and water absorption or via getter material usage. Getter technology was used in this instance as this is more appropriate for smaller gas flows and high concentrations. The power implication of a getter or a recomb + dryer technology is not expected to be very different. Getter technology considers the concept of selectively absorbing tritium onto a getter type sorbent. These can function in a wide window from 200-700\u00b0C according to ST 707 brochures and the DEMO CPS study. The getter material will need to be regenerated to remove the tritium from the sorbents. This will be done be adding heat to the getter material, effectively creating a Temperature Swing Ad/Absorbent. A very small purge may be used during regen in the event the tritium content is to be diluted due to permeation concerns, however this is slightly counter intuitive as a high concentration of tritium is prefered from a purification and tritium refining perspective. Separated into the following models with these major equations for the molten Salt/liquid Coolant: Tritium breeding rate tritium Breeding Rate (mol/sec) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio He Stream calc Loss of heat He gas compression Compressor energy (kW) = compressor work (kJ/kg) * coolant flowrate (kg/s) Electrical heating cost Using the highest bed volume, either capacity limited or contact time limited Capacity limited - Bed volume = T flowrate (g/s) * 3600 / 1000 * turnaround time (hours) / saturation capacity (%) / Density (kg/m 3 ) Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara)) Constant Heating of ceramic energy (kW) = Mass of getter in one vessel (kg) * getter heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - initial regen temperature) / (Turnaround time (hr)) * 3600) Pure HeGas Compression Compressor energy (kW) = compressor work (kJ/kg) * coolant flowrate (kg/s) Total contingency factor Gas compression calc (added 20 bar) + regen heating + regen compression + hydrogen from water electrolysis","title":"Description"},{"location":"modelica/coolantdetrit/coolantdetrit_package/","text":"CoolantDetrit.mo # Information # As per usual, the model takes in the thermal power and outputs the electrical power required. Description and Method # There are 3 packages within the coolant detritiation package: Water Coolant Coolant purpose is a non carrier and the most basic of these packages; Gases Coolant This is has 2 coolant options with two coolant purposes so separated into the following packages: CO2 coolant. Non-Carrier purpose; Helium coolant. Non-Carrier purpose; CO2 coolant. Carrier purpose; Helium coolant. Carrier Purpose; Molten Salt or Liquid This is divided into two packages: FliBe coolant. Breeder purpose; LiPb coolant. Breeder purpose;","title":"Package"},{"location":"modelica/coolantdetrit/coolantdetrit_package/#coolantdetritmo","text":"","title":"CoolantDetrit.mo"},{"location":"modelica/coolantdetrit/coolantdetrit_package/#information","text":"As per usual, the model takes in the thermal power and outputs the electrical power required.","title":"Information"},{"location":"modelica/coolantdetrit/coolantdetrit_package/#description-and-method","text":"There are 3 packages within the coolant detritiation package: Water Coolant Coolant purpose is a non carrier and the most basic of these packages; Gases Coolant This is has 2 coolant options with two coolant purposes so separated into the following packages: CO2 coolant. Non-Carrier purpose; Helium coolant. Non-Carrier purpose; CO2 coolant. Carrier purpose; Helium coolant. Carrier Purpose; Molten Salt or Liquid This is divided into two packages: FliBe coolant. Breeder purpose; LiPb coolant. Breeder purpose;","title":"Description and Method"},{"location":"modelica/coolantdetrit/gascoolant/","text":"CoolantDetrit.GasCoolants # Information # Similarly to the water detrit strategy - only some of the gas coolant will be detritiated (although other strategies may be possible). The detitiation of the full gas coolant stream is impractical due potentially high energy costs but is also mainly to due large absorbent beds which would be difficult to regenerate and recover tritium from. The largest power consumer is from the resulting pressure drop loss across the two detrit process steps - oxidation and water knock out. The additional pressure drop in turn will result in additonal compression power. Typical airgas detrit technology using oxidation and post dryers will be used. The associated heat typically used for oxidiser reactors can be ignored as the stream will already be hot, however the post dryer energy requirements will need to be considered for the split stream. Separated into the following models with these major equations for the Gases Coolant: - Tritium breeding rate - tritium Breeding Rate (mol/s) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio - Permeation calculation - Permeation Rate (mol/s) = Permeability * (Area (m 2 ) / Length (m)) * (sqrt(Blanket side partial pressure (Pa) - sqrt(coolant side partial pressure (Pa)) - Water split stream calculation - Split steam (kg/s) = permeation rate (mol/s) / (Assumed trit removal efficiency (%) * max trit concentration permissible (mol/kg)) - Gas Compression - Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) - Regen Heating - Using the highest bed volume, either capacity limited or contact time limited - Capacity limited - Bed volume = Water flowrate (g/s) * 3600 / 1000 * turnaround time (hours) / saturation capacity (%) / Density (kg/m 3 ) - Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara)) - Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - Ambient air regen temperature) / (Turnaround time (hr)) * 3600) - Water evolving energy (kW) = Water rate (kg/hour) * Water latent heat of vaporisation (kJ/kg) * 1 / 3600 - Total regen heating rate = constant heating of ceramic + water evolving rate - Compression of Regen gas - Using the highest bed volume, either capacity limited or contact time limited - Capacity limited - Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara)) - Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - Ambient air regen temperature) / (Turnaround time (hr)) * 3600) - Water evolving energy (kW) = Water rate (kg/hour) * Water latent heat of vaporisation (kJ/kg) * 1 / 3600 - Total regen heating rate = constant heating of ceramic + water evolving rate - Compressor energy (kW) = compressor work (kJ/kg) * airflow rate (kg/s) - Electrolysis Energy - Electrolysis Power (kW) =Amount of H2 required (mol/s) * Electrolysis power consumption (kJ/molH2) - Total contingency factor - Gas compression calc (added 20 bar) + regen heating + regen compression + hydrogen from water electrolysis Assumptions # Regen Heating - Upstream knock out pot operating temperature - 40 degrees C. Worst case assumption Regen Heating - Pressure of coolant from KOP - 90 bara. Worst case assumption","title":"Gas Detritiation"},{"location":"modelica/coolantdetrit/gascoolant/#coolantdetritgascoolants","text":"","title":"CoolantDetrit.GasCoolants"},{"location":"modelica/coolantdetrit/gascoolant/#information","text":"Similarly to the water detrit strategy - only some of the gas coolant will be detritiated (although other strategies may be possible). The detitiation of the full gas coolant stream is impractical due potentially high energy costs but is also mainly to due large absorbent beds which would be difficult to regenerate and recover tritium from. The largest power consumer is from the resulting pressure drop loss across the two detrit process steps - oxidation and water knock out. The additional pressure drop in turn will result in additonal compression power. Typical airgas detrit technology using oxidation and post dryers will be used. The associated heat typically used for oxidiser reactors can be ignored as the stream will already be hot, however the post dryer energy requirements will need to be considered for the split stream. Separated into the following models with these major equations for the Gases Coolant: - Tritium breeding rate - tritium Breeding Rate (mol/s) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio - Permeation calculation - Permeation Rate (mol/s) = Permeability * (Area (m 2 ) / Length (m)) * (sqrt(Blanket side partial pressure (Pa) - sqrt(coolant side partial pressure (Pa)) - Water split stream calculation - Split steam (kg/s) = permeation rate (mol/s) / (Assumed trit removal efficiency (%) * max trit concentration permissible (mol/kg)) - Gas Compression - Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) - Regen Heating - Using the highest bed volume, either capacity limited or contact time limited - Capacity limited - Bed volume = Water flowrate (g/s) * 3600 / 1000 * turnaround time (hours) / saturation capacity (%) / Density (kg/m 3 ) - Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara)) - Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - Ambient air regen temperature) / (Turnaround time (hr)) * 3600) - Water evolving energy (kW) = Water rate (kg/hour) * Water latent heat of vaporisation (kJ/kg) * 1 / 3600 - Total regen heating rate = constant heating of ceramic + water evolving rate - Compression of Regen gas - Using the highest bed volume, either capacity limited or contact time limited - Capacity limited - Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara)) - Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - Ambient air regen temperature) / (Turnaround time (hr)) * 3600) - Water evolving energy (kW) = Water rate (kg/hour) * Water latent heat of vaporisation (kJ/kg) * 1 / 3600 - Total regen heating rate = constant heating of ceramic + water evolving rate - Compressor energy (kW) = compressor work (kJ/kg) * airflow rate (kg/s) - Electrolysis Energy - Electrolysis Power (kW) =Amount of H2 required (mol/s) * Electrolysis power consumption (kJ/molH2) - Total contingency factor - Gas compression calc (added 20 bar) + regen heating + regen compression + hydrogen from water electrolysis","title":"Information"},{"location":"modelica/coolantdetrit/gascoolant/#assumptions","text":"Regen Heating - Upstream knock out pot operating temperature - 40 degrees C. Worst case assumption Regen Heating - Pressure of coolant from KOP - 90 bara. Worst case assumption","title":"Assumptions"},{"location":"modelica/coolantdetrit/watercoolant/","text":"CoolantDetrit.WaterCoolant # Description and Method # It is impractial for all of the water in the loop to be continuously detriated (from a power perspective) hence only a side stream shall be detritated. But what is the portion of the sidestream to be treated? Seperated into the following models with these major equations: Tritium breeding rate tritium Breeding Rate (mol/s) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio Permeation calculation Permeation Rate (mol/s) = Permeability * (Area (m 2 ) / Length (m)) * (sqrt(Blanket side partial pressure (Pa) - sqrt(coolant side partial pressure (Pa)) Water split stream calculation Split steam (kg/s) = permeation rate (mol/s) / (Assumed trit removal efficiency (%) * max trit concentration permissible (mol/kg)) Electrolysis Energy Electrolysis Power (kW) = tritiated water feed * (5/2) (kg/s) * electrolysis power Water heating calculation Heating Power (kW) = Flowrate (kg/s) * (reflux ratio * heat capacity (kJ / kg.\u00b0C) * (Target T (\u00b0C) - Ambient T (\u00b0C)) + latent heat of vapourisation * vapour fraction) Gas Compression Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) Total contingency factor Electrolysis Power + Water Heating + Compressor work Assumptions # Water Split stream calculation - Assumed tritium removal effciency of 95%","title":"Water Detritiation"},{"location":"modelica/coolantdetrit/watercoolant/#coolantdetritwatercoolant","text":"","title":"CoolantDetrit.WaterCoolant"},{"location":"modelica/coolantdetrit/watercoolant/#description-and-method","text":"It is impractial for all of the water in the loop to be continuously detriated (from a power perspective) hence only a side stream shall be detritated. But what is the portion of the sidestream to be treated? Seperated into the following models with these major equations: Tritium breeding rate tritium Breeding Rate (mol/s) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio Permeation calculation Permeation Rate (mol/s) = Permeability * (Area (m 2 ) / Length (m)) * (sqrt(Blanket side partial pressure (Pa) - sqrt(coolant side partial pressure (Pa)) Water split stream calculation Split steam (kg/s) = permeation rate (mol/s) / (Assumed trit removal efficiency (%) * max trit concentration permissible (mol/kg)) Electrolysis Energy Electrolysis Power (kW) = tritiated water feed * (5/2) (kg/s) * electrolysis power Water heating calculation Heating Power (kW) = Flowrate (kg/s) * (reflux ratio * heat capacity (kJ / kg.\u00b0C) * (Target T (\u00b0C) - Ambient T (\u00b0C)) + latent heat of vapourisation * vapour fraction) Gas Compression Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) Total contingency factor Electrolysis Power + Water Heating + Compressor work","title":"Description and Method"},{"location":"modelica/coolantdetrit/watercoolant/#assumptions","text":"Water Split stream calculation - Assumed tritium removal effciency of 95%","title":"Assumptions"},{"location":"modelica/cryo/convertflowelec/","text":"CryogenicPlant.CryogenicPower.convertFlowElec # Information # Calculates the electrical power required to cool a Helium coolant loop on the cold side of a heat exchanger. The power is calculated using the exergy change associated with bringing helium down to a given temperature tempC from room temperature. This is the method used by [1] (see p82). The logarithmic equation is a fit to values generated by coolprop. References # [1] Tanna, V. L. 'Design and Analysis of the Superconducting Current Feeder System for the International Thermonuclear Experimental Reactor (ITER)', October 2006","title":"Cryogenic Power Conversion"},{"location":"modelica/cryo/convertflowelec/#cryogenicplantcryogenicpowerconvertflowelec","text":"","title":"CryogenicPlant.CryogenicPower.convertFlowElec"},{"location":"modelica/cryo/convertflowelec/#information","text":"Calculates the electrical power required to cool a Helium coolant loop on the cold side of a heat exchanger. The power is calculated using the exergy change associated with bringing helium down to a given temperature tempC from room temperature. This is the method used by [1] (see p82). The logarithmic equation is a fit to values generated by coolprop.","title":"Information"},{"location":"modelica/cryo/convertflowelec/#references","text":"[1] Tanna, V. L. 'Design and Analysis of the Superconducting Current Feeder System for the International Thermonuclear Experimental Reactor (ITER)', October 2006","title":"References"},{"location":"modelica/cryo/cryogenic_power/","text":"CryogenicPlant.CryogenicPower # Information # Model of the power loads of the cryogenic plant. Model Description and Method # This model calulates the electrical power load of a Tokamak Cryogenic Plant by summing the power required for the following cryogenic loads: Hydrogen Freezing Cryodistillation Magnet Radiative Magnet Dissipative Cryopumping These cryogenic loads are modelled at a high level by taking their operating temperatures and calculating an individual carnot efficiency. This carnot efficiency is applied to the load's cooling power to find the ideal electrical power consumption. The practical power consumption is then found by applying an individual figure of merit to the ideal consumption. For the each of the cryogenic loads, the required cooling power is either assumed steady state, or in some cases, calculated using a more deatiled model. This is further explained below: Hydrogen Freezing - Assumed Steady-State 3.5g/s (copied from pellet Injection flow rate for JT60SA www.jt60sa.org/pdfs/cdr/10-3.5_Cryogenic_System.pdf) Cryodistillation - Modelled using net-flow-rates between columns and gas constants applied to Steady State Flow Equation Magnet Radiative - Modelled using 4th order polyfit to neutronic simulation data, with known parameters; PF heatload and neutronic shielding thickness Magnet Dissipative - Assumed Steady State 3MW Cryopumping - Assumed Seady State 100kW Assumptions # General: Each model uses a different cold temperature this assumes the ability to provide He2 at different pressures and the cost of this flexibility is not explicitly considered The system efficiency is taken as a block FOM(Figure of Merit) efficiency, but where this number comes from is not considered The transportation, pumping, and storage losses are not considered The use of byproducts such as enriched Hydrogen or waste heat is not considered Some product areas have static cooling power values as phase 2 modelling has not been attempted Room temperature is assumed to be 298K across the models Magnet Cooling: 2 coolants are assumed to be used at potentially different temperatures Radiative/Neutronic heat is assumed to be 100 percent dissipated in the outer coolant sink Dissipative/Resistive heat is assumed to be 100 percent dissipated in the inner coolant sink The equation for neutronic heat loads on the Central Solonoid coil is a 4th order polynomial fit to data from Tokamak (1GW-DI1) neutronics analysis over the range 10-60cm The static value for the PF coils is similarly taken from Tokamak (1GW-DI1) neutronics analysis TF coil cooling for radiative heat is not considered Resistive heat values are to be taken from the Magnet System Power consumption models Cryodistillation: ITER-like configuration considered [] hence the naming conventions for the various columns Ambient power used to reboil Liquid Hydrogen Heat Exchangers Loss-less Specific Heat of Gaseous Hydrogen, Specifc Heat of Liquid Hydrogen are assumed to be for Parahydrogen at 1 atm and 20.27 K Latent Heat of Evaporation is assumed to be for Parahydrogen at 1 atm and 20.27 K Temperature of Evaporation is assumed to be for Parahydrogen at 1 atm Pressure assumed constant for input cooling and super cooling of reflux Most default values are taken from ITER paper Values unknown for the mass flow rates of the Feedback stream from Column 3 to Column 1 and the output stream from Column 3, Decay heat of Tritium not considered Pressure drops in columns are not considered Hence pumping requirements not considered Comprehensive model diagram","title":"Cryo Power"},{"location":"modelica/cryo/cryogenic_power/#cryogenicplantcryogenicpower","text":"","title":"CryogenicPlant.CryogenicPower"},{"location":"modelica/cryo/cryogenic_power/#information","text":"Model of the power loads of the cryogenic plant.","title":"Information"},{"location":"modelica/cryo/cryogenic_power/#model-description-and-method","text":"This model calulates the electrical power load of a Tokamak Cryogenic Plant by summing the power required for the following cryogenic loads: Hydrogen Freezing Cryodistillation Magnet Radiative Magnet Dissipative Cryopumping These cryogenic loads are modelled at a high level by taking their operating temperatures and calculating an individual carnot efficiency. This carnot efficiency is applied to the load's cooling power to find the ideal electrical power consumption. The practical power consumption is then found by applying an individual figure of merit to the ideal consumption. For the each of the cryogenic loads, the required cooling power is either assumed steady state, or in some cases, calculated using a more deatiled model. This is further explained below: Hydrogen Freezing - Assumed Steady-State 3.5g/s (copied from pellet Injection flow rate for JT60SA www.jt60sa.org/pdfs/cdr/10-3.5_Cryogenic_System.pdf) Cryodistillation - Modelled using net-flow-rates between columns and gas constants applied to Steady State Flow Equation Magnet Radiative - Modelled using 4th order polyfit to neutronic simulation data, with known parameters; PF heatload and neutronic shielding thickness Magnet Dissipative - Assumed Steady State 3MW Cryopumping - Assumed Seady State 100kW","title":"Model Description and Method"},{"location":"modelica/cryo/cryogenic_power/#assumptions","text":"General: Each model uses a different cold temperature this assumes the ability to provide He2 at different pressures and the cost of this flexibility is not explicitly considered The system efficiency is taken as a block FOM(Figure of Merit) efficiency, but where this number comes from is not considered The transportation, pumping, and storage losses are not considered The use of byproducts such as enriched Hydrogen or waste heat is not considered Some product areas have static cooling power values as phase 2 modelling has not been attempted Room temperature is assumed to be 298K across the models Magnet Cooling: 2 coolants are assumed to be used at potentially different temperatures Radiative/Neutronic heat is assumed to be 100 percent dissipated in the outer coolant sink Dissipative/Resistive heat is assumed to be 100 percent dissipated in the inner coolant sink The equation for neutronic heat loads on the Central Solonoid coil is a 4th order polynomial fit to data from Tokamak (1GW-DI1) neutronics analysis over the range 10-60cm The static value for the PF coils is similarly taken from Tokamak (1GW-DI1) neutronics analysis TF coil cooling for radiative heat is not considered Resistive heat values are to be taken from the Magnet System Power consumption models Cryodistillation: ITER-like configuration considered [] hence the naming conventions for the various columns Ambient power used to reboil Liquid Hydrogen Heat Exchangers Loss-less Specific Heat of Gaseous Hydrogen, Specifc Heat of Liquid Hydrogen are assumed to be for Parahydrogen at 1 atm and 20.27 K Latent Heat of Evaporation is assumed to be for Parahydrogen at 1 atm and 20.27 K Temperature of Evaporation is assumed to be for Parahydrogen at 1 atm Pressure assumed constant for input cooling and super cooling of reflux Most default values are taken from ITER paper Values unknown for the mass flow rates of the Feedback stream from Column 3 to Column 1 and the output stream from Column 3, Decay heat of Tritium not considered Pressure drops in columns are not considered Hence pumping requirements not considered Comprehensive model diagram","title":"Assumptions"},{"location":"modelica/cryo/turbopump_cryo/","text":"CryogenicPlant.TurboPumpCryogenics # Information # A model to simulate a cryopump operation Cryo-pump calculations # Using the ITER cryopumps which can run the operation at a minimum pressure of 2.5x10-3 mbar (....\\pumps\\Maintenance\\PBS31 - Vacuum Vessel and Neutral Beam Pumping Systems (May'20 Draft).docx) Assumptions # ITER combines ScHe, He at 80 K and 120 K He to operate the pumping and the regeneration cycles The cryo pump(s) operate at 20 K to pump out the SPR vaccum vessel The cryo pump(s) are regernated at 120 K. No electrical power consumption for cooling down to 120 K has been added The flow rate is 99% of the injected D2 and T2, the other flows are neglected. D2 = 0.02049 mol/s and T2 = 0.02049.","title":"Cryopump"},{"location":"modelica/cryo/turbopump_cryo/#cryogenicplantturbopumpcryogenics","text":"","title":"CryogenicPlant.TurboPumpCryogenics"},{"location":"modelica/cryo/turbopump_cryo/#information","text":"A model to simulate a cryopump operation","title":"Information"},{"location":"modelica/cryo/turbopump_cryo/#cryo-pump-calculations","text":"Using the ITER cryopumps which can run the operation at a minimum pressure of 2.5x10-3 mbar (....\\pumps\\Maintenance\\PBS31 - Vacuum Vessel and Neutral Beam Pumping Systems (May'20 Draft).docx)","title":"Cryo-pump calculations"},{"location":"modelica/cryo/turbopump_cryo/#assumptions","text":"ITER combines ScHe, He at 80 K and 120 K He to operate the pumping and the regeneration cycles The cryo pump(s) operate at 20 K to pump out the SPR vaccum vessel The cryo pump(s) are regernated at 120 K. No electrical power consumption for cooling down to 120 K has been added The flow rate is 99% of the injected D2 and T2, the other flows are neglected. D2 = 0.02049 mol/s and T2 = 0.02049.","title":"Assumptions"},{"location":"modelica/hcd/hcd_system/","text":"HCDSystemPkg.HCDSystem # Information # Model of the power consumption of a Heading and Current Drive System, taking in the thermal power supplied to the plasma and calculating the electrical power required using wall plug efficiencies. Model Description and Method # This model calculates the total electrical power consumption over time, for a Tokamak external Heating and Current Drive system consisting of RF and NBI systems. Inputs # RF thermal power supplied to the plasma, profile over time NBI thermal power supplied to the plasma, profile over time Wall-Plug efficiency (electrical - thermal) of RF, defualt 0.4 NBI and RF consumptions are then summed to find the total electrical consumption of the external Heating and Current Drive system. Assumptions # Tokamak will use similar technology to ITERs neutral beam system: Approximately 50 MW beam output power requirement. [1] Negative ion injection. Uses a powered ion dump. 20-30% W.P Efficiency. [1] Tokamak will use similar technology to ITERs RF systems: Approximately 40 MW RF output power (20 MW ICRH + 20 MW ECRH) requirement. [2] 1 MW Gyrotrons. 30-40% W.P Efficiency. [3] Assumes only one type of RF technology used, as only one RF efficiency parameter. Assuming a pulse length of 60 seconds, no continuous run. Assuming thermal power contained within the plasma has ramp up and steady state period. Assuming that Heating and Current Drive Systems (RF and NBI) are responsible for all thermal power contained within the plasma Assuming that RF system has a fixed Wall-Plug efficiency which describes the entire conversion from electrical power taken from the grid to thermal power in the plasma. For NBI, assuming Negative Ion type as efficiencies are very poor for positive ion at beam energy above 150 keV [1] \"Technology developments for a beam source of an NNBI system for DEMO,\" Fusion Engineering and Design, Vols. 136, Part A, no. November, pp. 340-344, 2018. [2] P. Brans, \"Ion cyclotron heating: How to pump 20 MW of power into 1 gram of plasma,\" 13 Jan 2020. [Online]. Available: https://www.iter.org/newsline/-/3382. [Accessed July 2020]. [3] E. W. Sarah Parry Wright, \"Tokamak Additional Heating Power Supplies Literature Review,\" 2020.","title":"H&CD Power"},{"location":"modelica/hcd/hcd_system/#hcdsystempkghcdsystem","text":"","title":"HCDSystemPkg.HCDSystem"},{"location":"modelica/hcd/hcd_system/#information","text":"Model of the power consumption of a Heading and Current Drive System, taking in the thermal power supplied to the plasma and calculating the electrical power required using wall plug efficiencies.","title":"Information"},{"location":"modelica/hcd/hcd_system/#model-description-and-method","text":"This model calculates the total electrical power consumption over time, for a Tokamak external Heating and Current Drive system consisting of RF and NBI systems.","title":"Model Description and Method"},{"location":"modelica/hcd/hcd_system/#inputs","text":"RF thermal power supplied to the plasma, profile over time NBI thermal power supplied to the plasma, profile over time Wall-Plug efficiency (electrical - thermal) of RF, defualt 0.4 NBI and RF consumptions are then summed to find the total electrical consumption of the external Heating and Current Drive system.","title":"Inputs"},{"location":"modelica/hcd/hcd_system/#assumptions","text":"Tokamak will use similar technology to ITERs neutral beam system: Approximately 50 MW beam output power requirement. [1] Negative ion injection. Uses a powered ion dump. 20-30% W.P Efficiency. [1] Tokamak will use similar technology to ITERs RF systems: Approximately 40 MW RF output power (20 MW ICRH + 20 MW ECRH) requirement. [2] 1 MW Gyrotrons. 30-40% W.P Efficiency. [3] Assumes only one type of RF technology used, as only one RF efficiency parameter. Assuming a pulse length of 60 seconds, no continuous run. Assuming thermal power contained within the plasma has ramp up and steady state period. Assuming that Heating and Current Drive Systems (RF and NBI) are responsible for all thermal power contained within the plasma Assuming that RF system has a fixed Wall-Plug efficiency which describes the entire conversion from electrical power taken from the grid to thermal power in the plasma. For NBI, assuming Negative Ion type as efficiencies are very poor for positive ion at beam energy above 150 keV [1] \"Technology developments for a beam source of an NNBI system for DEMO,\" Fusion Engineering and Design, Vols. 136, Part A, no. November, pp. 340-344, 2018. [2] P. Brans, \"Ion cyclotron heating: How to pump 20 MW of power into 1 gram of plasma,\" 13 Jan 2020. [Online]. Available: https://www.iter.org/newsline/-/3382. [Accessed July 2020]. [3] E. W. Sarah Parry Wright, \"Tokamak Additional Heating Power Supplies Literature Review,\" 2020.","title":"Assumptions"},{"location":"modelica/hcd/nini/","text":"Tokamak.HCDSystemPkg.NINI # Information # Model of Negative Ion Neutral Injector. This model was modified from Damian King and Elizabeth Surrey's code, used for NBI studies[1]. The original (ENBI.pro) and modified (ENBI_mcannon.pro) versions, along with input parameters and associated excel spreadsheet can be found here: (15) Power Balance Models (B1.6 Power Infrastructure) | Microsoft Teams The model now calculates electrical power usage as a function of heat to plasma. The code was taken from ENBI.pro (see appendix). This is a verified code written in IDL and is written to calculate the power coupled to plasma for a given set of input parameters and a given wallplug power. The code is modified here to output wall plug power usage for a given power coupled to plasma. The model first calculates the number of injectors and beamlines (numInjectors, numBeamlines) required to output the maximum thermal power. This calculation is done using the parameters below: __NBIThermalPowerMaxMW, maxJ, maxDeuteriumCurrent_TotalPulse The model then adjusts beam current in order to give an output power matching the profile it is given. [1] \"Improved Parameterisation of NBI Systems Code\", D. King, E. Surrey, December 2012 Appendix 1: ENBI.pro (original IDL code) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; ;ENBI ; ; IDL version of NBI system code ENBI (Efficiency of Neutral Beam Injector) ; ; ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;general inputs;;;; PRO ENBI,n,input_vary result=read_ascii('input.txt') all=result.field1 s=size(all, /dimensions) all2=fltarr(s(1)) all2(*)=all(1,*) all2(n)=input_vary coreDivergence= all2(0) haloDivergence= all2(1) beam_E= all2(2) beamlineLength= all2(3) gridArea= all2(4) ext_area= all2(5) electronRatio= all2(6) J= all2(7) numInj_PerLine= all2(8) numBeamlines= all2(9) ;power supply inputs extractionVolt= all2(10) suppressionVolt= all2(11) filterVolt= all2(12) filterCurrent= all2(13) stripFraction_Laser= all2(14) stripVolt= all2(15) stripCollected= all2(16) powerRF= all2(17) efficiencyDC= all2(18) efficiencyRF= all2(19) ;laser neutraliser laser= fix(all2(20)) efficiencyLaser= all2(21) neut_chan_w= all2(22) numChannels= all2(23) efficiencyNeutralization= all2(24) ;energy recovery negVolt =all2(25) negFraction =all2(26) posVolt =all2(27) posFraction =all2(28) efficiencyPosConverter =all2(31) powerIncidentals= all2(32) stripFraction_Laser= all2(33) ;;;;;;;;;;;;;;;;;;;;;calculations;;;;;;;;;;;;;;;;;;;;;;;;;;; DeuteriumCurrent_PerLine=ext_area*J electronCurrent_PerLine=DeuteriumCurrent_PerLine*electronRatio IF (laser EQ 0) THEN stripFraction=stripFraction_Laser*ext_area/0.197 ELSE stripFraction=stripFraction_Laser*ext_area/0.197 IF (laser EQ 0) THEN neg_RI_frac=0.21 ELSE neg_RI_frac=1-efficiencyNeutralization IF (laser EQ 0) THEN pos_RI_frac=0.21 ELSE pos_RI_frac=all2(30) IF (laser EQ 0) THEN efficiencyNeutralization=0.58 ELSE efficiencyNeutralization=all2(24) IF (laser EQ 0) THEN powerIncidentals=6 ELSE powerIncidentals=all2(32) currentHVPSU=DeuteriumCurrent_PerLine*(1-stripCollected*stripFraction-negFraction*neg_RI_frac*(1-stripFraction)) powerHVPSU=currentHVPSU*beam_E suppressionCurrent=J*(gridArea-ext_area) extractionPower=extractionVolt*electronCurrent_PerLine/(1000.0*efficiencyDC) suppressionPower_PerLine=suppressionCurrent*suppressionVolt/(1000000.0*efficiencyDC) filterPower_PerLine=filterVolt*filterCurrent/(1000000.0*efficiencyDC) stripPower_PerLine=stripFraction*stripCollected*stripVolt*DeuteriumCurrent_PerLine/1000.0 tot_HVP=(powerHVPSU+extractionPower+suppressionPower_PerLine+filterPower_PerLine+stripPower_PerLine)/efficiencyDC RFInputPower_PerLine=powerRF/(1000.0*efficiencyRF) tot_inj_P=tot_HVP+RFInputPower_PerLine neg_rec_P=neg_RI_frac*DeuteriumCurrent_PerLine*(1-stripFraction)*negFraction*negVolt/(1000.0*efficiencyDC) pos_rec_P=pos_ri_frac*DeuteriumCurrent_PerLine*(1-stripFraction)*posFraction*posVolt*efficiencyPosConverter IF (laser EQ 0) THEN BEGIN laser_P=0 ENDIF ELSE BEGIN laser_P=-55.39*9788*((beam_E*1000000.0)^0.5)*alog(1-efficiencyNeutralization)*neut_chan_w*numChannels/(500.0*efficiencyLaser*1000000) ENDELSE tot_in_P=tot_inj_P+laser_p+neg_rec_p+powerIncidentals-pos_rec_p transmit_p=DeuteriumCurrent_PerLine*beam_E*(1-stripFraction) di_loss_NH=(0.0122*coreDivergence^2.0)-0.0708*coreDivergence+0.1029 di_loss_H=(0.0102*coreDivergence^2.0)-0.0496*coreDivergence+0.0711 haloDivergence=fix(haloDivergence) IF (haloDivergence EQ 0) THEN di_loss=di_loss_nh ELSE di_loss=di_loss_h ;IF (coreDivergence LT 3.1) THEN di_loss=0 ELSE di_loss=di_loss lossReionisation_Laser=0.01*(ext_area/0.2)*(beamlineLength/23.0)*(2.0/3.0)*numInj_PerLine lossReionisation_NoLaser=0.05*(ext_area/0.2)*(beamlineLength/23.0)*(2.0/3.0)*numInj_PerLine IF (laser EQ 0) THEN lossReionisation=lossReionisation_NoLaser ELSE lossReionisation=lossReionisation_Laser lossTransmission=lossReionisation+di_loss p_to_p=DeuteriumCurrent_PerLine*beam_E*(1-stripFraction)*(1-lossTransmission)*efficiencyNeutralization*numInj_PerLine print,'Power out = ', p_to_p print,'Power in = ', tot_in_p wallplug=p_to_p/tot_in_p print,'wallplug = ', wallplug SAVE,filename='temp.sav' END","title":"Neutral Beam Injection (NINI-type)"},{"location":"modelica/hcd/nini/#tokamakhcdsystempkgnini","text":"","title":"Tokamak.HCDSystemPkg.NINI"},{"location":"modelica/hcd/nini/#information","text":"Model of Negative Ion Neutral Injector. This model was modified from Damian King and Elizabeth Surrey's code, used for NBI studies[1]. The original (ENBI.pro) and modified (ENBI_mcannon.pro) versions, along with input parameters and associated excel spreadsheet can be found here: (15) Power Balance Models (B1.6 Power Infrastructure) | Microsoft Teams The model now calculates electrical power usage as a function of heat to plasma. The code was taken from ENBI.pro (see appendix). This is a verified code written in IDL and is written to calculate the power coupled to plasma for a given set of input parameters and a given wallplug power. The code is modified here to output wall plug power usage for a given power coupled to plasma. The model first calculates the number of injectors and beamlines (numInjectors, numBeamlines) required to output the maximum thermal power. This calculation is done using the parameters below: __NBIThermalPowerMaxMW, maxJ, maxDeuteriumCurrent_TotalPulse The model then adjusts beam current in order to give an output power matching the profile it is given. [1] \"Improved Parameterisation of NBI Systems Code\", D. King, E. Surrey, December 2012 Appendix 1: ENBI.pro (original IDL code) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; ;ENBI ; ; IDL version of NBI system code ENBI (Efficiency of Neutral Beam Injector) ; ; ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;general inputs;;;; PRO ENBI,n,input_vary result=read_ascii('input.txt') all=result.field1 s=size(all, /dimensions) all2=fltarr(s(1)) all2(*)=all(1,*) all2(n)=input_vary coreDivergence= all2(0) haloDivergence= all2(1) beam_E= all2(2) beamlineLength= all2(3) gridArea= all2(4) ext_area= all2(5) electronRatio= all2(6) J= all2(7) numInj_PerLine= all2(8) numBeamlines= all2(9) ;power supply inputs extractionVolt= all2(10) suppressionVolt= all2(11) filterVolt= all2(12) filterCurrent= all2(13) stripFraction_Laser= all2(14) stripVolt= all2(15) stripCollected= all2(16) powerRF= all2(17) efficiencyDC= all2(18) efficiencyRF= all2(19) ;laser neutraliser laser= fix(all2(20)) efficiencyLaser= all2(21) neut_chan_w= all2(22) numChannels= all2(23) efficiencyNeutralization= all2(24) ;energy recovery negVolt =all2(25) negFraction =all2(26) posVolt =all2(27) posFraction =all2(28) efficiencyPosConverter =all2(31) powerIncidentals= all2(32) stripFraction_Laser= all2(33) ;;;;;;;;;;;;;;;;;;;;;calculations;;;;;;;;;;;;;;;;;;;;;;;;;;; DeuteriumCurrent_PerLine=ext_area*J electronCurrent_PerLine=DeuteriumCurrent_PerLine*electronRatio IF (laser EQ 0) THEN stripFraction=stripFraction_Laser*ext_area/0.197 ELSE stripFraction=stripFraction_Laser*ext_area/0.197 IF (laser EQ 0) THEN neg_RI_frac=0.21 ELSE neg_RI_frac=1-efficiencyNeutralization IF (laser EQ 0) THEN pos_RI_frac=0.21 ELSE pos_RI_frac=all2(30) IF (laser EQ 0) THEN efficiencyNeutralization=0.58 ELSE efficiencyNeutralization=all2(24) IF (laser EQ 0) THEN powerIncidentals=6 ELSE powerIncidentals=all2(32) currentHVPSU=DeuteriumCurrent_PerLine*(1-stripCollected*stripFraction-negFraction*neg_RI_frac*(1-stripFraction)) powerHVPSU=currentHVPSU*beam_E suppressionCurrent=J*(gridArea-ext_area) extractionPower=extractionVolt*electronCurrent_PerLine/(1000.0*efficiencyDC) suppressionPower_PerLine=suppressionCurrent*suppressionVolt/(1000000.0*efficiencyDC) filterPower_PerLine=filterVolt*filterCurrent/(1000000.0*efficiencyDC) stripPower_PerLine=stripFraction*stripCollected*stripVolt*DeuteriumCurrent_PerLine/1000.0 tot_HVP=(powerHVPSU+extractionPower+suppressionPower_PerLine+filterPower_PerLine+stripPower_PerLine)/efficiencyDC RFInputPower_PerLine=powerRF/(1000.0*efficiencyRF) tot_inj_P=tot_HVP+RFInputPower_PerLine neg_rec_P=neg_RI_frac*DeuteriumCurrent_PerLine*(1-stripFraction)*negFraction*negVolt/(1000.0*efficiencyDC) pos_rec_P=pos_ri_frac*DeuteriumCurrent_PerLine*(1-stripFraction)*posFraction*posVolt*efficiencyPosConverter IF (laser EQ 0) THEN BEGIN laser_P=0 ENDIF ELSE BEGIN laser_P=-55.39*9788*((beam_E*1000000.0)^0.5)*alog(1-efficiencyNeutralization)*neut_chan_w*numChannels/(500.0*efficiencyLaser*1000000) ENDELSE tot_in_P=tot_inj_P+laser_p+neg_rec_p+powerIncidentals-pos_rec_p transmit_p=DeuteriumCurrent_PerLine*beam_E*(1-stripFraction) di_loss_NH=(0.0122*coreDivergence^2.0)-0.0708*coreDivergence+0.1029 di_loss_H=(0.0102*coreDivergence^2.0)-0.0496*coreDivergence+0.0711 haloDivergence=fix(haloDivergence) IF (haloDivergence EQ 0) THEN di_loss=di_loss_nh ELSE di_loss=di_loss_h ;IF (coreDivergence LT 3.1) THEN di_loss=0 ELSE di_loss=di_loss lossReionisation_Laser=0.01*(ext_area/0.2)*(beamlineLength/23.0)*(2.0/3.0)*numInj_PerLine lossReionisation_NoLaser=0.05*(ext_area/0.2)*(beamlineLength/23.0)*(2.0/3.0)*numInj_PerLine IF (laser EQ 0) THEN lossReionisation=lossReionisation_NoLaser ELSE lossReionisation=lossReionisation_Laser lossTransmission=lossReionisation+di_loss p_to_p=DeuteriumCurrent_PerLine*beam_E*(1-stripFraction)*(1-lossTransmission)*efficiencyNeutralization*numInj_PerLine print,'Power out = ', p_to_p print,'Power in = ', tot_in_p wallplug=p_to_p/tot_in_p print,'wallplug = ', wallplug SAVE,filename='temp.sav' END","title":"Information"},{"location":"modelica/hcd/rf_gyrotron/","text":"Tokamak.HCDSystemPkg.RF.Gyrotron # Information # Model of an RF Gyrotron Model Description and Method # This model is based on the design of a 170GHz 1.5MW Grotron by Kalaria & Kartikeyan [1, 2]. The Gyrotron model is broken down into three sub-models, namely Magntron Injection Gun (MIG) model Beam model RF coil model. The electrical power delivered to the Gyrotron is the product of its efficiency and the RF power delivered to the plasma via the Waveguide. The efficiency of the Gyrotron is estimated as the product of the efficiencies of the sub-models (that make up the Gyrotron) based on their design parameters or configuration. The default values used to calculate the efficiency of the sub-models were taken from the design described in [2]. References [1] S. Stewart, \"Modelling of Radio Frequency Heating and Current Drive Systems for Nuclear Fusion,\" 2020. [2] P. C. Kalaria, M. V. Kartikeyan and M. Thumm, \"Design of 170GHz, 1.5-MW Conventional Cavity Gyrotron for Plasma Heating,\" IEEE Transactions on Plasma Science, pp. 1522-1528, 2014.","title":"RF Gyrotron"},{"location":"modelica/hcd/rf_gyrotron/#tokamakhcdsystempkgrfgyrotron","text":"","title":"Tokamak.HCDSystemPkg.RF.Gyrotron"},{"location":"modelica/hcd/rf_gyrotron/#information","text":"Model of an RF Gyrotron","title":"Information"},{"location":"modelica/hcd/rf_gyrotron/#model-description-and-method","text":"This model is based on the design of a 170GHz 1.5MW Grotron by Kalaria & Kartikeyan [1, 2]. The Gyrotron model is broken down into three sub-models, namely Magntron Injection Gun (MIG) model Beam model RF coil model. The electrical power delivered to the Gyrotron is the product of its efficiency and the RF power delivered to the plasma via the Waveguide. The efficiency of the Gyrotron is estimated as the product of the efficiencies of the sub-models (that make up the Gyrotron) based on their design parameters or configuration. The default values used to calculate the efficiency of the sub-models were taken from the design described in [2]. References [1] S. Stewart, \"Modelling of Radio Frequency Heating and Current Drive Systems for Nuclear Fusion,\" 2020. [2] P. C. Kalaria, M. V. Kartikeyan and M. Thumm, \"Design of 170GHz, 1.5-MW Conventional Cavity Gyrotron for Plasma Heating,\" IEEE Transactions on Plasma Science, pp. 1522-1528, 2014.","title":"Model Description and Method"},{"location":"modelica/hcd/rf_waveguide/","text":"Tokamak.HCDSystemPkg.RF.WaveGuide # Information # Model of Waveguide Network Model Description and Method # The Waveguide network transmits RF power from the Gyrotron to the plasma. Due to the tight space in tokamaks, RF power is usually transmitted over a long distance up to 100 meters at low losses. However, there are sources of power loss in the Waveguide which are: Coupling losses in and out of waveguide (both = 1.9%) Reflections at chemical vapour deposition windows (CVD loss) (0.3%) Launcher losses (1.0%) Mitre bend losses (calculated as 3.46%) Attenuation introduced by the mode converters (calculated as 1.39e-6%) The values were the default values for a 7 mitre bend, 100m length, 45mm diameter at 110GHz waveguide (WG45) [1, 2]. The efficiency of the Waveguide network is obtained from the difference of all the losses from that of an ideal waveguide network. The RF power into the Waveguide network is calculated by multiplying the efficiency and the RF heating power delivered to the plasma by the Waveguide. References [1] S. Stewart, \"Modelling of Radio Frequency Heating and Current Drive Systems for Nuclear Fusion,\" 2020. [2] S. Alberti, T. P. Goodman and et al., \"An ITER relevant evacuated waveguide transmission system for the JET-EP ECRH project,\" Nuclear Fusion, vol. 43, pp. 1-14, 2003.","title":"RF Waveguide"},{"location":"modelica/hcd/rf_waveguide/#tokamakhcdsystempkgrfwaveguide","text":"","title":"Tokamak.HCDSystemPkg.RF.WaveGuide"},{"location":"modelica/hcd/rf_waveguide/#information","text":"Model of Waveguide Network","title":"Information"},{"location":"modelica/hcd/rf_waveguide/#model-description-and-method","text":"The Waveguide network transmits RF power from the Gyrotron to the plasma. Due to the tight space in tokamaks, RF power is usually transmitted over a long distance up to 100 meters at low losses. However, there are sources of power loss in the Waveguide which are: Coupling losses in and out of waveguide (both = 1.9%) Reflections at chemical vapour deposition windows (CVD loss) (0.3%) Launcher losses (1.0%) Mitre bend losses (calculated as 3.46%) Attenuation introduced by the mode converters (calculated as 1.39e-6%) The values were the default values for a 7 mitre bend, 100m length, 45mm diameter at 110GHz waveguide (WG45) [1, 2]. The efficiency of the Waveguide network is obtained from the difference of all the losses from that of an ideal waveguide network. The RF power into the Waveguide network is calculated by multiplying the efficiency and the RF heating power delivered to the plasma by the Waveguide. References [1] S. Stewart, \"Modelling of Radio Frequency Heating and Current Drive Systems for Nuclear Fusion,\" 2020. [2] S. Alberti, T. P. Goodman and et al., \"An ITER relevant evacuated waveguide transmission system for the JET-EP ECRH project,\" Nuclear Fusion, vol. 43, pp. 1-14, 2003.","title":"Model Description and Method"},{"location":"modelica/magnet/basemagnet/","text":"Magnets.BaseMagnet # A partial model to act as a platform on which specialized magnet systems can be built. Extended By # TF_Magnet PF_Magnet Information # The following is the base magnet model. From this partial model, the TF and PF magnets are extended, and theoretically any other magnet system could be extended as well. The model does not consider temperature and field variations, and it does not consider any standard coil protection schemes such as FDUs. Input # The input i_in is intended to come in as a predefined signal (see MagnetPower), and a SignalCurrent block is used to translate this signal into a current for our system. Power Supply # Given the required fidelity and detail of the model, we do not have to model the behaviour of an AC-DC converter. In fact, our input signal is already a DC current generated by a comverter somewhere upstream, outside the model. Should the behaviour of an AC-DC converter need to be modelled, this can be done in a separate model. With the above in mind, we have used a ConstantVoltage component to emulate the voltage drop (and thus power consumption) of a power converter. The relevant iinput here is __Vdrop which, multiplied by two, gives a rough estimate. This means our power supply unit does not consider the relationship between output current and voltage drop, and is 'always on'. Feeder # The feeder for this system assumes one of two options - a resistive (default) using the basic Resistor component, and a superconducting option using the custom SuperconLayer. It can be thought of as the description of the busbars and feeders that link the power converter with the coils. However, capacitance and inductance are ignored. The input for a resistive feeder is __Rfeeder . Coil # As with the feeder, the user may choose either a resistive (default) using the basic Resistor component, and a superconducting option using the custom SuperconLayer. The input for a resistive coil is __Rcoil . Here we can also model the inductance of the coil, set by assigning a value to Lself. (right now the value cannot be set externally, define a new parameter in the extended model and assign it during declaration). Inductor saturation is not considered, and coupling between the coil and external structures may be included as part of the inductance value. Eddy currents are not considered. The joints here are set as a separate Resistor. Their resistance Rjoint may, for now, only be set within the model (but as with Lself, you may make it equal to an externally-accessible parameter in an extended model). Coolant flow # The variable Hflow is the total mass flow rate of cryogenic helium through heat exchangers on magnet coil feeders. The flow rate is proportional to the current rating of the feeder, which is given by __maxcurrent (due to the scaling of cross section with current rating. The constant of proportionality __Feeder_m is taken from [1] for a 50K HTS current feeder (see p85). Outputs # The model outputs are: Variable Description P_amb The heating power dissipated in the air (the loss in the power supply basically) P_cryo The heating power loss at cryogenic temperature (pretty much all losses other than the power supply) P_tot The total electrical power required to run the system Hflow Coolant flow. Parameters # The following are the remaining parameters that this base model needs (reminder that a double underscore __ indicates a parameter that can be modified externally to Modelica): Parameter Description __nTurn Number of turns in one coil. JpTurn Number of joints per turn. __numCoils Number of coils in the system. __maxCurrent Maximum anticipated operating current per turn. __coilLength The length of one coil. Choosing between resistive and superconducting models # The feeder and coil models use \"conditional components\" to select the type of conductor based on boolean parameters isSuperconCoil and isSuperconFeeder . This selection is done during compilation and therefore you cannot select the other option after the model has been compiled. The components and connections of the \"other\" conductor material are completely ignored and simply do not exist in the compiled version of the model. As such, you may be able to see that some connections appear \"doubled-up\" - in order to make sure everything is properly connected when an option is selected. Superconductor scaling # At present, the hysteresis model is simulating flux/length \\(Wb/m\\) in one BSCCO tape with the following characteristics: \\(I_c = 16.85\\:\\mathrm{A}\\) \\(n = 20\\) \\(R_{\\mathrm{normal}} = 1\\times10^8\\:\\Omega\\mathrm{/m}\\) and hysteresis parameterization as given in Superconductor.Data.HTS_EverettParameter . There is a need to scale that to fit a full-size cable. It is assumed that there are n number of tapes all connected in parallel and the value of n is found by dividing the maximum operating current by the product of the critical current of the tape and the safety factor, e.g. n = current / (safety factor * critical current). The voltage drop across each tape is obtained by multiplying the flux/length by the length of the cable (coil or coil system circumference times number of turns). der(flux/length * length) equals voltage. The power loss is calculated for each tape and then summed up for all of them. This is a crude assumption and should not be used past some preliminary investigation stage. At the very least, better data should be used, but current-flux relationship characterizations are rare in literture. References # [1] Tanna, V. L. 'Design and Analysis of the Superconducting Current Feeder System for the International Thermonuclear Experimental Reactor (ITER)', October 2006 Warnings # Translation warnings Building the model may produce a Translation Warning: Conditional component 'resistiveCoil'/superconCoil is used in a non-connect context. This warning can be safely ignored. There is no way to \"fix\" it and it does not affect performance. Revisions # Date Comment Authors 2021-03-11 Documentation created and model updated Alexander Petrov 2020-08-31 Initial model implemented Samuel Stewart, Finlay Christie, Katherine Rochford, Sophie Gribben","title":"Base Magnet"},{"location":"modelica/magnet/basemagnet/#magnetsbasemagnet","text":"A partial model to act as a platform on which specialized magnet systems can be built.","title":"Magnets.BaseMagnet"},{"location":"modelica/magnet/basemagnet/#extended-by","text":"TF_Magnet PF_Magnet","title":"Extended By"},{"location":"modelica/magnet/basemagnet/#information","text":"The following is the base magnet model. From this partial model, the TF and PF magnets are extended, and theoretically any other magnet system could be extended as well. The model does not consider temperature and field variations, and it does not consider any standard coil protection schemes such as FDUs.","title":"Information"},{"location":"modelica/magnet/basemagnet/#input","text":"The input i_in is intended to come in as a predefined signal (see MagnetPower), and a SignalCurrent block is used to translate this signal into a current for our system.","title":"Input"},{"location":"modelica/magnet/basemagnet/#power-supply","text":"Given the required fidelity and detail of the model, we do not have to model the behaviour of an AC-DC converter. In fact, our input signal is already a DC current generated by a comverter somewhere upstream, outside the model. Should the behaviour of an AC-DC converter need to be modelled, this can be done in a separate model. With the above in mind, we have used a ConstantVoltage component to emulate the voltage drop (and thus power consumption) of a power converter. The relevant iinput here is __Vdrop which, multiplied by two, gives a rough estimate. This means our power supply unit does not consider the relationship between output current and voltage drop, and is 'always on'.","title":"Power Supply"},{"location":"modelica/magnet/basemagnet/#feeder","text":"The feeder for this system assumes one of two options - a resistive (default) using the basic Resistor component, and a superconducting option using the custom SuperconLayer. It can be thought of as the description of the busbars and feeders that link the power converter with the coils. However, capacitance and inductance are ignored. The input for a resistive feeder is __Rfeeder .","title":"Feeder"},{"location":"modelica/magnet/basemagnet/#coil","text":"As with the feeder, the user may choose either a resistive (default) using the basic Resistor component, and a superconducting option using the custom SuperconLayer. The input for a resistive coil is __Rcoil . Here we can also model the inductance of the coil, set by assigning a value to Lself. (right now the value cannot be set externally, define a new parameter in the extended model and assign it during declaration). Inductor saturation is not considered, and coupling between the coil and external structures may be included as part of the inductance value. Eddy currents are not considered. The joints here are set as a separate Resistor. Their resistance Rjoint may, for now, only be set within the model (but as with Lself, you may make it equal to an externally-accessible parameter in an extended model).","title":"Coil"},{"location":"modelica/magnet/basemagnet/#coolant-flow","text":"The variable Hflow is the total mass flow rate of cryogenic helium through heat exchangers on magnet coil feeders. The flow rate is proportional to the current rating of the feeder, which is given by __maxcurrent (due to the scaling of cross section with current rating. The constant of proportionality __Feeder_m is taken from [1] for a 50K HTS current feeder (see p85).","title":"Coolant flow"},{"location":"modelica/magnet/basemagnet/#outputs","text":"The model outputs are: Variable Description P_amb The heating power dissipated in the air (the loss in the power supply basically) P_cryo The heating power loss at cryogenic temperature (pretty much all losses other than the power supply) P_tot The total electrical power required to run the system Hflow Coolant flow.","title":"Outputs"},{"location":"modelica/magnet/basemagnet/#parameters","text":"The following are the remaining parameters that this base model needs (reminder that a double underscore __ indicates a parameter that can be modified externally to Modelica): Parameter Description __nTurn Number of turns in one coil. JpTurn Number of joints per turn. __numCoils Number of coils in the system. __maxCurrent Maximum anticipated operating current per turn. __coilLength The length of one coil.","title":"Parameters"},{"location":"modelica/magnet/basemagnet/#choosing-between-resistive-and-superconducting-models","text":"The feeder and coil models use \"conditional components\" to select the type of conductor based on boolean parameters isSuperconCoil and isSuperconFeeder . This selection is done during compilation and therefore you cannot select the other option after the model has been compiled. The components and connections of the \"other\" conductor material are completely ignored and simply do not exist in the compiled version of the model. As such, you may be able to see that some connections appear \"doubled-up\" - in order to make sure everything is properly connected when an option is selected.","title":"Choosing between resistive and superconducting models"},{"location":"modelica/magnet/basemagnet/#superconductor-scaling","text":"At present, the hysteresis model is simulating flux/length \\(Wb/m\\) in one BSCCO tape with the following characteristics: \\(I_c = 16.85\\:\\mathrm{A}\\) \\(n = 20\\) \\(R_{\\mathrm{normal}} = 1\\times10^8\\:\\Omega\\mathrm{/m}\\) and hysteresis parameterization as given in Superconductor.Data.HTS_EverettParameter . There is a need to scale that to fit a full-size cable. It is assumed that there are n number of tapes all connected in parallel and the value of n is found by dividing the maximum operating current by the product of the critical current of the tape and the safety factor, e.g. n = current / (safety factor * critical current). The voltage drop across each tape is obtained by multiplying the flux/length by the length of the cable (coil or coil system circumference times number of turns). der(flux/length * length) equals voltage. The power loss is calculated for each tape and then summed up for all of them. This is a crude assumption and should not be used past some preliminary investigation stage. At the very least, better data should be used, but current-flux relationship characterizations are rare in literture.","title":"Superconductor scaling"},{"location":"modelica/magnet/basemagnet/#references","text":"[1] Tanna, V. L. 'Design and Analysis of the Superconducting Current Feeder System for the International Thermonuclear Experimental Reactor (ITER)', October 2006","title":"References"},{"location":"modelica/magnet/basemagnet/#warnings","text":"Translation warnings Building the model may produce a Translation Warning: Conditional component 'resistiveCoil'/superconCoil is used in a non-connect context. This warning can be safely ignored. There is no way to \"fix\" it and it does not affect performance.","title":"Warnings"},{"location":"modelica/magnet/basemagnet/#revisions","text":"Date Comment Authors 2021-03-11 Documentation created and model updated Alexander Petrov 2020-08-31 Initial model implemented Samuel Stewart, Finlay Christie, Katherine Rochford, Sophie Gribben","title":"Revisions"},{"location":"modelica/magnet/magnetpower/","text":"Magnets.MagnetPower # The 'control' model that brings all coils together. Assumptions # The resistance is assumed to be 100% dissipated in the Joints Eddy Currents are not considered Input is assumed dominant and mutual inductance are included as a nominal constant Saturation of the Inductor is not considered Temperature of the resistor and inductor are assumed to be constant Ground resistance and FDU resistance are not considered 6 PF coils assumed but this is a very tenuous assumption S - Complex Power (is not actually AC complex power but a summation of real power dissipated and stored in the inductors)","title":"Magnet Power"},{"location":"modelica/magnet/magnetpower/#magnetsmagnetpower","text":"The 'control' model that brings all coils together.","title":"Magnets.MagnetPower"},{"location":"modelica/magnet/magnetpower/#assumptions","text":"The resistance is assumed to be 100% dissipated in the Joints Eddy Currents are not considered Input is assumed dominant and mutual inductance are included as a nominal constant Saturation of the Inductor is not considered Temperature of the resistor and inductor are assumed to be constant Ground resistance and FDU resistance are not considered 6 PF coils assumed but this is a very tenuous assumption S - Complex Power (is not actually AC complex power but a summation of real power dissipated and stored in the inductors)","title":"Assumptions"},{"location":"modelica/magnet/mutual_inductor/","text":"Magnets.Superconductor.MutualInductor # Implementation of two basic inductors together with a mutual inductance between them. Information # The model of mutual inductance here is taken in the simplest form in terms of circuit theory: \\(V1 = L_1\\frac{di_1}{dt} + M\\frac{di_2}{dt}\\) \\(V2 = L_2\\frac{di_2}{dt} + M\\frac{di_1}{dt}\\) The upper inductor is taken as '1' and the lower inductor is taken as '2'. Customization is fairly easy to include more than 2 inductors depending on modeling needs. Revisions # 2021 by Alexander Petrov (credit due to the creators of the TwoPort and Transformer classes), initially implemented","title":"Mutual Inductor"},{"location":"modelica/magnet/mutual_inductor/#magnetssuperconductormutualinductor","text":"Implementation of two basic inductors together with a mutual inductance between them.","title":"Magnets.Superconductor.MutualInductor"},{"location":"modelica/magnet/mutual_inductor/#information","text":"The model of mutual inductance here is taken in the simplest form in terms of circuit theory: \\(V1 = L_1\\frac{di_1}{dt} + M\\frac{di_2}{dt}\\) \\(V2 = L_2\\frac{di_2}{dt} + M\\frac{di_1}{dt}\\) The upper inductor is taken as '1' and the lower inductor is taken as '2'. Customization is fairly easy to include more than 2 inductors depending on modeling needs.","title":"Information"},{"location":"modelica/magnet/mutual_inductor/#revisions","text":"2021 by Alexander Petrov (credit due to the creators of the TwoPort and Transformer classes), initially implemented","title":"Revisions"},{"location":"modelica/magnet/pfcoil/","text":"Magnets.PF_Magnet # A specialized magnet model for a Poloidal Field (PF) coil system Extends # BaseMagnet Information # Most notably the superconductor coil is set to true by default. Resistances have been set to very low values. Only one coil per component. Revisions # Date Comment Authors 2021-03-11 Documentation added and model implemented. Alexander Petrov","title":"Poloidal Field Coil"},{"location":"modelica/magnet/pfcoil/#magnetspf_magnet","text":"A specialized magnet model for a Poloidal Field (PF) coil system","title":"Magnets.PF_Magnet"},{"location":"modelica/magnet/pfcoil/#extends","text":"BaseMagnet","title":"Extends"},{"location":"modelica/magnet/pfcoil/#information","text":"Most notably the superconductor coil is set to true by default. Resistances have been set to very low values. Only one coil per component.","title":"Information"},{"location":"modelica/magnet/pfcoil/#revisions","text":"Date Comment Authors 2021-03-11 Documentation added and model implemented. Alexander Petrov","title":"Revisions"},{"location":"modelica/magnet/preisach_everett/","text":"Magnets.Superconductor.Hysteresis.PreisachEverett # Superconductor I-Phi(V) hysteresis based on the Preisach model and Everett function data Information # An I-V model of superconducting hysteresis using the Preisach hysteresis model with an Everett function. The details surrounding the Presiach model implementation in Modelica (for ferromagnetism) can be found in the OpenModelica documentation for Preisach-Everett hysteresis. The majority of this code is an adapted version of GenericHystPreisachEverett that makes it possible to work in an electric circuit using current as an input and magnetic flux as output. The derivative of the magnetic flux is the voltage. The Everett function is specified as a set of parameters through the HTS_EverettParameter data record. Different parameters may be set by either modifying the record file or setting a different file path for the 'mat' parameter on input. NOTE: Take care with solver tolerance and time steps when attempting to model very small fluxes - a tolerance of 1e-10 or 1e-12 offers better results. More information about Preisach and its use for superconductor hysteresis modelling can be found here: M. Sjostrom, B. Dutoit, and J. Duron, 'Equivalent circuit model for superconductors', IEEE Transactions on Applied Superconductivity, vol. 13, no. 2, pp. 1890\u20131893, Jun. 2003, doi: 10.1109/TASC.2003.812941. M. Sjostrom, 'Hysteresis modelling of high temperature superconductors', Infoscience, 2001. http://infoscience.epfl.ch/record/32848 (accessed Jan. 29, 2021). Revisions # by OpenModelica (the authors of GenericHystPreisachEverett, and all the classes this model extends as well as the authors of OnePort, and Ferenc Preisach, without all of whom this superconducting variant of the Presiach-Everett model would not have been possible) Jan 2021 by Alexander Petrov. Modified the model for use in an electrical system.","title":"Hysteresis"},{"location":"modelica/magnet/preisach_everett/#magnetssuperconductorhysteresispreisacheverett","text":"Superconductor I-Phi(V) hysteresis based on the Preisach model and Everett function data","title":"Magnets.Superconductor.Hysteresis.PreisachEverett"},{"location":"modelica/magnet/preisach_everett/#information","text":"An I-V model of superconducting hysteresis using the Preisach hysteresis model with an Everett function. The details surrounding the Presiach model implementation in Modelica (for ferromagnetism) can be found in the OpenModelica documentation for Preisach-Everett hysteresis. The majority of this code is an adapted version of GenericHystPreisachEverett that makes it possible to work in an electric circuit using current as an input and magnetic flux as output. The derivative of the magnetic flux is the voltage. The Everett function is specified as a set of parameters through the HTS_EverettParameter data record. Different parameters may be set by either modifying the record file or setting a different file path for the 'mat' parameter on input. NOTE: Take care with solver tolerance and time steps when attempting to model very small fluxes - a tolerance of 1e-10 or 1e-12 offers better results. More information about Preisach and its use for superconductor hysteresis modelling can be found here: M. Sjostrom, B. Dutoit, and J. Duron, 'Equivalent circuit model for superconductors', IEEE Transactions on Applied Superconductivity, vol. 13, no. 2, pp. 1890\u20131893, Jun. 2003, doi: 10.1109/TASC.2003.812941. M. Sjostrom, 'Hysteresis modelling of high temperature superconductors', Infoscience, 2001. http://infoscience.epfl.ch/record/32848 (accessed Jan. 29, 2021).","title":"Information"},{"location":"modelica/magnet/preisach_everett/#revisions","text":"by OpenModelica (the authors of GenericHystPreisachEverett, and all the classes this model extends as well as the authors of OnePort, and Ferenc Preisach, without all of whom this superconducting variant of the Presiach-Everett model would not have been possible) Jan 2021 by Alexander Petrov. Modified the model for use in an electrical system.","title":"Revisions"},{"location":"modelica/magnet/supercon_layer/","text":"Magnets.Superconductor.SuperconLayer # A model that can simulate a single superconducting tape or strand","title":"Superonducting Layer"},{"location":"modelica/magnet/supercon_layer/#magnetssuperconductorsuperconlayer","text":"A model that can simulate a single superconducting tape or strand","title":"Magnets.Superconductor.SuperconLayer"},{"location":"modelica/magnet/supercon_resistive/","text":"Magnets.Superconductor.SuperconResistive # Resistive model of a superconductor's I-V relationship, employing a macroscopic power law. Information # The model simulates the I-V relationship of a superconductor based on a macroscopic power law (instead of critical current density and electric field, critical current and voltage are used). At about 1.2x Ic and higher this I-V macroscopic characteristic becomes dominant and the hysteresis may be neglected; otherwise the hysteresis is dominant and instead this I-V characteristic may be neglected. Inputs are the critical current, power exponent and normal state resistance. The critical current criterion is set to 1e-4 V/m whch should not normally be changed. Change the length to achieve the desired voltage. Revisions # by OpenModelica (class OnePort) 2020 by Alexander Petrov (credits due to J Rhyner who developed the Power Law model) initially implemented","title":"Power Law Resistance"},{"location":"modelica/magnet/supercon_resistive/#magnetssuperconductorsuperconresistive","text":"Resistive model of a superconductor's I-V relationship, employing a macroscopic power law.","title":"Magnets.Superconductor.SuperconResistive"},{"location":"modelica/magnet/supercon_resistive/#information","text":"The model simulates the I-V relationship of a superconductor based on a macroscopic power law (instead of critical current density and electric field, critical current and voltage are used). At about 1.2x Ic and higher this I-V macroscopic characteristic becomes dominant and the hysteresis may be neglected; otherwise the hysteresis is dominant and instead this I-V characteristic may be neglected. Inputs are the critical current, power exponent and normal state resistance. The critical current criterion is set to 1e-4 V/m whch should not normally be changed. Change the length to achieve the desired voltage.","title":"Information"},{"location":"modelica/magnet/supercon_resistive/#revisions","text":"by OpenModelica (class OnePort) 2020 by Alexander Petrov (credits due to J Rhyner who developed the Power Law model) initially implemented","title":"Revisions"},{"location":"modelica/magnet/tfcoil/","text":"Magnets.TF_Magnet # A specialized magnet model for a Toroidal Field (TF) coil system. Extends # BaseMagnet Information # This model focuses on use for the toroidal field coil. The values for the joint resistances are from latest known experimental results. Revisions # Date Comment Authors 2021-03-11 Documentation added and model implemented. Alexander Petrov","title":"Toroidal Field Coil"},{"location":"modelica/magnet/tfcoil/#magnetstf_magnet","text":"A specialized magnet model for a Toroidal Field (TF) coil system.","title":"Magnets.TF_Magnet"},{"location":"modelica/magnet/tfcoil/#extends","text":"BaseMagnet","title":"Extends"},{"location":"modelica/magnet/tfcoil/#information","text":"This model focuses on use for the toroidal field coil. The values for the joint resistances are from latest known experimental results.","title":"Information"},{"location":"modelica/magnet/tfcoil/#revisions","text":"Date Comment Authors 2021-03-11 Documentation added and model implemented. Alexander Petrov","title":"Revisions"},{"location":"modelica/powergen/equations/","text":"PowerGenEquations.mo # Information # This model calculates the efficiency of power conversion (plasma heat - electrical power) in the system. It's inputs are the primary coolant, secondary coolant, compression ratio, operating pressure and thermal power, and it's output is the electrical power generated. Modelling Methodology # The Power Generation modelling has been based on the excel power generation model created as part of internal UKAEA work. 30 different relevant scenarios were identified according to the following criteria: Different primary coolants Different secondary coolants Different compression ratios or operating pressures (depending on secondary coolant chosen). Each scenario was evaluated to develop an equation relating reactor operating temperature (ie primary fluid reactor outlet temperatures) to total loop efficiency. Total loop efficiency considers the power consumption from 1st, 2nd and 3rd loops (excluding tritium related equipment and any power consumption within the boundaries of reactor).","title":"Power Generation"},{"location":"modelica/powergen/equations/#powergenequationsmo","text":"","title":"PowerGenEquations.mo"},{"location":"modelica/powergen/equations/#information","text":"This model calculates the efficiency of power conversion (plasma heat - electrical power) in the system. It's inputs are the primary coolant, secondary coolant, compression ratio, operating pressure and thermal power, and it's output is the electrical power generated.","title":"Information"},{"location":"modelica/powergen/equations/#modelling-methodology","text":"The Power Generation modelling has been based on the excel power generation model created as part of internal UKAEA work. 30 different relevant scenarios were identified according to the following criteria: Different primary coolants Different secondary coolants Different compression ratios or operating pressures (depending on secondary coolant chosen). Each scenario was evaluated to develop an equation relating reactor operating temperature (ie primary fluid reactor outlet temperatures) to total loop efficiency. Total loop efficiency considers the power consumption from 1st, 2nd and 3rd loops (excluding tritium related equipment and any power consumption within the boundaries of reactor).","title":"Modelling Methodology"},{"location":"modelica/turbopump/pumps/","text":"TurboMolecularPump.mo # Summary # Turbopumps will be used directly to achieve the low pressures required in the torus vacuum vessel. Many turbopumps in parallel are required to achieve the low pressure at the required flow rates. The turbopumps are backed by multiple booster stages and roughing (screw) pumps. The main power considerations are the electrical load required to run the various pumping stages in series. The model takes the thermal power as an input, and outputs the electrical power required to run the pumps. Main Equations # Required flowrate (m 3 / sec) = molar flow per GW (mol / s.GW) * thermal power (GW) * 8.314 (m^3.Pa / K.mol) * T (\u00b0K) / (Pressure (mbar) * 100 (Pa / mbar)) Turbo power (kW) = SinglePump power (W) * 0.001 * Required flowrate / single pump flowrate","title":"Turbopump"},{"location":"modelica/turbopump/pumps/#turbomolecularpumpmo","text":"","title":"TurboMolecularPump.mo"},{"location":"modelica/turbopump/pumps/#summary","text":"Turbopumps will be used directly to achieve the low pressures required in the torus vacuum vessel. Many turbopumps in parallel are required to achieve the low pressure at the required flow rates. The turbopumps are backed by multiple booster stages and roughing (screw) pumps. The main power considerations are the electrical load required to run the various pumping stages in series. The model takes the thermal power as an input, and outputs the electrical power required to run the pumps.","title":"Summary"},{"location":"modelica/turbopump/pumps/#main-equations","text":"Required flowrate (m 3 / sec) = molar flow per GW (mol / s.GW) * thermal power (GW) * 8.314 (m^3.Pa / K.mol) * T (\u00b0K) / (Pressure (mbar) * 100 (Pa / mbar)) Turbo power (kW) = SinglePump power (W) * 0.001 * Required flowrate / single pump flowrate","title":"Main Equations"},{"location":"modelica/wasteheat/wasteheat_package/","text":"WasteHeat.mo # Information # Package containing the waste heat Management system object (WasteHeatSystem) and model for the power load of waste heat management of Magnets, H&CD, Cryo and WaterDetrit (WasteHeatPower). Model Description and Method # The purpose of this model is to extract the waste heat from the air. It does this by taking in waste power from other models and performing a cooling with dehumidification calculation. The settable user input values for this model are given, alongside their default values: Waste power from other models (1000 W) Height of room Length of room Width of room Efficiency of Waste Heat system (0.8) simulation stop time (60 s) Assumptions # Cooling with Dehumidification process Steady flow process mass flow rate of air constant Air behaves and an ideal gas Kinetic energy and Potential energy negligible Heat transfer through floor is negligible If the waste power is under 5000 W, the dehumidification calculation is disregarded. This is due to several reasons. The temperature difference is calculated using the waste power, and at low powers this can be very small. The mass flow rate of the moisture in the air is calculated as a fraction of the mass flow rate of the air, and at these low powers it would dominate the calculation and give a negative overall power.","title":"Waste Package"},{"location":"modelica/wasteheat/wasteheat_package/#wasteheatmo","text":"","title":"WasteHeat.mo"},{"location":"modelica/wasteheat/wasteheat_package/#information","text":"Package containing the waste heat Management system object (WasteHeatSystem) and model for the power load of waste heat management of Magnets, H&CD, Cryo and WaterDetrit (WasteHeatPower).","title":"Information"},{"location":"modelica/wasteheat/wasteheat_package/#model-description-and-method","text":"The purpose of this model is to extract the waste heat from the air. It does this by taking in waste power from other models and performing a cooling with dehumidification calculation. The settable user input values for this model are given, alongside their default values: Waste power from other models (1000 W) Height of room Length of room Width of room Efficiency of Waste Heat system (0.8) simulation stop time (60 s)","title":"Model Description and Method"},{"location":"modelica/wasteheat/wasteheat_package/#assumptions","text":"Cooling with Dehumidification process Steady flow process mass flow rate of air constant Air behaves and an ideal gas Kinetic energy and Potential energy negligible Heat transfer through floor is negligible If the waste power is under 5000 W, the dehumidification calculation is disregarded. This is due to several reasons. The temperature difference is calculated using the waste power, and at low powers this can be very small. The mass flow rate of the moisture in the air is calculated as a fraction of the mass flow rate of the air, and at these low powers it would dominate the calculation and give a negative overall power.","title":"Assumptions"},{"location":"modelica/wasteheat/wasteheat_system/","text":"WasteHeat.WasteHeatSystem # Information # Model of the power loads of the Waste Heat Management (formerly HVAC) system - takes in waste heat from other models and performs cooling with dehumidification calculation. Assumptions # Cooling with Dehumidification process Steady flow process mass flow rate of air constant Air behaves and an ideal gas Kinetic energy and Potential energy negligible Heat transfer through floor is negligible If the waste power is below 5000 W dehumdifying is neglected due to small change in temperature.","title":"Waste System"},{"location":"modelica/wasteheat/wasteheat_system/#wasteheatwasteheatsystem","text":"","title":"WasteHeat.WasteHeatSystem"},{"location":"modelica/wasteheat/wasteheat_system/#information","text":"Model of the power loads of the Waste Heat Management (formerly HVAC) system - takes in waste heat from other models and performs cooling with dehumidification calculation.","title":"Information"},{"location":"modelica/wasteheat/wasteheat_system/#assumptions","text":"Cooling with Dehumidification process Steady flow process mass flow rate of air constant Air behaves and an ideal gas Kinetic energy and Potential energy negligible Heat transfer through floor is negligible If the waste power is below 5000 W dehumdifying is neglected due to small change in temperature.","title":"Assumptions"},{"location":"modelica/waterdetrit/waterdetrit_package/","text":"WaterDetritiation.mo # Information # The input is the thermal power and the output is the electrical power required. Description and Method # There are three types of power load involved. The Thermal Power, the Electrical Power and the Negligeable Power Load. The development of this system is to control the tritium content in the diverging streams to minimize the power usage. This is completed by thermal power being pumped in to the Liquid Phase Catalytic Exchange or LPCE in this diagram. The electrical power loads include the electrical power for electrolysis and the potential electrical load on the compression of gases around the permeator. There are more models to predict the time this process takes but the overall goal will separate the clean water and the tritiated water into separate streams. There are 4 models included in this water detritiation package: Electrolysis Energy Electrolysis Power (kW) = Flowrate (kg/s) * Electrolysis power consumption (kJ / kgH20) Water Heating Heating Power (kW) = Flowrate (kg/s) * (reflux ratio * heat capacity (kJ/kg.\u00b0C ) * (Target T (\u00b0C) - Ambient T (\u00b0C)) + latent heat of vaporisation * vapour fraction) Gas Compression Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) Total Contingency Electrolysis Power + Water heating + compressor work Assumptions # Thermal Power exiting the reactor - 1GW","title":"Water Detritiation"},{"location":"modelica/waterdetrit/waterdetrit_package/#waterdetritiationmo","text":"","title":"WaterDetritiation.mo"},{"location":"modelica/waterdetrit/waterdetrit_package/#information","text":"The input is the thermal power and the output is the electrical power required.","title":"Information"},{"location":"modelica/waterdetrit/waterdetrit_package/#description-and-method","text":"There are three types of power load involved. The Thermal Power, the Electrical Power and the Negligeable Power Load. The development of this system is to control the tritium content in the diverging streams to minimize the power usage. This is completed by thermal power being pumped in to the Liquid Phase Catalytic Exchange or LPCE in this diagram. The electrical power loads include the electrical power for electrolysis and the potential electrical load on the compression of gases around the permeator. There are more models to predict the time this process takes but the overall goal will separate the clean water and the tritiated water into separate streams. There are 4 models included in this water detritiation package: Electrolysis Energy Electrolysis Power (kW) = Flowrate (kg/s) * Electrolysis power consumption (kJ / kgH20) Water Heating Heating Power (kW) = Flowrate (kg/s) * (reflux ratio * heat capacity (kJ/kg.\u00b0C ) * (Target T (\u00b0C) - Ambient T (\u00b0C)) + latent heat of vaporisation * vapour fraction) Gas Compression Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) Total Contingency Electrolysis Power + Water heating + compressor work","title":"Description and Method"},{"location":"modelica/waterdetrit/waterdetrit_package/#assumptions","text":"Thermal Power exiting the reactor - 1GW","title":"Assumptions"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage"}]}