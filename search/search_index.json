{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#power-balance-models","title":"Power Balance Models","text":"<p>Power Balance Models (PBM) is a framework developed by UKAEA for assessment of net power production by different Tokamak fusion reactor designs. The simulations are built around models constructed using Modelica for power generation and consumption systems. The included API allows users to configure and launch simulation runs quickly and easily either via a command line interface (CLI) or through scripts.</p> <p>This site provides information on the models contained within PBM and how to use the framework in your own analysis, as well as guidelines towards contributing to the project.</p> <p>You can download the latest release on the project repository.</p>"},{"location":"#current-development-team","title":"Current Development Team","text":"<ul> <li>Alexander Petrov</li> <li>Jack Acres</li> <li>Kristian Zar\u0119bski</li> <li>Tom Stroud</li> <li>Taiwo Owoeye</li> <li>Vignesh Laksharam</li> <li>Steven Wray</li> <li>Christie Finlay<sup>*-**</sup></li> <li>Timothy Jackson<sup>**</sup></li> </ul>"},{"location":"#previous-development-team-members","title":"Previous Development Team Members","text":"<ul> <li>Marius Cannon</li> <li>Nicholas Brewer</li> <li>Rhys Griffiths</li> <li>Sophie Gribben<sup>*</sup></li> <li>Katherine Rochford<sup>*</sup></li> <li>Samuel Stewart<sup>*</sup></li> </ul> <p>* 2020 summer student</p> <p>** 2021 summer student</p>"},{"location":"API/advanced_api/","title":"Interactive Session","text":"<p>For inspection of outputs, and dynamically setting up and running of simulations it is recommended that the API be launched within an <code>ipython</code> session. This allows the user to create an instance of <code>PowerBalance</code> and modify/inspect parameters on the fly.</p>"},{"location":"API/advanced_api/#installing-ipython","title":"Installing iPython","text":"<p><code>ipython</code> can be installed using <code>pip</code>:</p> <pre><code>pip install ipython\n</code></pre>"},{"location":"API/advanced_api/#example","title":"Example","text":"<pre><code>In [1]: from power_balance.core import PowerBalance\n\nIn [2]:  p = PowerBalance()\nInitialising session, please wait...\n\nIn [3]: p.run_simulation('output_dir')\nstdout            | info    | ... loading \"data\" from \"/home/user/PowerBalanceModels/power_balance/profiles/mat_profile_files/ThermalPowerOut.mat\"\nstdout            | info    | ... loading \"data\" from \"/home/user/PowerBalanceModels/power_balance/profiles/mat_profile_files/currentCS.mat\"\n...\n\nIn [4]: p.get_parameters()\nOut[4]: \n{'Tokamak.Interdependencies.air_gas_power.compFeedGas.compressorWork': 485.8823529411765,\n 'Tokamak.Interdependencies.air_gas_power.compRegenGas.absorbentRequired': 381.9861818181818,\n 'Tokamak.Interdependencies.air_gas_power.compRegenGas.compressorWork': 227.0588235294117,\n ...\n\nIn [5]: p.set_parameter_value('tokamak.interdependencies.magnetpower.magnetpf1.numcoils', 10)\nOut[5]: 10\n\nIn [6]: p.modifiable_parameters()\nOut[6]: \n['tokamak.interdependencies.primarycoolanttype',\n 'tokamak.interdependencies.secondarycoolanttype',\n 'tokamak.interdependencies.ratiotype',\n 'tokamak.interdependencies.systempressure',\n ...\nIn [7]: p.clear_cache()\n</code></pre> <p>Parameter setting</p> <p>All parameters including those that are protected are listed via <code>PowerBalance.get_parameters()</code> for the purposes of inspection. Only modifiable parameters can be updated, these are listed by running <code>PowerBalance.modifiable_parameters()</code>.</p> <p>PyDelica cache</p> <p>On Windows temporary directories are not deleted on log out. PyDelica uses these to perform builds and store the model binaries. It is therefore recommended unless using <code>PowerBalance</code> as a context manager you should run the <code>clear_cache</code> method to wipe these build folders upon completion.</p>"},{"location":"API/api_overview/","title":"Power Balance Models API","text":""},{"location":"API/api_overview/#overview","title":"Overview","text":"<ul> <li>The Application Programming Interface (API) provides commands for accessing features within Power Balance Models (PBM). The core part of the API is the <code>PowerBalance</code> class which holds session properties such as the model list and model parameters.</li> <li> <p>Parameters can be set manually by the user within scripts, are read from input parameter files or default values are used.</p> </li> <li> <p>The interaction with Modelica source files is handled by PyDelica which is itself an API to the OpenModelica Compiler (OMC).</p> </li> <li> <p>When a model run is completed copies of the inputs are stored alongside the output data for reproducibility. graph LR; subgraph Inputs;     subgraph TOML Files;         A[API Config]         B[Parameter Values]         C[Simulation Config]     end     subgraph Profiles;         D[Current Profiles]         E[Heat Profiles]     end     subgraph Models;         G[Modelica Files]     end end subgraph PyDelica;     ZP[PyDelica Input Files]     ZW[C Code]     ZK[Model Binaries]     ZI[XML Input File]     ZP --OMC--&gt; ZI end subgraph Power Balance Models;     G --&gt; ZP --OMC--&gt; ZW --Make--&gt; ZK     G --&gt; H[Models List]     B --&gt; I[Parameters]     DA[Validator]     D --&gt; I     E --&gt; I     C --&gt; DA --&gt; J[Configuration]     A --&gt; DA     H -.Extract.-&gt;I     O[Simulation]     I --&gt; ZI     J --&gt; O     ZI --&gt; O     ZK --&gt; O end  subgraph User Interface;     K[Add Model]     L[Set Parameter]     M[Get Parameter]     VA[View Plots]     K --&gt; ZP     L --&gt; I     I --&gt; M end  subgraph Outputs;     P[Dataframe]     Q[Power Plots]     O --&gt; P     O --&gt; Q     AA[Heat Profiles]     BB[Current Profiles]     I --&gt; AA     I --&gt; BB     R[Parameters]     S[API Config]     T[Simulation Config]     I --&gt; R     J --&gt; S     J --&gt; T end BR[PBMBrowser] Q --&gt; BR VA --&gt; BR </p> </li> </ul>"},{"location":"API/api_overview/#pydelica","title":"PyDelica","text":"<p>PBM uses PyDelica to compile, configure and run a Modelica model. At its base the process consists of five main steps:</p> <ul> <li>Create a PyDelica session and hand it the Modelica files for the models required.</li> <li>The models will firstly be converted into C source files and relevant build files.</li> <li>The model will then be compiled using the created Makefile.</li> <li>As compiled models rely on a created XML file to set initial parameter values, PyDelica allows the user to set these conditions by modifying this XML file directly.</li> <li>Run the binary when a simulation is requested.</li> </ul> Why not OMPython? <p>For those who have researched the topic you will already know that OpenModelica already comes with a Python interface, OMPython. However rather than being a direct API for OpenModelica itself, it acts as an API for OMShell which in turn runs OpenModelica. In order to do this it has to run on a server (i.e. ZMQ session). Whilst writing Unit Tests for Power Balance Models using OMPython it was discovered that this server approach is very taxing on CPU especially when you want to run multiple models in tandem as each would create a new OMC session. </p> <p>When OMC is run in script generation mode an XML file is also created from which the compiled binary reads parameter values and simulation options. As Python is able to edit XML files PyDelica instead updates parameter values directly.</p> <p>Furthermore OMPython does not throw exceptions when the OpenModelica backend fails, instead the errors are largely lost or not even returned meaning any scripts continue to run even after model compilation/run failure.</p>"},{"location":"API/api_overview/#validation","title":"Validation","text":"<p>In the case of the API configuration, simulation configuration and plasma scenario files a validation check is performed on the inputs. These checks are performed using the pydantic Python module which compares the inputs to a defined schema containing rules. Further information these schemas can be found here.</p>"},{"location":"API/cli/","title":"Command Line Interface","text":"<p>Most analysis can be performed using the command line interface (CLI). The commands below are added to your <code>PATH</code> after installation.</p>"},{"location":"API/cli/#powerbalance","title":"powerbalance","text":"<p>Power Balance Models CLI for running models, as well as generating and viewing profiles.</p> <p>Usage:</p> <pre><code>powerbalance [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --version  Show the version and exit.\n  --help     Show this message and exit.\n</code></pre>"},{"location":"API/cli/#generate-profiles","title":"generate-profiles","text":"<p>Generate profiles used as model inputs</p> <p>Usage:</p> <pre><code>powerbalance generate-profiles [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --outdir TEXT  Profile output directory\n  --help         Show this message and exit.\n</code></pre>"},{"location":"API/cli/#install-msl","title":"install-msl","text":"<p>Installs MSL 4.0.0 if not installed</p> <p>Usage:</p> <pre><code>powerbalance install-msl [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"API/cli/#new","title":"new","text":"<p>Create a new project folder with modifiable a parameter set</p> <p>Usage:</p> <pre><code>powerbalance new [OPTIONS] OUTPUT_DIR\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"API/cli/#plugins","title":"plugins","text":"<p>Commands relating to plugins</p> <p>Usage:</p> <pre><code>powerbalance plugins [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"API/cli/#install","title":"install","text":"<p>Installs a plugin from the given directory</p> <p>Usage:</p> <pre><code>powerbalance plugins install [OPTIONS] PLUGIN_DIRECTORY\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"API/cli/#list","title":"list","text":"<p>Lists all available plugins</p> <p>Usage:</p> <pre><code>powerbalance plugins list [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"API/cli/#remove","title":"remove","text":"<p>Remove a plugin by name</p> <p>Usage:</p> <pre><code>powerbalance plugins remove [OPTIONS] PLUGIN_NAME\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"API/cli/#run","title":"run","text":"<p>Launch and run a PBM simulation session</p> <p>Usage:</p> <pre><code>powerbalance run [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --config TEXT             TOML configuration file.\n  --verbose / --no-verbose  Run in Debug Mode\n  --no-browser / --browser  Run without launching result browser  [default:\n                            browser]\n  --outputdir TEXT          Output directory, default is current directory\n  --param-dir TEXT          Location of parameter files\n  --model-dir TEXT          Modelica model file directory\n  --profiles-dir TEXT       Directory containing profiles\n  --from-session TEXT       Run Power Balance using an existing session output\n                            directory\n  --help                    Show this message and exit.\n</code></pre>"},{"location":"API/cli/#view-profile","title":"view-profile","text":"<p>View a profile within a '.mat' file</p> <p>Usage:</p> <pre><code>powerbalance view-profile [OPTIONS] INPUT_MAT_FILE\n</code></pre> <p>Options:</p> <pre><code>  --head INTEGER  display head n rows\n  --tail INTEGER  display tail n rows\n  --help          Show this message and exit.\n</code></pre>"},{"location":"API/cli/#view-results","title":"view-results","text":"<p>Launch browser window from output directory</p> <p>Usage:</p> <pre><code>powerbalance view-results [OPTIONS] OUTPUT_DIR\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"API/configuration/","title":"Global Configuration File","text":"<p>The global config file contains options which are related to the API session as opposed to Modelica configurations. This configuration is validated before the session is started. The contents of the default configuration file are:</p> <pre><code>models = [ \"Tokamak.Interdependencies\" ]                # Default model\nparameters_directory  = \"Default\"                       # Use built in\nsimulation_options_file = \"simulation_options.toml\"     # Opts TOML file\nplasma_scenario_file = \"plasma_scenario.toml\"           # Opts TOML file\nstructural_params_file = \"structural_parameters.toml\"   # Opts TOML file\nprofiles_directory = \"Default\"                          # Use built in\nmodelica_file_directory = \"Default\"                     # Use built in\n</code></pre> <p>Options with the value <code>\"Default\"</code> must still be specified, this option specifying to instead use the internal configurations. The default values can be viewed after a run within the output folder.</p> Option Type Description Required Comments <code>models</code> <code>List[str]</code> List of models to run Make sure these are models and not model components. <code>parameters_directory</code> <code>str</code> Directory containing parameter files Defaults to internal parameter directory <code>simulation_options_file</code> <code>str</code> Identifier for the simulation options file in the parameters directory This is the relative filename not a path <code>profiles_directory</code> <code>str</code> Directory containing the <code>.mat</code> profiles Defaults to internal profile directory, is generated if it does not yet exist <code>modelica_file_directory</code> <code>str</code> Directory containing modelica model files Defaults to internal model directory <code>sweep_mode</code> <code>str</code> Type of sweep to perform (if sweep specified) See below <code>structural_params_file</code> <code>str</code> Identifier for the structural parameters file in the parameters directory Overrides the default structured parameters with the values provided (see here) <code>plugins</code> Specify which plugins to run and the order in which to run them. By default all installed are used."},{"location":"API/configuration/#plugin-specification","title":"Plugin Specification","text":"<p>The key <code>plugins</code> is not included by default. All plugins will be run in the order given by <code>os.listdir</code>. You can specify which plugins to use and in what order by adding this key along with a list:</p> <p><pre><code>plugins = ['My Plugin']\n</code></pre> this name should match that of the plugin itself, but is case insensitive.</p> <p>A full list of available plugins is given by running:</p> <pre><code>powerbalance plugins\n</code></pre> <p>Order is Important!</p> <p>Plugins can change the input arguments for Power Balance as such the order in which they are executed is important. Given plugins <code>A</code>, <code>B</code> and <code>C</code> which all setup arguments: <code>A -&gt; B -&gt; C</code> would not be equivalent to a run order of <code>B -&gt; C -&gt; A</code> etc. Therefore usage of <code>plugins</code> is recommended where a run will use more than one plugin.</p>"},{"location":"API/configuration/#creating-a-parameter-sweep","title":"Creating a parameter sweep","text":"<p>To perform a parameter sweep you will need to add an additional <code>sweep</code> section to your configuration file and specify the values to run with.</p> <pre><code>[sweep]\nTokamak.Interdependencies.MagnetPower.MagnetPF4.RFeeder = [1E-8, 1E-7, 5E-8]\n</code></pre> <p>Parameter addresses</p> <p>Parameters must be specified by their complete address within the Modelica model.</p> <p>There are two sweep modes:</p> <ul> <li><code>set</code>: run in sequence (i.e. for run <code>i</code> use the <code>i</code>th element of all sweep parameter lists).</li> <li><code>combination</code>: run all possible combinations of all sweep parameters.</li> </ul>"},{"location":"API/data_out/","title":"Analysing Outputs","text":""},{"location":"API/data_out/#output-file-structure","title":"Output File Structure","text":"<p>After running Power Balance Models (PBM) a new directory should be created either in the current working directory, or the manually specified location. This directory will have a name in the format <code>pbm_results_&lt;time-stamp&gt;</code> and contain a set of subdirectories with files pertaining to the run itself (presence of the <code>html</code> and directory may depend on whether the plot browser is set to open after the run):</p> <pre><code>pbm_results_2021_06_18_12_59_22/\n\u251c\u2500\u2500 configs\n\u2502   \u2514\u2500\u2500 configuration.toml\n\u251c\u2500\u2500 data\n\u2502   \u2514\u2500\u2500 session_data.h5\n\u251c\u2500\u2500 parameters\n\u2502   \u251c\u2500\u2500 simulation_options.toml\n\u2502   \u2514\u2500\u2500 tokamak_interdependencies.toml\n\u251c\u2500\u2500 plots\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_air_gas_power.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_blanketdetritpower.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_coolantdetritpower.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_cryogenicpower.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_hcdsystem.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_magnetpower.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_netpowerconsumption.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_netpowergeneration.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_powergenerated.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_total_turbopump_power.jpg\n\u2502   \u251c\u2500\u2500 Tokamak_Interdependencies_wasteheatpower.jpg\n\u2502   \u2514\u2500\u2500 Tokamak_Interdependencies_water_detrit_power.jpg\n\u2514\u2500\u2500 profiles\n    \u251c\u2500\u2500 NBI_Heat.mat\n    \u251c\u2500\u2500 RF_Heat.mat\n    \u251c\u2500\u2500 ThermalPowerOut.mat\n    \u251c\u2500\u2500 currentCS.mat\n    \u251c\u2500\u2500 currentPF1.mat\n    \u251c\u2500\u2500 currentPF2.mat\n    \u251c\u2500\u2500 currentPF3.mat\n    \u251c\u2500\u2500 currentPF4.mat\n    \u251c\u2500\u2500 currentPF5.mat\n    \u251c\u2500\u2500 currentPF6.mat\n    \u2514\u2500\u2500 currentTF.mat\n</code></pre> Directory Description <code>configs</code> Contains a saved copy of the API session configuration file used during the run. <code>data</code> Contains a single file containing all data frames from all models run during the session. <code>html</code> Contains the generated HTML file for viewing power data plots within the browser. <code>parameters</code> Contains all parameter start value configuration files and the simulation options file. <code>plots</code> Contains JPG versions of the plots generated during a run. <code>profiles</code> Contains copies of the <code>.mat</code> profiles used as inputs for the model run."},{"location":"API/development/","title":"Development","text":"<p>Contributions to the Power Balance Models (PBM) project can be broken down into model development and API development. Both should be performed under git version control with changes being committed to a personal development branch, and any conflicts being resolved before merging into the main <code>develop</code> branch takes place. </p> <p>It is recommended you develop and test PBM using UV, instructions on how to install and run the project this way are given here.</p> <p>The terms \"backend\" and \"frontend\" are used to refer to the OpenModelica and Python code respectively.</p>"},{"location":"API/development/#model-development","title":"Model Development","text":"<p>When updating revisions of the model components make sure to add the revision to the documentation page for that component, e.g. for <code>Tokamak.Magnets.TF_Magnet</code> here.</p> <p>Model Merge Conflicts</p> <p>Special care should be taken to ensure any conflicts raised during a git merge are addressed. If such conflicts appear within the Modelica files it is strongly recommended that you either use the script view in OMEdit or another editor to address them.</p>"},{"location":"API/development/#api-development","title":"API Development","text":"<p>Where possible any new features should either be placed within a relevant existing location, or should form a new subdirectory in the python module. For example, any additions relating to compatibility with external data sources could be added to a new location <code>power_balance/external_data</code>.</p> <p>A unit/regression test for each new feature should be added to the <code>tests</code> directory (See Testing).</p> <p>The code should be documented sensibly. As a tip, imagine you are returning to the code after a year, what comments would help you remember how to use your code?</p> <p>Try to use typing in your functions. Not only does this improve readability, but if you run <code>uv run mypy</code> it will tell you if the object type a function is returning matches your expectation. An example typed function would be:</p> <pre><code>from typing import Dict\nfrom string import ascii_lowercase\n\ndef my_useless_function(a: int, b: int) -&gt; str:\n    temp_var_ : Dict[int, str] = {}\n\n    for i in range(a, b):\n        temp_var_[i] = ascii_lowercase[i % 3]\n\n    return ''.join(temp_var_.values())\n</code></pre> <p>more information on <code>mypy</code> can be found here.</p>"},{"location":"API/development/#testing","title":"Testing","text":""},{"location":"API/development/#unit-and-regression-testing","title":"Unit and Regression Testing","text":"<p>Testing is essential to ensuring the outputs from PBM are accurate and the code behaves as expected. Tests are performed using <code>pytest</code> and are usually of the following form:</p> <ul> <li>If the code addition is being added to an existing feature create a test in the tests script for that feature else create a new one within <code>tests</code>.</li> <li>Test files must start with the prefix <code>test_</code>.</li> <li>Use <code>pytest.mark</code> to help categorise tests.</li> <li>Use <code>pytest.fixture</code> for test setup (e.g. creating an instance of a class that should be shared between all tests)</li> </ul> <p>As an example say we have a new feature \"User Greetings\", a test script would be created <code>tests/unit_tests/test_user_greeting.py</code>:</p> <pre><code>import pytest\n\nfrom power_balance.greetings import Greeter\n\n\n# Create an instance of the fictional Greeting class\n# to be shared between all tests within this module (script)\n@pytest.fixture(scope=\"module\")\ndef greeter_instance():\n    return Greeter(name=\"John\")\n\n\n# Add the test to the category \"greetings\"\n# pass fixture as argument\n@pytest.mark.greetings\ndef test_greeter_message(greeter_instance):\n    # Check that we get what we expect\n    assert greeter_instance.message() == \"Hello John!\"\n</code></pre> <p>We also need to add the new category to the <code>pytest.ini</code> file: <pre><code>[pytest]\nmarkers=\n    greetings: tests related to the greetings submodule\n</code></pre></p> Unit or Regression? <p>Unit tests and regression tests are very different things. A unit test is a test which asserts that the code behaves as we expect (usually as the literature/science dictates). For example:</p> <pre><code>def adder(a, b):\n    return a + b\n\n# We know 2+3 should equal 5 so we check our code\n# behaves as such\ndef test_adder():\n    assert adder(2, 3) == 5\n</code></pre> <p>However a regression test checks that the code behaves the same now as it did previously, in the case of PBM the folder <code>baseline</code> contains data collected during a run which is known to be correct. Using the previous example:</p> <pre><code>def adder(a, b):\n    return a + b\n\ndef test_adder():\n    with open('previous_run_data.npy', 'rb') as f:\n        assert adder(2, 3) == np.load(f)\n</code></pre>"},{"location":"API/development/#benchmark-testing","title":"Benchmark Testing","text":"<p>Performance of PBM is measured using airspeed-velocity (ASV) which allows the user to write tests for measuring properties such as the timing and memory usage during execution. These tests are grouped in \"suites\" which are classes containing similar category tests. For PBM these can be found in the <code>benchmarks</code> directory, the Python scripts containing tests which are grouped as either timing or memory tests. ASV identifies the type of test from the prefix, <code>time_</code> for timing tests, <code>mem_</code> for memory tests.</p> <p>For timing a function a simple test would be: <pre><code>from my_module import a_very_long_process\n\n# As these are timing tests we shall group them in the same class/suite\nclass TimingSuite:\n    def setup(self):\n        # we can put any setup for the tests in here\n        pass\n\n    def time_long_process(self):\n        a_very_long_process()\n</code></pre> See the ASV documentation for more details.</p>"},{"location":"API/development/#semantic-versioning","title":"Semantic Versioning","text":"<p>PBM where possible keeps to a strict following of the semantic versioning standard outlined here. It is strongly recommended you read these standards before creating a new release. The most important points being:</p> <ul> <li>\"Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\"</li> <li>The importance of numbering <code>X.Y.Z</code> representing MAJOR, MINOR, PATCH. A good illustration of the difference between these is shown here.</li> </ul> <p>Pre-Release</p> <p>Note versions prior to <code>v1.0.0</code> may follow a looser standard.</p>"},{"location":"API/development/#using-git-prehooks","title":"Using Git Prehooks","text":"<p>It is strongly recommended that the pre-commit git hooks be installed to catch any issues with code quality, file size and merge conflict remnants. In order to install the git hooks within the repository install <code>pre-commit</code> via pip (this is already present if using <code>uv</code> to develop), and run: <pre><code>pre-commit install\n</code></pre> to update your local <code>.git/hooks/pre-commit</code> file. Whenever you create a commit if there are any issues with it these will be flagged before you are allowed to continue.</p>"},{"location":"API/getting_started/","title":"Getting Started","text":"<p>Power Balance Models (PBM) can be run via a command line interface (CLI) or by constructing scripts to access the API. Whichever case is chosen runs can be customised by the user as much (or as little) as required.</p>"},{"location":"API/getting_started/#example-run","title":"Example run","text":"<p>As there are existing configurations within the API you can run PBM 'out the box' using the available CLI command:</p> <pre><code>powerbalance run\n</code></pre> <p>after the run is completed a new timestamped directory will be produced containing not only the results but a preserved copy of the configuration set to achieve them. This is useful for recreating runs.</p> <p>In addition your chosen browser should be launched to show a webpage displaying the power data plots as dynamic widgets which can be interacted with.</p>"},{"location":"API/getting_started/#viewing-existing-plots","title":"Viewing existing plots","text":"<p>A new plot browser window can be opened on any results directory using the <code>view-results</code> command:</p> <pre><code>powerbalance view-results &lt;pbm_results_dir&gt;\n</code></pre>"},{"location":"API/getting_started/#viewing-the-data","title":"Viewing the data","text":"<p>Data is written to a HDF5 file, with each model's output being written to the file as a single dataframe the key for which is the model name in lower case with any <code>.</code> being replaced with <code>_</code>.</p> <p>The recommended method for accessing the data is using the Pandas module. In the case of the <code>Tokamak.Interdependencies</code> model:</p> <p><pre><code>import pandas as pd\nimport glob\nimport os\nimport argparse\n\n# Create a parser so we can select the result directory\n# we which to view from the command line\nparser = argparse.ArgumentParser()\nparser.add_argument('result_dir')\nargs = parser.parse_args()\n\n# Use glob to lazily find the HDF5 file\nhdf5_file = glob.glob(\n    os.path.join(args.result_dir, 'data', '*.hdf5')\n)[0]\n\n# Accessing the dataframe using the key within the file\ndata_frame = pd.read_hdf(hdf5_file, key='tokamak_interdependencies')\n\nprint(data_frame)\n</code></pre> data frames are very powerful objects, you can apply cuts to them and perform operations on subsets, see the Pandas documentation for details.</p>"},{"location":"API/getting_started/#creating-your-own-scripts","title":"Creating your own scripts","text":"<p>The main class used to initialise and run a simulation via the OpenModelica backend within PBM is the <code>PowerBalance</code> class. It is recommended that the class be used via a context manager to ensure that model build directories are removed upon completion (this is done automatically when using the CLI).</p> <pre><code>from power_balance.core import PowerBalance\n\n# Initialise the PBM class fetching parameters\n# and models from the default locations\n# Use context manager to ensure junk collection\nwith PowerBalance() as pbm_instance:\n\n    # Run the simulation with the configuration\n    pbm_instance.run_simulation()\n\n    # Open the plots in the browser window\n    pbm_instance.launch_browser()\n</code></pre>"},{"location":"API/installation/","title":"Installation","text":""},{"location":"API/installation/#supported-environments","title":"Supported Environments","text":"<p>Power Balance Models (PBM) has been confirmed to work on:</p> <ul> <li>Ubuntu 22.04 - 25.04</li> <li>Windows 10*</li> </ul> <p>* using Python for Windows and CMD.</p> <p>The PBM is not tested on Mac systems. The software requires:</p> <ul> <li>Python <code>&gt;= 3.10</code>. Recommended version is <code>3.13.3</code>, which you can download from the bottom of the page here);</li> <li>OpenModelica <code>&gt;= 1.25</code>. Recommended version is <code>1.25.0</code>, which you can download from here (Windows) or here (Unix) (instructions in https://www.openmodelica.org/download/download-linux). Installation on Mac (not stable) can be found here;</li> </ul> <p>It is recommended you run the software from within a virtual environment system such as PyEnv or the built-in <code>venv</code> module, this ensures there is no interference with your system python installation. Alternatively you can install it under the current user.</p>"},{"location":"API/installation/#installation-for-unix-and-windows","title":"Installation for UNIX and Windows","text":"<p>Downloads are available here. You can install the package using <code>pip</code> on the wheels file:</p> <pre><code>pip install power_balance-&lt;version&gt;-py3-none-any.whl\n</code></pre> <p>To install this package you will firstly need to install OpenModelica to your system. The module works by either finding the location of an <code>omc</code> installation (in the case of UNIX) or using the environment variable <code>%OPENMODELICAHOME%</code> in the case of Windows.</p>"},{"location":"API/installation/#installing-openmodelica-compiler","title":"Installing OpenModelica Compiler","text":"<p>For Windows users will need to install the complete OpenModelica application using the dedicated installer found on the project website.</p> <p>Linux users only require <code>omc</code> and the Modelica Standard Library, see here.</p> <p>Installation on Mac is not tested and not supported by the Power Balance team, primarily because of the difficulty associated with installing OpenModelica on Mac.</p> <p>Updating PowerBalance Installation</p> <p>Note, if updating your version of <code>powerbalance</code>, it is strongly recommended that you re-generate the model profiles in case changes have been made which affect them: <pre><code>powerbalance generate-profiles\n</code></pre></p> <p>Modelica Standard Library version</p> <p>The Power Balance Models API is not compatible with Modelica Standard Library <code>&lt;4.0.0</code>. Significant changes have been implemented in these versions. Latest known working environment is OpenModelica <code>1.25.0</code> with MSL <code>4.0.0</code>.</p>"},{"location":"API/installation/#testing","title":"Testing","text":"<p>You can verify your install is working correctly by either running the default configuration using the <code>powerbalance</code> command, or by running the included tests using <code>pytest</code>:</p> <pre><code>pytest -s tests/\n</code></pre>"},{"location":"API/parameters/","title":"Parameter Values","text":""},{"location":"API/parameters/#model-parameters","title":"Model Parameters","text":"<p>Initial mutable Modelica model parameter values are specified in TOML files with a file existing for each model executed. These files are placed together in a parameter directory. The naming convention of these files should follow that of: the model name in lower case where <code>.</code> is replaced with <code>_</code>. For example for the model <code>Tokamak.Interdependencies</code> the relevant parameter file is named <code>tokamak_interdependencies.toml</code>. In TOML files hierarchy is specified via headers <code>[...]</code>. </p> <p>Example</p> <p>The parameter <code>Tokamak.Interdependencies.hcdsystem.NINI1.__beamEnergy</code> would be found in the file <code>tokamak_interdependencies.toml</code> and be modified as:</p> <pre><code>[hcdsystem.NINI1]\nbeamEnergy = 1\n</code></pre> <p>Editable values</p> <p>Only parameters with the prefix <code>__</code> can be modified within PBM as such this prefix is omitted from the parameter TOML file specification. If a non-modifiable parameter is specified in a parameter configuration file it will be ignored.</p> <p>In the case of the default parameters the internal file <code>parameters/tokamak_interdependencies.toml</code> contains:</p> <pre><code>PrimaryCoolantType = \"CO2_NC\"  # Can be CO2_C, CO2_NC, He_C, He_NC, H2O, FLiBe, LiPb\nSecondaryCoolantType = \"H2O\"   # Can be CO2, H2O\nRatioType = \"1.5\"              # Can be 1.5, 2, 2.5\nSystemPressure = \"90\"          # Can be 50, 90, 200\nVacuumType = true              # True or false\nThermalPower = 1000            # Default value 1 GW\n# ========================== HCD SYSTEM ================================ #\n[hcdsystem]\nRFEfficiency = 0.4\n\n[hcdsystem.negativeIonNeutralInjector]\nbeamEnergy = 1\nefficiencyNeutralization = 0.58\nNBIThermalPowerMaxMW = 109\n\n# ======================= CRYOGENIC POWER ============================== #\n[cryogenicpower]\ncryoFlow_HydrogenFreezing = 3.5\ncryoTemp_TF = 20\ncryoTemp_PF = 4\nPFcrMW = 0.0007\n\n[cryogenicpower.CD]\nFBCol_2 = 0.0003902222222222223\nFBCol_3 = 0.0001944444444444444\nInputFlowRateCol_1 = 0.0002737777777777778\nInputFlowRateCol_2 = 0.0002755555555555556\nOutputStreamRateCol_1 = 8.638888888888889e-05\nOutputStreamRateCol_2 = 0.0001803333333333333\nOutputStreamRateCol_3 = 5.555555555555556e-05\nOutputStreamRateCol_4 = 0.0001411944444444444\n\n# ========================== MAGNET POWER ============================== #\n[magnetpower.magnetPF1]\nnumCoils = 1\nVdrop = 1.45\nRfeeder = 3.7e-9\nnTurn = 200.0\nmaxCurrent = 50e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nL = 0.02\n\n[magnetpower.magnetPF2]\nnumCoils = 1\nVdrop = 1.45\nRfeeder = 3.7e-9\nnTurn = 200.0\nmaxCurrent = 50e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nL = 0.02\n\n[magnetpower.magnetPF3]\nnumCoils = 1\nVdrop = 1.45\nRfeeder = 3.7e-9\nnTurn = 200.0\nmaxCurrent = 50e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nL = 0.02\n\n[magnetpower.magnetPF4]\nnumCoils = 1\nVdrop = 1.45\nRfeeder = 3.7e-9\nnTurn = 200.0\nmaxCurrent = 50e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nL = 0.02\n\n[magnetpower.magnetPF5]\nnumCoils = 1\nVdrop = 1.45\nRfeeder = 3.7e-9\nnTurn = 200.0\nmaxCurrent = 50e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nL = 0.02\n\n[magnetpower.magnetPF6]\nnumCoils = 1\nVdrop = 1.45\nRfeeder = 3.7e-9\nnTurn = 200.0\nmaxCurrent = 50e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nL = 0.02\n\n[magnetpower.magnetTF]\nnumCoils = 12\nVdrop = 1.45\nRfeeder = 1.9e-7\nnTurn = 5.0\nmaxCurrent = 60e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nmagEnergy = 2.139e9\nRtot = 4.253e-7\nRoleg = 1.948e-8\n\n# ========================== POWER GENERATION ============================== #\n[powergenerated]\npowergenOutletTemp = 500\n</code></pre> <p>Examining TOML Files</p> <p>TOML files can be loaded into Python as a dictionary using the <code>toml</code> module: <pre><code>import toml\nimport os\n\n# If parameters located at ./parameters/parameters.toml\nparams_path = os.path.join(os.getcwd(), 'parameters', 'parameters.toml')\n\n# Load the TOML file into a dictionary\nparams_dict = toml.load(open(params_path))\n\n# Retrieve parameter 'model.component.var' from dictionary\nprint(params_dict['model']['component']['var'])\n</code></pre></p>"},{"location":"API/parameters/#model-expansion","title":"Model Expansion","text":"<p>The \"Magnets\" component of Power Balance can be expanded to include additional PF magnets within the model. By default the model is run with the defined 6 PF magnet configuration, in order to define additional magnets extra statements can be added to the parameters file, e.g. including:</p> <p><pre><code>[magnetpower.magnetPF7]\nnumCoils = 1\nVdrop = 1.45\nRfeeder = 3.7e-9\nnTurn = 200.0\nmaxCurrent = 50e3\ncoilLength = 40\nFeeder_Qk = 0.198\nFeeder_m = 0.069\nL = 0.02\ncombiTimeTable = 2\n</code></pre> will create one additional magnet. The optional parameter <code>combiTimeTable</code> is not a Modelica parameter in this case, but rather an additional variable used to select which existing <code>combiTimeTable</code> instance to use for creating the magnet instance. In this case we are using PF2 as the template.</p> <p>Note also you can provide as many or as little parameters as you like to add a new magnet definition, the minimum being one (we recommend setting at least <code>combiTimeTable</code> in this case). As the number of magnets is deduced from the maximum PF stated within the parameters file to have for example 20 magnets, you need only explicitly define the 20th (i.e. <code>magnetpower.magnetPF20</code>).</p>"},{"location":"API/parameters/#structural-parameters","title":"Structural Parameters","text":"<p>Structural parameters for the Modelica models are not mutable and can only be changed by altering the code itself. As such changes to these are handled independent of the main model parameters.</p> <p>In order to make alterations you need to provide the <code>structural_params_file</code> key within your configuration file. By default the file <code>power_balance/parameters/structural_parameters.toml</code> is read. If no key is provided then the substitutions are not made and the original unmodified model code is used.</p> <p>The default substitution file contains the following: <pre><code># ========================== MAGNETS =================================== #\n[Magnets]\nisMagnetTFSuperconCoil = false\nisMagnetTFSuperconFeeder = false\n\nisMagnetPF1SuperconCoil = false\nisMagnetPF1SuperconFeeder = false\n\nisMagnetPF2SuperconCoil = false\nisMagnetPF2SuperconFeeder = false\n\nisMagnetPF3SuperconCoil = false\nisMagnetPF3SuperconFeeder = false\n\nisMagnetPF4SuperconCoil = false\nisMagnetPF4SuperconFeeder = false\n\nisMagnetPF5SuperconCoil = false\nisMagnetPF5SuperconFeeder = false\n\nisMagnetPF6SuperconCoil = false\nisMagnetPF6SuperconFeeder = false\n\n[CryogenicPlant]\nFOM4K = 30 # Figure of merit for the cryoplant at 4 K\nFOM20K = 30 # Figure of merit for the cryoplant at 20 K\nFOM80K = 30 # Figure of merit for the cryoplant at 80 K\n\n# ========================== Tokamak ====================================== #\n[Tokamak]\nPrimaryCoolantType = \"CO2_NC\" # Can be CO2_C, CO2_NC, He_C, He_NC, H2O, FLiBe, LiPb\nSecondaryCoolantType = \"H2O\" # Can be CO2, H2O\nRatioType = \"1.5\" # Can be 1.5, 2, 2.5\nSystemPressure = \"90\" # Can be 50, 90, 200\n\n# ========================== PowerGenCaseByCase========================== #\n[PowerGenEquations]\npowergenOutletTemp = 500 # temperature related to the exchange of heat between the tokamak and the power generation system (Celsius)\n</code></pre></p> <p>Structural Parameter Substitution</p> <p>Such substitutions can cause code compilation failures if not performed correctly, therefore caution should be taken when using configurations different to the defaults.</p>"},{"location":"API/plasma/","title":"Plasma Scenario","text":"<p>The Power Balance Model may take in a plasma scenario. This scenario is used for the generation of input profiles, such as the plasma heating and magnet currents. The values of each stage must be in ascending order and smaller than the end of the simulation at <code>stopTime</code>.</p> Name Description Default value (s) <code>plasma_ramp_up_start</code> The end of the premagnetization stage, and when the plasma current begins to be ramped up 10 <code>plasma_flat_top_start</code> The plasma current is at its highest, and flat-top operation begins 20 <code>plasma_flat_top_end</code> Flat-top ends, and the plasma current starts to be ramped down 40 <code>plasma_ramp_up_end</code> The plasma current is now 0 A, end of plasma. Demagnetizaiton begins 50"},{"location":"API/plugins/","title":"Plugins","text":"<p>Power Balance Models (PBM) supports extensions or \"plugins\" which act as wrappers preparing parameters and arguments before execution of the core API. These plugins may add additional commands to the CLI, or create the requirement input files to initialise a run.</p>"},{"location":"API/plugins/#managing-plugins","title":"Managing Plugins","text":"<p>Plugin are installed by running:</p> <pre><code>powerbalance plugins install &lt;plugin-directory&gt;\n</code></pre> <p>and removed using the command:</p> <pre><code>powerbalance plugins remove &lt;plugin-name&gt;\n</code></pre> <p>you can view all currently installed plugins by running:</p> <pre><code>powerbalance plugins list\n</code></pre> <p>which will display the plugin name (used to remove plugins), and the path of the plugin relative to the <code>power_balance/plugins</code> internal directory.</p>"},{"location":"API/plugins/#plugin-development","title":"Plugin Development","text":"<p>Plugins are placed in the <code>power_balance/plugins</code> folder in order to be recognised by the central API, this process is automated by the <code>powerbalance plugins install</code> command when it is run on the plugin root directory. The command will search for the metadata file, <code>plugin.toml</code>, the location of which is taken to be the root of the plugin structure, and then create a new directory using the name of the plugin, as defined within the metadata file (e.g. if the key <code>name</code> in the <code>plugin.toml</code> file is \"My Project\", the plugin would be installed to <code>power_balance/plugins/my_project</code>). All files within the root location and descending directories are copied during the installation.</p> <p>The plugin root directory must be importable, containing a <code>__init__.py</code> file:</p> <pre><code>.\n\u251c\u2500\u2500 commands.py\n\u251c\u2500\u2500 plugin_functions.py\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 plugin.toml\n\u251c\u2500\u2500 my_plugin_tab_template.jinja\n\u2514\u2500\u2500 tests\n</code></pre> <p>Verify your plugin is recognised by running <code>powerbalance plugins</code> to list those available. For configuration options see the relevant section here.</p>"},{"location":"API/plugins/#the-plugintoml-file","title":"The <code>plugin.toml</code> File","text":"<p>Plugins are defined within a TOML file which is placed in the root directory for that plugin. An example file may look like the following:</p> <pre><code>name = \"My Plugin\"\ncommands = [\n    \"commands:convert_data\"\n]\n\npre_run_script = \"plugin_setup:prepare_args\"\n\n[options.run.select_myplugin_mode]\nparam_decls = [\"--myplugin-mode\"]\nhelp = \"Run mode for My Plugin\"\n\n[options.run.verbose]\nparam_decls = [\"--verbose/--not-verbose\"]\nhelp = \"Run in higher verbosity\"\n\n[options.run.myplugin_outfile]\nparam_decls = [\"--myplugin-out\", \"-b\", \"mpout\"]\nhelp = \"Output name for my plugin\"\n</code></pre> Key Description <code>name</code> Name of the plugin. <code>commands</code> List of additional <code>click</code> commmands to attach to the CLI (see below) <code>pre_run_script</code> Script to run before <code>pbm_main</code>, the PBM main function call. <code>options</code> A dictionary of additional options to append to the main <code>powerbalance</code> subcommands, currently only modifications to <code>run</code> is supported."},{"location":"API/plugins/#appending-commands","title":"Appending Commands","text":"<p>To append additional commands to the <code>powerbalance</code> command group you must provide the path to the commands as a list the format <code>module_path:command_function</code>.</p> <p>In the example above the commands are defined in a file <code>power_balance/plugins/my_plugin/commands.py</code>:</p> <p><pre><code>import click\nimport os\n\nfrom .plugin_commands import demo_func\n\n@click.command()\n@click.argument(\"input_file\")\n@click.option(\n    \"--format\",\n    \"-f\",\n    \"fmt\",\n    default=\"toml\",\n    help=\"Output file format: yaml, pickle, json, toml\",\n)\n@click.option(\n    \"--output-dir\", \"-o\", default=os.getcwd(), help=\"Output directory\"\n)\ndef convert_data(fmt: str, output_dir: str) -&gt; None:\n    demo_func(fmt, output_dir)\n</code></pre> the <code>plugin.toml</code> statement: <pre><code>commands = [\n    \"commands:convert_data\"\n]\n</code></pre> then pointing to this click command.</p>"},{"location":"API/plugins/#appending-options","title":"Appending Options","text":"<p>Further options can be added to the <code>powerbalance run</code> command, under the <code>options.run</code> key. These are defined with the same arguments given to <code>click.option</code>, where <code>param_decls</code> defines the flags and variable name for an option:</p> <pre><code>[options.run.myplugin_outfile]\nparam_decls = [\"--myplugin-out\", \"-b\", \"mpout\"]\nhelp = \"Output name for my plugin\"\n</code></pre>"},{"location":"API/plugins/#modifying-parameters-before-setup","title":"Modifying Parameters Before Setup","text":"<p>If your plugin prepares parameters for a PBM run you will want to modify the inputs given during <code>powerbalance run</code> to use those prepared instead. The key <code>pre_run_script</code> can be given the path of a function.</p> <p>This function must take a dictionary as an argument, this dictionary being the arguments given by the user to the CLI and thus the <code>cli.session:pbm_main</code> function. Your function should then update/add to this dictionary, and hence modify the inputs as required.</p> <p>Argument Modification Clashes</p> <p>Be very careful when modifying inputs, remember if running a simulation with more than one plugin each of these will modify the arguments. This may mean your plugin is not receiving the inputs you expect.</p>"},{"location":"API/plugins/#displaying-plugin-outputs","title":"Displaying Plugin Outputs","text":"<p>Plugins can themselves have displays, these are shown as additional tabs within the PBM browser. Displays are created as additional HTML content held within a Jinja template file. To get the correct expected name for your plugin template file consider loading your <code>plugin.toml</code> file into a variable to ensure the same name is used:</p> <p><code>plugins/my_plugin/__init__.py</code></p> <pre><code>import toml\nimport path\n\nPLUGIN_METADATA = toml.load(\n    os.path.join(os.path.dirname(__file__), \"plugin.toml\")\n)\n</code></pre> <p><code>plugins/my_plugin/results.py</code></p> <pre><code>...\n\n_display_file = get_plugin_display_filename(PLUGIN_METADATA[\"name\"])\n\nwith open(_display_file, 'w') as out_html:\n    out_html.write(plugin_html_str)\n\n...\n</code></pre> <p>If your display requires extra HTML files make sure they have a name unique to the plugin and copy them to the correct location using the <code>PLUGIN_DISPLAY_DIR</code> variable:</p> <pre><code>import shutil\nfrom power_balance.plugins import get_plugin_display_filename, PLUGIN_DISPLAY_DIR\n\n...\n\nmy_plugin_extra_html = \"my_plugin_extras.html\"\ncomponent_file = os.path.join(\n    PLUGIN_DISPLAY_DIR,\n    my_plugin_extra_html\n)\nshutil.copy(my_plugin_extra_html, component_file)\n\n...\n</code></pre>"},{"location":"API/result_output/","title":"Data Output","text":"<p>Results of power generation and consumption modelling are saved to a dataframe object for each model executed. These data frames are stored to a Hierarchical Data Format 5 (HDF5) file which has the advantage of allowing for metadata to be saved alongside numerical values.</p> <p>The data frames can be easily retrieved using the Python module <code>pandas</code>, and provide a quick and easy way to perform analysis allowing the analyser to apply cuts to extract subsets they are interested in. This data format can also be loaded into other languages including R.</p> <p>Each dataframe is stored under a key matching its lower case name with <code>.</code> replaced by <code>_</code>, e.g. <code>Tokamak.Interdependencies</code> \\(\\rightarrow\\) <code>tokamak_interdependencies</code>.</p> iPython <p>The Python module <code>ipython</code> provides an interactive Python session which has more features than the conventional Python prompt including better command history preservation. It is recommended for quickly checking a HDF5 output on the fly.</p> Example: Plotting Cryogenic Power Consumption in the last 20 seconds <p>As a case study, let us say we are only interested in the power consumption of the Cryogenic system (\\(P_{cryo}\\)) at \\(40 \\lt t \\leq 60\\)s.</p> <p><pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport os\n\nfrom typing import Tuple\n\ndef plot_pcryo(data_frame: pd.DataFrame, time_interval: Tuple[int, int]) -&gt; None:\n    \"\"\"Plot Cryogenic power consumption within a time interval\n\n    Parameters\n    ----------\n    data_frame: pandas.DataFrame\n        dataframe to plot\n    time_interval: Tuple[int, int]\n        time range as tuple\n    \"\"\"\n    # Apply cut to dataframe, could apply in one step but lets\n    # do it in two for tidyness. Here we apply a cut to the 'time' variable\n    _sub_df = data_frame[ data_frame['time'] &gt; time_interval[0] ] # t1 &lt; t\n    _sub_df = _sub_df[ _sub_df['time'] &lt;= time_interval[1] ]      # t1 &lt; t &lt;= t2\n\n    # Now we can just directly specify which columns we want to plot X-Y\n    plt.plot( _sub_df['time'], _sub_df['cryogenicpower'] )\n    plt.xlabel('Time/s')\n    plt.ylabel('$P_{cryo}/W$')\n    plt.title('Cryogenic Power Consumption')\n    plt.show()\n\nif __name__ in \"__main__\":\n    # System path to output HDF5 file\n    _file_path = 'pbm_results_2021_03_24_10_07_30/data/session_data.h5'\n\n    # Key for model in file\n    _df_key = 'tokamak_interdependencies'\n\n    # Read the dataframe from the given file\n    _data_frame = pd.read_hdf( _file_path, key=_df_key )\n\n    plot_pcryo( _data_frame, (40, 60) )\n</code></pre> </p> HDF5 browser <p>There are many applications and utilities that let you browse HDF5 files, some of these include:</p> <ul> <li><code>hdf5dump</code>: a CLI tool which is part of HDF5 tools.</li> <li>HDFCompass: GUI based browser. </li> </ul>"},{"location":"API/setup_overview/","title":"Configuring a Run","text":"<p>Properties for a Power Balance Models (PBM) are set via configuration files which are in the TOML format. These are parsed as inputs and used to specify model selection and parameter values. </p> TOML files <p>TOML files can be commented! Do take advantage of this when writing your PBM configs for future reference by yourself or others. For more information on how to write TOML files see the documentation site.</p> <p>Configuration priority</p> <p>If an option is specified within the configuration file AND on the command line interface, the latter is prioritised.</p>"},{"location":"API/simulation_opts/","title":"Simulation Options","text":"<p>Simulation options are those found within Modelica itself and determine the time interval, solver choice etc. The options are written in a TOML file placed in the same directory as parameter options. The name of this file should be specified within the API configuration file via the <code>simulation_options_file</code> key. This configuration is validated before the session is run.</p> <p>The default file <code>parameters/simulation_options.toml</code> contained within the PBM module has the contents:</p> <pre><code>startTime = 0\nstopTime = 60\nstepSize = 0.01\ntolerance = 1e-012\nsolver = \"dassl\"\n</code></pre> <p>these options being defined as:</p> Option Description <code>startTime</code> Simulation data record start time in seconds <code>stopTime</code> Simulation data record stop time in seconds <code>stepSize</code> Frequency of data collection <code>tolerance</code> Tolerance of the solver <code>solver</code> Choice of solver <p>Case sensitivity</p> <p>These options are case sensitive, make sure to correctly specify the keys above.</p>"},{"location":"API/simulation_opts/#solver-types","title":"Solver Types","text":"<p>Recognised solver types:</p> <ul> <li><code>dassl</code></li> <li><code>ida</code></li> <li><code>cvode</code></li> <li><code>impeuler</code></li> <li><code>trapezoid</code></li> <li><code>imprungekutta</code></li> <li><code>euler</code></li> <li><code>heun</code></li> <li><code>rungekutta</code></li> <li><code>rungekuttaSsc</code></li> <li><code>irksco</code></li> <li><code>symSolver</code></li> <li><code>symSolverSsc</code></li> <li><code>qss</code></li> </ul>"},{"location":"API/troubleshooting/","title":"Troubleshooting","text":""},{"location":"API/troubleshooting/#numpy-dependency","title":"Numpy dependency","text":"<p>You may encounter issues with <code>numpy</code> as a dependency, this can usually fixed by installing it manually beforehand: <pre><code>pip install numpy\n</code></pre> if you are using UV make sure to run this command within the virtual environment: <pre><code>uv pip install numpy\n</code></pre></p>"},{"location":"API/troubleshooting/#pytables-build","title":"PyTables build","text":"<p>Releases of PyTables for the latest version of Python are often not yet available. When an existing build is not downloadable <code>pip</code> will attempt to build the module locally. If required libraries are unavailable this build will likely fail and prevent installation. To fix this you should find a <code>pytables</code> wheels file appropriate to your system and Python installation here. Install this file by running: <pre><code>pip install &lt;path-to-wheels-file&gt;\n</code></pre> or if using UV: <pre><code>uv pip install &lt;path-to-wheels-file&gt;\n</code></pre></p>"},{"location":"API/troubleshooting/#command-uv-is-not-recognised","title":"Command <code>uv</code> is not recognised","text":"<p>If you are using UV and the command <code>uv</code> is not recognised after installation make sure the location of your UV installation is added to the PATH environment variable. To find your local installation run: <pre><code>python -m uv run which uv\n</code></pre> and note the location given during the initialisation.</p> <p>For example in the case of the prefix <code>C:\\Users\\&lt;user&gt;\\AppData\\Local\\</code> on Windows, UV was found in <code>C:\\Users\\&lt;user&gt;\\AppData\\Local\\Packages\\PythonSoftwareFoundation.&lt;python_version_string&gt;\\LocalCache\\local-packages\\Python&lt;version-num&gt;\\Scripts</code> and this location is added to the PATH variable as described here or temporarily by running: <pre><code>set \"PATH=%PATH%;&lt;location-of-uv.exe&gt;\"\n</code></pre></p>"},{"location":"API/troubleshooting/#command-powerbalance-is-not-recognised","title":"Command <code>powerbalance</code> is not recognised","text":"<p>If the command <code>powerbalance</code> is not recognised an alternative method for running Power Balance Models is to run the Python script: <pre><code>python &lt;path-to-clone-repo&gt;/power_balance/cli/__init__.py\n</code></pre></p>"},{"location":"API/uv/","title":"UV","text":""},{"location":"API/uv/#using-uv","title":"Using UV","text":"<p>The easiest method for developing PBM is to use the tool <code>uv</code> which combines handling of python dependencies, virtual environment, deployment and versioning.</p>"},{"location":"API/uv/#installing-pbm-with-uv","title":"Installing PBM with uv","text":"<p>uv can be installed using <code>pip</code>:</p> <p><pre><code>pip install --user uv\n</code></pre> you can now install the development version of PBM by running:</p> <p><pre><code>uv venv\n</code></pre> within the repository directory. This will create a virtual environment containing all Python modules required to run the project as defined within the <code>pyproject.toml</code> file.</p> <p>Any changes made within the repository will be picked up by <code>uv</code> whenever the code is run.</p>"},{"location":"API/uv/#running-pbm-with-uv","title":"Running PBM with uv","text":"<p>Run the <code>powerbalance</code> command from within the virtual environment by executing:</p> <pre><code>uv run powerbalance\n</code></pre>"},{"location":"API/uv/#troubleshooting","title":"Troubleshooting","text":""},{"location":"API/uv/#troubleshooting_1","title":"Troubleshooting","text":"<ul> <li>If you encounter issues with <code>numpy</code> as a dependency, this can usually fixed by installing it manually beforehand: <pre><code>uv pip install numpy\n</code></pre></li> <li>Another problem encountered on Windows systems is with the installation of PyTables, the error usually states that HDF5 libraries could not be located and is due to there being no built wheels in the PyPi database for the user's Python version and system architecture (when this is the case Python attempts to build the module itself). A working solution is to download the relevant <code>pytables</code> wheels for Windows from here, then install them with pip: <pre><code>uv pip install &lt;path-to-wheels-file&gt;\n</code></pre></li> <li> <p>If you are using uv and the command <code>uv</code> is not recognised after it has been installed, make sure the location of your uv installation is added to PATH, to find the installation try running <pre><code>python -m uv run which uv\n</code></pre> and noting the address given during the initialisation. For example for the case of a prefix of <code>C:\\Users\\&lt;user&gt;\\AppData\\Local\\</code>, uv was found in <code>C:\\Users\\&lt;user&gt;\\AppData\\Local\\Packages\\PythonSoftwareFoundation.&lt;python_version_string&gt;\\LocalCache\\local-packages\\Python&lt;version-num&gt;\\Scripts</code>. This location is then added to the PATH variable as described here or temporarily</p> <p>In the case of Windows: <pre><code>set \"PATH=%PATH%;&lt;location-of-uv.exe&gt;\"\n</code></pre> for Linux/macOS: <pre><code>export PATH=&lt;location-of-uv&gt;:$PATH\n</code></pre></p> </li> <li> <p>If the command <code>powerbalance</code> is not available after install, you can also run the program via Python as normal: <pre><code>uv run python &lt;path-to-cloned-repo&gt;/power_balance/cli/__init__.py\n</code></pre></p> </li> </ul>"},{"location":"API/validation/","title":"Validation of Inputs","text":"<p>Validation of inputs is performed using pydantic and is based on model representations of the different configuration files, these models being classes within the source code. The attributes for these classes coincide with the keys for the relevant dictionary to be tested, in the case of Power Balance Models these are dictionaries read from TOML files.</p> <p>The current schemas are loose but demonstrate the process for possible tightening of constraints in future.</p>"},{"location":"API/validation/#api-configuration-validation","title":"API Configuration Validation","text":"<p>The global configuration or API configuration input is validated with the following rules:</p> Key Rule Required <code>models</code> Must be of type <code>List[str]</code> and contain models defined within the specified models directory.* <code>parameters_directory</code> Must be a filename, not a path. <code>simulation_options_file</code> Must be a filename, not a path.. <code>plasma_scenario_file</code> Must be a filename, not a path. <code>structural_params_file</code> Must be a filename, not a path. <code>profiles_directory</code> Must be the path to an existing directory. <code>parameters_directory</code> Must be the path to an existing directory. <code>modelica_file_directory</code> Must be the path to an existing directory. <code>sweep</code> Must be of type <code>Dict[str, List[T]]</code>. Where all items in list are the same type. <code>sweep_mode</code> Must be one of <code>set</code> or <code>combinations</code>. <p>* This rule does not apply if <code>add_model</code> is used within the API to add a model after the configuration.</p>"},{"location":"API/validation/#simulation-options-validation","title":"Simulation Options Validation","text":"<p>The Modelica simulation options configuration is validated with the following rules:</p> Key Rule Required <code>stopTime</code> Must be of type <code>int</code> and be above 1. <code>startTime</code> Must be of type <code>int</code> and be positive. <code>stepSize</code> Must be of type <code>int</code> or <code>float</code>, and be positive. <code>solver</code> Must be either of type <code>string</code> and recognised <code>tolerance</code> Must be of type <code>float</code> and positive. <p>A check is also applied to ensure that the <code>startTime</code> is before the <code>stopTime</code>, and that the <code>stepSize</code> is less than the <code>stopTime</code>.</p>"},{"location":"API/validation/#plasma-scenario-validation","title":"Plasma Scenario Validation","text":"<p>The plasma scenario configuration is validated with the following rules:</p> Key Rule Required <code>plasma_ramp_up_start</code> Must be a positive integer. <code>plasma_flat_top_start</code> Must be a positive integer. <code>plasma_flat_top_end</code> Must be a positive integer. <code>plasma_ramp_down_end</code> Must be a positive integer. <p>A check is also applied to ensure that the above are in the given order of increasing magnitude.</p>"},{"location":"modelica/airgasdetrit/airgasdetrit_package/","title":"AirGasDetrit.mo","text":""},{"location":"modelica/airgasdetrit/airgasdetrit_package/#information","title":"Information","text":"<p>The input is the thermal power, and the output is the electrical power required.</p>"},{"location":"modelica/airgasdetrit/airgasdetrit_package/#description-and-method","title":"Description and Method","text":"<p>The Air gas detrit package includes the Recombination and post dryer sections.</p> <p>There are 5 models included in the airgas detritiation package:</p> <ul> <li>Low and High Temperature Heating<ul> <li>Heating load (kW) = Flowrate (kg/s) * Average heat capacity (kJ/kg.\u00b0C ) * (Required second stage temperature (\u00b0C) - Ambient temperature (\u00b0C))</li> </ul> </li> <li>Compression of feed gas<ul> <li>Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s)</li> </ul> </li> <li>Regen heating<ul> <li>Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - ambient air regen temperature) * turnaround time (hour) / 3600</li> </ul> </li> <li>Compression of regen gas<ul> <li>Compressor energy (kW) = compressor work (kJ/kg) * air flowrate (kg/s)</li> </ul> </li> <li>Total Contingency factor<ul> <li>Electrolysis Power + Water heating + compressor work</li> </ul> </li> </ul>"},{"location":"modelica/airgasdetrit/airgasdetrit_package/#assumptions","title":"Assumptions","text":"<ul> <li>Thermal Power exiting the reactor - 1 GW</li> <li>Worst case assumptions<ul> <li>Regen heating - Upstream knock out pot operating temperature - 40\u00b0C </li> <li>Regen heating - Pressure of air from KOP - 3 bara</li> <li>Comp regen gas - 'Mol sieve bed 1 turnaround operational time (from regen to saturation during operation) - 1 hr. This assumption is based off operational experience</li> </ul> </li> </ul>"},{"location":"modelica/blanketdetrit/power/","title":"BlanketDetrit.mo","text":""},{"location":"modelica/blanketdetrit/power/#information","title":"Information","text":"<p>Applies to both <code>Power_NonCarrier</code> and <code>Power_CarrierBreeder</code>. The input is the thermal power, and the output is electrical power required.</p>"},{"location":"modelica/blanketdetrit/power/#description","title":"Description","text":"<p>Removal of tritium from helium (or any inert) can be performed either via recombination and water absorption or via getter material usage.  Getter technology was used in this instance as this is more appropriate for smaller gas flows and high concentrations. The power implication of a getter or a recomb + dryer technology is not expected to be very different. Getter technology considers the concept of selectively absorbing tritium onto a getter type sorbent. These can function in a wide window from 200-700\u00b0C according to ST 707 brochures and the DEMO CPS study. </p> <p>The getter material will need to be regenerated to remove the tritium from the sorbents. This will be done be adding heat to the getter material, effectively creating a Temperature Swing Ad/Absorbent. A very small purge may be used during regen in the event the tritium content is to be diluted due to permeation concerns, however this is slightly counter intuitive as a high concentration of tritium is prefered from a purification and tritium refining perspective. </p> <p>Separated into the following models with these major equations for the molten Salt/liquid Coolant:</p> <ul> <li>Tritium breeding rate<ul> <li>tritium Breeding Rate (mol/sec) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio</li> </ul> </li> <li>He Stream calc</li> <li>Loss of heat</li> <li>He gas compression<ul> <li>Compressor energy (kW) = compressor work (kJ/kg) * coolant flowrate (kg/s)</li> </ul> </li> <li>Electrical heating cost<ul> <li>Using the highest bed volume, either capacity limited or contact time limited<ul> <li>Capacity limited - Bed volume = T flowrate (g/s) * 3600 / 1000 * turnaround time (hours) / saturation capacity (%) / Density (kg/m<sup>3</sup>)</li> </ul> </li> <li>Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara))</li> <li>Constant Heating of ceramic energy (kW) = Mass of getter in one vessel (kg) * getter heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - initial regen temperature) / (Turnaround time (hr)) * 3600)</li> </ul> </li> <li>Pure HeGas Compression<ul> <li>Compressor energy (kW) = compressor work (kJ/kg) * coolant flowrate (kg/s)</li> </ul> </li> <li>Total contingency factor<ul> <li>Gas compression calc (added 20 bar) + regen heating + regen compression + hydrogen from water electrolysis</li> </ul> </li> </ul>"},{"location":"modelica/coolantdetrit/coolantdetrit_package/","title":"CoolantDetrit.mo","text":""},{"location":"modelica/coolantdetrit/coolantdetrit_package/#information","title":"Information","text":"<p>As per usual, the model takes in the thermal power and outputs the electrical power required.</p>"},{"location":"modelica/coolantdetrit/coolantdetrit_package/#description-and-method","title":"Description and Method","text":"<p>There are 3 packages within the coolant detritiation package:</p> <ul> <li>Water Coolant<ul> <li>Coolant purpose is a non carrier and the most basic of these packages;</li> </ul> </li> <li>Gases Coolant<ul> <li>This is has 2 coolant options with two coolant purposes so separated into the following packages:<ul> <li>CO2 coolant. Non-Carrier purpose;</li> <li>Helium coolant. Non-Carrier purpose;</li> <li>CO2 coolant. Carrier purpose;</li> <li>Helium coolant. Carrier Purpose;</li> </ul> </li> </ul> </li> <li>Molten Salt or Liquid<ul> <li>This is divided into two packages:<ul> <li>FliBe coolant. Breeder purpose;</li> <li>LiPb coolant. Breeder purpose;</li> </ul> </li> </ul> </li> </ul>"},{"location":"modelica/coolantdetrit/gascoolant/","title":"CoolantDetrit.GasCoolants","text":""},{"location":"modelica/coolantdetrit/gascoolant/#information","title":"Information","text":"<p>Similarly to the water detrit strategy - only some of the gas coolant will be detritiated (although other strategies may be possible). The detitiation of the full gas coolant stream is impractical due potentially high energy costs but is also mainly to due large absorbent beds which would be difficult to regenerate and recover tritium from. </p> <p>The largest power consumer is from the resulting pressure drop loss across the two detrit process steps - oxidation and water knock out. The additional pressure drop in turn will result in additonal compression power. Typical airgas detrit technology using oxidation and post dryers will be used. The associated heat typically used for oxidiser reactors can be ignored as the stream will already be hot, however the post dryer energy requirements will need to be considered for the split stream. </p> <p>Separated into the following models with these major equations for the Gases Coolant: - Tritium breeding rate     - tritium Breeding Rate (mol/s) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio - Permeation calculation     - Permeation Rate (mol/s) = Permeability * (Area (m<sup>2</sup>) / Length (m)) * (sqrt(Blanket side partial pressure (Pa) - sqrt(coolant side partial pressure (Pa)) - Water split stream calculation     - Split steam (kg/s) = permeation rate (mol/s) / (Assumed trit removal efficiency (%) * max trit concentration permissible (mol/kg)) - Gas Compression     - Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s) - Regen Heating     - Using the highest bed volume, either capacity limited or contact time limited         - Capacity limited - Bed volume = Water flowrate (g/s) * 3600 / 1000 * turnaround time (hours) / saturation capacity (%) / Density (kg/m<sup>3</sup>)         - Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara))     - Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - Ambient air regen temperature) / (Turnaround time (hr)) * 3600)     - Water evolving energy (kW) = Water rate (kg/hour) * Water latent heat of vaporisation (kJ/kg) * 1 / 3600     - Total regen heating rate = constant heating of ceramic + water evolving rate - Compression of Regen gas     - Using the highest bed volume, either capacity limited or contact time limited         - Capacity limited          - Contact time limited - Bed volume = Min contact time * gas flow (NM3/hour) / 3600 * T(Gas)(\u00b0K) / 273 * 1(bara) / pgas (bara))     - Constant Heating of ceramic energy (kW) = Mass of ceramic in one vessel (kg) * mol sieve heat capacity (kJ/kg.\u00b0C) * (final air regen temperature - Ambient air regen temperature) / (Turnaround time (hr)) * 3600)     - Water evolving energy (kW) = Water rate (kg/hour) * Water latent heat of vaporisation (kJ/kg) * 1 / 3600     - Total regen heating rate = constant heating of ceramic + water evolving rate     - Compressor energy (kW) = compressor work (kJ/kg) * airflow rate (kg/s) - Electrolysis Energy     - Electrolysis Power (kW) =Amount of H2 required (mol/s) * Electrolysis power consumption (kJ/molH2) - Total contingency factor     - Gas compression calc (added 20 bar) + regen heating + regen compression + hydrogen from water electrolysis</p>"},{"location":"modelica/coolantdetrit/gascoolant/#assumptions","title":"Assumptions","text":"<ul> <li>Regen Heating - Upstream knock out pot operating temperature - 40 degrees C. Worst case assumption</li> <li>Regen Heating -  Pressure of coolant from KOP - 90 bara. Worst case assumption</li> </ul>"},{"location":"modelica/coolantdetrit/watercoolant/","title":"CoolantDetrit.WaterCoolant","text":""},{"location":"modelica/coolantdetrit/watercoolant/#description-and-method","title":"Description and Method","text":"<p>It is impractial for all of the water in the loop to be continuously detriated (from a power perspective) hence only a side stream shall be detritated. But what is the portion of the sidestream to be treated? </p> <p>Seperated into the following models with these major equations:</p> <ul> <li>Tritium breeding rate<ul> <li>tritium Breeding Rate (mol/s) = Trit reactor input per 1GW thermal (mol/s) * Thermal Power * burn rate (%) * Tritium breeding ratio</li> </ul> </li> <li>Permeation calculation<ul> <li>Permeation Rate (mol/s) = Permeability * (Area (m<sup>2</sup>) / Length (m)) * (sqrt(Blanket side partial pressure (Pa) - sqrt(coolant side partial pressure (Pa))</li> </ul> </li> <li>Water split stream calculation<ul> <li>Split steam (kg/s) = permeation rate (mol/s) / (Assumed trit removal efficiency (%) * max trit concentration permissible (mol/kg))</li> </ul> </li> <li>Electrolysis Energy<ul> <li>Electrolysis Power (kW) = tritiated water feed * (5/2) (kg/s) * electrolysis power</li> </ul> </li> <li>Water heating calculation<ul> <li>Heating Power (kW) = Flowrate (kg/s) * (reflux ratio * heat capacity (kJ / kg.\u00b0C) * (Target T (\u00b0C) - Ambient T (\u00b0C)) + latent heat of vapourisation * vapour fraction)</li> </ul> </li> <li>Gas Compression<ul> <li>Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s)</li> </ul> </li> <li>Total contingency factor<ul> <li>Electrolysis Power + Water Heating + Compressor work</li> </ul> </li> </ul>"},{"location":"modelica/coolantdetrit/watercoolant/#assumptions","title":"Assumptions","text":"<ul> <li>Water Split stream calculation - Assumed tritium removal effciency of 95%</li> </ul>"},{"location":"modelica/cryo/convertflowelec/","title":"CryogenicPlant.CryogenicPower.convertFlowElec","text":""},{"location":"modelica/cryo/convertflowelec/#information","title":"Information","text":"<p>Calculates the electrical power required to cool a Helium coolant loop on the cold side of a heat exchanger. The power is calculated using the exergy change associated with bringing helium down to a given temperature tempC from room temperature. This is the method used by [1] (see p82). The logarithmic equation is a fit to values generated by coolprop.</p>"},{"location":"modelica/cryo/convertflowelec/#references","title":"References","text":"<p>[1] Tanna, V. L. 'Design and Analysis of the Superconducting Current Feeder System for the International Thermonuclear Experimental Reactor (ITER)', October 2006</p>"},{"location":"modelica/cryo/cryogenic_power/","title":"CryogenicPlant.CryogenicPower","text":""},{"location":"modelica/cryo/cryogenic_power/#information","title":"Information","text":"<p>Model of the power loads of the cryogenic plant.</p>"},{"location":"modelica/cryo/cryogenic_power/#model-description-and-method","title":"Model Description and Method","text":"<p>This model calulates the electrical power load of a Tokamak Cryogenic Plant by summing the power required for the following cryogenic loads:</p> <ul> <li>Hydrogen Freezing</li> <li>Cryodistillation</li> <li>Magnet Radiative</li> <li>Magnet Dissipative</li> <li>Cryopumping</li> </ul> <p>These cryogenic loads are modelled at a high level by taking their operating temperatures and calculating an individual carnot efficiency. This carnot efficiency is applied to the load's cooling power to find the ideal electrical power consumption. The practical power consumption is then found by applying an individual figure of merit to the ideal consumption. </p> <p>For the each of the cryogenic loads, the required cooling power is either assumed steady state, or in some cases, calculated using a more deatiled model. This is further explained below:</p> <ul> <li>Hydrogen Freezing - Assumed Steady-State 3.5g/s (copied from pellet Injection flow rate for JT60SA www.jt60sa.org/pdfs/cdr/10-3.5_Cryogenic_System.pdf)</li> <li>Cryodistillation - Modelled using net-flow-rates between columns and gas constants applied to Steady State Flow Equation</li> <li>Magnet Radiative - Modelled using 4th order polyfit to neutronic simulation data, with known parameters; PF heatload and neutronic shielding thickness </li> <li>Magnet Dissipative - Assumed Steady State 3MW</li> <li>Cryopumping - Assumed Seady State 100kW</li> </ul>"},{"location":"modelica/cryo/cryogenic_power/#assumptions","title":"Assumptions","text":"<p>General:</p> <ul> <li>Each model uses a different cold temperature this assumes the ability to provide He2 at different pressures and the cost of this flexibility is not explicitly considered</li> <li>The system efficiency is taken as a block FOM(Figure of Merit) efficiency, but where this number comes from is not considered</li> <li>The transportation, pumping, and storage losses are not considered</li> <li>The use of byproducts such as enriched Hydrogen or waste heat is not considered</li> <li>Some product areas have static cooling power values as phase 2 modelling has not been attempted</li> <li>Room temperature is assumed to be 298K across the models</li> </ul> <p>Magnet Cooling:</p> <ul> <li>2 coolants are assumed to be used at potentially different temperatures</li> <li>Radiative/Neutronic heat is assumed to be 100 percent dissipated in the outer coolant sink</li> <li>Dissipative/Resistive heat is assumed to be 100 percent dissipated in the inner coolant sink</li> <li>The equation for neutronic heat loads on the Central Solonoid coil is a 4th order polynomial fit to data from Tokamak (1GW-DI1) neutronics analysis over the range 10-60cm</li> <li>The static value for the PF coils is similarly taken from  Tokamak (1GW-DI1) neutronics analysis</li> <li>TF coil cooling for radiative heat is not considered</li> <li>Resistive heat values are to be taken from the Magnet System Power consumption models</li> </ul> <p>Cryodistillation:</p> <ul> <li>ITER-like configuration considered [] hence the naming conventions for the various columns</li> <li>Ambient power used to reboil Liquid Hydrogen</li> <li>Heat Exchangers Loss-less</li> <li>Specific Heat of Gaseous Hydrogen, Specifc Heat of Liquid Hydrogen are assumed to be for Parahydrogen at 1 atm and 20.27 K</li> <li>Latent Heat of Evaporation is assumed to be for Parahydrogen at 1 atm and 20.27 K</li> <li>Temperature of Evaporation is assumed to be for Parahydrogen at 1 atm</li> <li>Pressure assumed constant for input cooling and super cooling of reflux</li> <li>Most default values are taken from ITER paper</li> <li>Values unknown for the mass flow rates of the Feedback stream from Column 3 to Column 1 and the output stream from Column 3,</li> <li>Decay heat of Tritium not considered</li> <li>Pressure drops in columns are not considered </li> <li>Hence pumping requirements not considered </li> <li>Comprehensive model diagram</li> </ul>"},{"location":"modelica/cryo/turbopump_cryo/","title":"CryogenicPlant.TurboPumpCryogenics","text":""},{"location":"modelica/cryo/turbopump_cryo/#information","title":"Information","text":"<p>A model to simulate a cryopump operation</p>"},{"location":"modelica/cryo/turbopump_cryo/#cryo-pump-calculations","title":"Cryo-pump calculations","text":"<p>Using the ITER cryopumps which can run the operation at a minimum pressure of 2.5x10-3 mbar (....\\pumps\\Maintenance\\PBS31 - Vacuum Vessel and Neutral Beam Pumping Systems (May'20 Draft).docx)</p>"},{"location":"modelica/cryo/turbopump_cryo/#assumptions","title":"Assumptions","text":"<ul> <li>ITER combines ScHe, He at 80 K and 120 K He to operate the pumping and the regeneration cycles</li> <li>The cryo pump(s) operate at 20 K to pump out the SPR vaccum vessel</li> <li>The cryo pump(s) are regernated at 120 K. No electrical power consumption for cooling down to 120 K has been added</li> <li>The flow rate is 99% of the injected D2 and T2, the other flows are neglected. D2 = 0.02049 mol/s and T2 = 0.02049.</li> </ul>"},{"location":"modelica/hcd/hcd_system/","title":"HCDSystemPkg.HCDSystem","text":""},{"location":"modelica/hcd/hcd_system/#information","title":"Information","text":"<p>Model of the power consumption of a Heading and Current Drive System, taking in the thermal power supplied to the plasma and calculating the electrical power required using wall plug efficiencies.</p>"},{"location":"modelica/hcd/hcd_system/#model-description-and-method","title":"Model Description and Method","text":"<p>This model calculates the total electrical power consumption over time, for a Tokamak external Heating and Current Drive system consisting of RF and NBI systems.</p>"},{"location":"modelica/hcd/hcd_system/#inputs","title":"Inputs","text":"<ul> <li>RF thermal power supplied to the plasma, profile over time</li> <li>NBI thermal power supplied to the plasma, profile over time</li> <li>Wall-Plug efficiency (electrical - thermal) of RF, defualt 0.4</li> <li>NBI and RF consumptions are then summed to find the total electrical consumption of the external Heating and Current Drive system.</li> </ul>"},{"location":"modelica/hcd/hcd_system/#assumptions","title":"Assumptions","text":"<ul> <li>Tokamak will use similar technology to ITERs neutral beam system:<ul> <li>Approximately 50 MW beam output power requirement. [1]</li> <li>Negative ion injection.</li> <li>Uses a powered ion dump.</li> <li>20-30% W.P Efficiency. [1]</li> </ul> </li> <li>Tokamak will use similar technology to ITERs RF systems:<ul> <li>Approximately 40 MW RF output power (20 MW ICRH + 20 MW ECRH) requirement. [2]</li> <li>1 MW Gyrotrons.</li> <li>30-40% W.P Efficiency. [3]</li> </ul> </li> <li>Assumes only one type of RF technology used, as only one RF efficiency parameter.</li> <li>Assuming a pulse length of 60 seconds, no continuous run.</li> <li>Assuming thermal power contained within the plasma has ramp up and steady state period.</li> <li>Assuming that Heating and Current Drive Systems (RF and NBI) are responsible for all thermal power contained within the plasma</li> <li>Assuming that RF system has a fixed Wall-Plug efficiency which describes the entire conversion from electrical power taken from the grid to thermal power in the plasma.</li> <li>For NBI, assuming Negative Ion type as efficiencies are very poor for positive ion at beam energy above 150 keV</li> </ul> <p>[1] \"Technology developments for a beam source of an NNBI system for DEMO,\" Fusion Engineering and Design, Vols. 136, Part A, no. November, pp. 340-344, 2018.</p> <p>[2] P. Brans, \"Ion cyclotron heating: How to pump 20 MW of power into 1 gram of plasma,\" 13 Jan 2020. [Online]. Available: https://www.iter.org/newsline/-/3382. [Accessed July 2020].</p> <p>[3] E. W. Sarah Parry Wright, \"Tokamak Additional Heating Power Supplies Literature Review,\" 2020.</p>"},{"location":"modelica/hcd/nini/","title":"Tokamak.HCDSystemPkg.NINI","text":""},{"location":"modelica/hcd/nini/#information","title":"Information","text":"<p>Model of Negative Ion Neutral Injector.</p> <p>This model was modified from Damian King and Elizabeth Surrey's code, used for NBI studies[1]. The original (ENBI.pro) and modified (ENBI_mcannon.pro) versions, along with input parameters and associated excel spreadsheet can be found here: (15) Power Balance Models (B1.6 Power Infrastructure) | Microsoft Teams</p> <p>The model now calculates electrical power usage as a function of heat to plasma. The code was taken from ENBI.pro (see appendix). This is a verified code written in IDL and is written to calculate the power coupled to plasma for a given set of input parameters and a given wallplug power. The code is modified here to output wall plug power usage for a given power coupled to plasma. The model first calculates the number of injectors and beamlines (numInjectors, numBeamlines) required to output the maximum thermal power. This calculation is done using the parameters below:</p> <p>__NBIThermalPowerMaxMW, maxJ, maxDeuteriumCurrent_TotalPulse The model then adjusts beam current in order to give an output power matching the profile it is given.</p> <p>[1] \"Improved Parameterisation of NBI Systems Code\", D. King, E. Surrey, December 2012</p> <p>Appendix 1: ENBI.pro (original IDL code)</p> <pre><code>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;\n;ENBI\n;\n; IDL version of NBI system code ENBI (Efficiency of Neutral Beam Injector)\n;\n;\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;;general inputs;;;;\n\nPRO ENBI,n,input_vary\n\nresult=read_ascii('input.txt')\nall=result.field1\ns=size(all, /dimensions)\nall2=fltarr(s(1))\nall2(*)=all(1,*)\n\nall2(n)=input_vary\n\ncoreDivergence= all2(0)\nhaloDivergence= all2(1)\nbeam_E= all2(2)\nbeamlineLength= all2(3)\ngridArea= all2(4)\next_area= all2(5)\nelectronRatio= all2(6)\nJ= all2(7)\nnumInj_PerLine= all2(8)\nnumBeamlines= all2(9)\n\n;power supply inputs\nextractionVolt= all2(10)\nsuppressionVolt= all2(11)\nfilterVolt= all2(12)\nfilterCurrent= all2(13)\nstripFraction_Laser= all2(14)\nstripVolt= all2(15)\nstripCollected= all2(16)\npowerRF= all2(17)\nefficiencyDC= all2(18)\nefficiencyRF= all2(19)\n\n;laser neutraliser\n\nlaser= fix(all2(20))\n\nefficiencyLaser= all2(21)\nneut_chan_w= all2(22)\nnumChannels= all2(23)\nefficiencyNeutralization= all2(24)\n\n;energy recovery\n\nnegVolt =all2(25)\nnegFraction =all2(26)\nposVolt =all2(27)\nposFraction =all2(28)\nefficiencyPosConverter =all2(31)\n\npowerIncidentals= all2(32)\nstripFraction_Laser= all2(33)\n\n;;;;;;;;;;;;;;;;;;;;;calculations;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\nDeuteriumCurrent_PerLine=ext_area*J\nelectronCurrent_PerLine=DeuteriumCurrent_PerLine*electronRatio\n\nIF (laser EQ 0) THEN stripFraction=stripFraction_Laser*ext_area/0.197 ELSE stripFraction=stripFraction_Laser*ext_area/0.197\nIF (laser EQ 0) THEN neg_RI_frac=0.21 ELSE neg_RI_frac=1-efficiencyNeutralization\nIF (laser EQ 0) THEN pos_RI_frac=0.21 ELSE pos_RI_frac=all2(30)\nIF (laser EQ 0) THEN efficiencyNeutralization=0.58 ELSE efficiencyNeutralization=all2(24)\nIF (laser EQ 0) THEN powerIncidentals=6 ELSE powerIncidentals=all2(32)\n\ncurrentHVPSU=DeuteriumCurrent_PerLine*(1-stripCollected*stripFraction-negFraction*neg_RI_frac*(1-stripFraction))\npowerHVPSU=currentHVPSU*beam_E\nsuppressionCurrent=J*(gridArea-ext_area)\nextractionPower=extractionVolt*electronCurrent_PerLine/(1000.0*efficiencyDC)\nsuppressionPower_PerLine=suppressionCurrent*suppressionVolt/(1000000.0*efficiencyDC)\nfilterPower_PerLine=filterVolt*filterCurrent/(1000000.0*efficiencyDC)\nstripPower_PerLine=stripFraction*stripCollected*stripVolt*DeuteriumCurrent_PerLine/1000.0\ntot_HVP=(powerHVPSU+extractionPower+suppressionPower_PerLine+filterPower_PerLine+stripPower_PerLine)/efficiencyDC\nRFInputPower_PerLine=powerRF/(1000.0*efficiencyRF)\ntot_inj_P=tot_HVP+RFInputPower_PerLine\n\nneg_rec_P=neg_RI_frac*DeuteriumCurrent_PerLine*(1-stripFraction)*negFraction*negVolt/(1000.0*efficiencyDC)\npos_rec_P=pos_ri_frac*DeuteriumCurrent_PerLine*(1-stripFraction)*posFraction*posVolt*efficiencyPosConverter\n\nIF (laser EQ 0) THEN BEGIN\nlaser_P=0\nENDIF ELSE BEGIN\nlaser_P=-55.39*9788*((beam_E*1000000.0)^0.5)*alog(1-efficiencyNeutralization)*neut_chan_w*numChannels/(500.0*efficiencyLaser*1000000)\nENDELSE\n\n\ntot_in_P=tot_inj_P+laser_p+neg_rec_p+powerIncidentals-pos_rec_p\n\ntransmit_p=DeuteriumCurrent_PerLine*beam_E*(1-stripFraction)\ndi_loss_NH=(0.0122*coreDivergence^2.0)-0.0708*coreDivergence+0.1029\ndi_loss_H=(0.0102*coreDivergence^2.0)-0.0496*coreDivergence+0.0711\n\nhaloDivergence=fix(haloDivergence)\nIF (haloDivergence EQ 0) THEN di_loss=di_loss_nh ELSE di_loss=di_loss_h\n;IF (coreDivergence LT 3.1) THEN di_loss=0 ELSE di_loss=di_loss\n\nlossReionisation_Laser=0.01*(ext_area/0.2)*(beamlineLength/23.0)*(2.0/3.0)*numInj_PerLine\nlossReionisation_NoLaser=0.05*(ext_area/0.2)*(beamlineLength/23.0)*(2.0/3.0)*numInj_PerLine\nIF (laser EQ 0) THEN lossReionisation=lossReionisation_NoLaser ELSE lossReionisation=lossReionisation_Laser\n\nlossTransmission=lossReionisation+di_loss\n\np_to_p=DeuteriumCurrent_PerLine*beam_E*(1-stripFraction)*(1-lossTransmission)*efficiencyNeutralization*numInj_PerLine\n\nprint,'Power out = ', p_to_p\nprint,'Power in = ', tot_in_p\n\nwallplug=p_to_p/tot_in_p\n\nprint,'wallplug = ', wallplug\n\nSAVE,filename='temp.sav'\nEND\n</code></pre>"},{"location":"modelica/hcd/rf_gyrotron/","title":"Tokamak.HCDSystemPkg.RF.Gyrotron","text":""},{"location":"modelica/hcd/rf_gyrotron/#information","title":"Information","text":"<p>Model of an RF Gyrotron</p>"},{"location":"modelica/hcd/rf_gyrotron/#model-description-and-method","title":"Model Description and Method","text":"<p>This model is based on the design of a 170GHz 1.5MW Grotron by Kalaria &amp; Kartikeyan [1, 2]. </p> <p>The Gyrotron model is broken down into three sub-models, namely </p> <ul> <li>Magntron Injection Gun (MIG) model</li> <li>Beam model</li> <li>RF coil model. </li> </ul> <p>The electrical power delivered to the Gyrotron is the product of its efficiency and the RF power delivered to the plasma via the Waveguide. The efficiency of the Gyrotron is estimated as the product of the efficiencies of the sub-models (that make up the Gyrotron) based on their design parameters or configuration. The default values used to calculate the efficiency of the sub-models were taken from the design described in [2].</p> <p>References</p> <p>[1] S. Stewart, \"Modelling of Radio Frequency Heating and Current Drive Systems for Nuclear Fusion,\" 2020.</p> <p>[2] P. C. Kalaria, M. V. Kartikeyan and M. Thumm, \"Design of 170GHz, 1.5-MW Conventional Cavity Gyrotron for Plasma Heating,\" IEEE Transactions on Plasma Science, pp. 1522-1528, 2014. </p>"},{"location":"modelica/hcd/rf_waveguide/","title":"Tokamak.HCDSystemPkg.RF.WaveGuide","text":""},{"location":"modelica/hcd/rf_waveguide/#information","title":"Information","text":"<p>Model of Waveguide Network </p>"},{"location":"modelica/hcd/rf_waveguide/#model-description-and-method","title":"Model Description and Method","text":"<p>The Waveguide network transmits RF power from the Gyrotron to the plasma. Due to the tight space in tokamaks, RF power is usually transmitted over a long distance up to 100 meters at low losses. However, there are sources of power loss in the Waveguide which are:</p> <ul> <li>Coupling losses in and out of waveguide (both = 1.9%)</li> <li>Reflections at chemical vapour deposition windows (CVD loss) (0.3%)</li> <li>Launcher losses (1.0%)</li> <li>Mitre bend losses (calculated as 3.46%)</li> <li>Attenuation introduced by the mode converters (calculated as 1.39e-6%)</li> </ul> <p>The values were the default values for a 7 mitre bend, 100m length, 45mm diameter at 110GHz waveguide (WG45) [1, 2]. The efficiency of the Waveguide network is obtained from the difference of all the losses from that of an ideal waveguide network. </p> <p>The RF power into the Waveguide network is calculated by multiplying the efficiency and the RF heating power delivered to the plasma by the Waveguide. </p> <p>References</p> <p>[1] S. Stewart, \"Modelling of Radio Frequency Heating and Current Drive Systems for Nuclear Fusion,\" 2020.</p> <p>[2] S. Alberti, T. P. Goodman and et al., \"An ITER relevant evacuated waveguide transmission system for the JET-EP ECRH project,\" Nuclear Fusion, vol. 43, pp. 1-14, 2003. </p>"},{"location":"modelica/magnet/basemagnet/","title":"Magnets.BaseMagnet","text":"<p>A partial model to act as a platform on which specialized magnet systems can be built.</p>"},{"location":"modelica/magnet/basemagnet/#extended-by","title":"Extended By","text":"<ul> <li>TF_Magnet</li> <li>PF_Magnet</li> </ul>"},{"location":"modelica/magnet/basemagnet/#information","title":"Information","text":"<p>The following is the base magnet model. From this partial model, the TF and PF magnets are extended, and theoretically any other magnet system could be extended as well.</p> <p>The model does not consider temperature and field variations, and it does not consider any standard coil protection schemes such as FDUs.</p>"},{"location":"modelica/magnet/basemagnet/#input","title":"Input","text":"<p>The input <code>i_in</code> is intended to come in as a predefined signal (see MagnetPower), and a SignalCurrent block is used to translate this signal into a current for our system.</p>"},{"location":"modelica/magnet/basemagnet/#power-supply","title":"Power Supply","text":"<p>Given the required fidelity and detail of the model, we do not have to model the behaviour of an AC-DC converter. In fact, our input signal is already a DC current generated by a comverter somewhere upstream, outside the model. Should the behaviour of an AC-DC converter need to be modelled, this can be done in a separate model.</p> <p>With the above in mind, we have used a ConstantVoltage component to emulate the voltage drop (and thus power consumption) of a power converter. The relevant iinput here is <code>__Vdrop</code> which, multiplied by two, gives a rough estimate.</p> <p>This means our power supply unit does not consider the relationship between output current and voltage drop, and is 'always on'.</p>"},{"location":"modelica/magnet/basemagnet/#feeder","title":"Feeder","text":"<p>The feeder for this system assumes one of two options - a resistive (default) using the basic Resistor component, and a superconducting option using the custom SuperconLayer. It can be thought of as the description of the busbars and feeders that link the power converter with the coils. However, capacitance and inductance are ignored. The input for a resistive feeder is <code>__Rfeeder</code>.</p>"},{"location":"modelica/magnet/basemagnet/#coil","title":"Coil","text":"<p>As with the feeder, the user may choose either a resistive (default) using the basic Resistor component, and a superconducting option using the custom SuperconLayer. The input for a resistive coil is <code>__Rcoil</code>.  Here we can also model the inductance of the coil, set by assigning a value to Lself. (right now the value cannot be set externally, define a new parameter in the extended model and assign it during declaration). Inductor saturation is not considered, and coupling between the coil and external structures may be included as part of the inductance value. Eddy currents are not considered.</p> <p>The joints here are set as a separate Resistor. Their resistance Rjoint may, for now, only be set within the model (but as with Lself, you may make it equal to an externally-accessible parameter in an extended model).</p>"},{"location":"modelica/magnet/basemagnet/#coolant-flow","title":"Coolant flow","text":"<p>The variable Hflow is the total mass flow rate of cryogenic helium through heat exchangers on magnet coil feeders. The flow rate is proportional to the current rating of the feeder, which is given by <code>__maxcurrent</code> (due to the scaling of cross section with current rating. The constant of proportionality __Feeder_m is taken from [1] for a 50K HTS current feeder (see p85).</p>"},{"location":"modelica/magnet/basemagnet/#outputs","title":"Outputs","text":"<p>The model outputs are:</p> Variable Description <code>P_amb</code> The heating power dissipated in the air (the loss in the power supply basically) <code>P_cryo</code> The heating power loss at cryogenic temperature (pretty much all losses other than the power supply) <code>P_tot</code> The total electrical power required to run the system <code>Hflow</code> Coolant flow."},{"location":"modelica/magnet/basemagnet/#parameters","title":"Parameters","text":"<p>The following are the remaining parameters that this base model needs (reminder that a double underscore <code>__</code> indicates a parameter that can be modified externally to Modelica):</p> Parameter Description <code>__nTurn</code> Number of turns in one coil. <code>JpTurn</code> Number of joints per turn. <code>__numCoils</code> Number of coils in the system. <code>__maxCurrent</code> Maximum anticipated operating current per turn. <code>__coilLength</code> The length of one coil."},{"location":"modelica/magnet/basemagnet/#choosing-between-resistive-and-superconducting-models","title":"Choosing between resistive and superconducting models","text":"<p>The feeder and coil models use \"conditional components\" to select the type of conductor based on boolean parameters <code>isSuperconCoil</code> and <code>isSuperconFeeder</code>. This selection is done during compilation and therefore you cannot select the other option after the model has been compiled. The components and connections of the \"other\" conductor material are completely ignored and simply do not exist in the compiled version of the model. As such, you may be able to see that some connections appear \"doubled-up\" - in order to make sure everything is properly connected when an option is selected.</p>"},{"location":"modelica/magnet/basemagnet/#superconductor-scaling","title":"Superconductor scaling","text":"<p>At present, the hysteresis model is simulating flux/length \\(Wb/m\\) in one BSCCO tape with the following characteristics:</p> <ul> <li>\\(I_c = 16.85\\:\\mathrm{A}\\)</li> <li>\\(n = 20\\)</li> <li>\\(R_{\\mathrm{normal}} = 1\\times10^8\\:\\Omega\\mathrm{/m}\\)</li> </ul> <p>and hysteresis parameterization as given in <code>Superconductor.Data.HTS_EverettParameter</code>. There is a need to scale that to fit a full-size cable. It is assumed that there are n number of tapes all connected in parallel and the value of n is found by dividing the maximum operating current by the product of the critical current of the tape and the safety factor, e.g. n = current / (safety factor * critical current). The voltage drop across each tape is obtained by multiplying the flux/length by the length of the cable (coil or coil system circumference times number of turns). der(flux/length * length) equals voltage. The power loss is calculated for each tape and then summed up for all of them.</p> <p>This is a crude assumption and should not be used past some preliminary investigation stage.  At the very least, better data should be used, but current-flux relationship characterizations are rare in literture.</p>"},{"location":"modelica/magnet/basemagnet/#references","title":"References","text":"<p>[1] Tanna, V. L. 'Design and Analysis of the Superconducting Current Feeder System for the International Thermonuclear Experimental Reactor (ITER)', October 2006</p>"},{"location":"modelica/magnet/basemagnet/#warnings","title":"Warnings","text":"<p>Translation warnings</p> <p>Building the model may produce a Translation Warning: <pre><code>Conditional component 'resistiveCoil'/superconCoil is used in a non-connect context.\n</code></pre> This warning can be safely ignored. There is no way to \"fix\" it and it does not affect performance.</p>"},{"location":"modelica/magnet/basemagnet/#revisions","title":"Revisions","text":"Date Comment Authors 2021-03-11 Documentation created and model updated Alexander Petrov 2020-08-31 Initial model implemented Samuel Stewart, Finlay Christie, Katherine Rochford, Sophie Gribben"},{"location":"modelica/magnet/magnetpower/","title":"Magnets.MagnetPower","text":"<p>The 'control' model that brings all coils together.</p>"},{"location":"modelica/magnet/magnetpower/#assumptions","title":"Assumptions","text":"<ul> <li>The resistance is assumed to be 100% dissipated in the Joints</li> <li>Eddy Currents are not considered</li> <li>Input is assumed dominant and mutual inductance are included as a nominal constant</li> <li>Saturation of the Inductor is not considered</li> <li>Temperature of the resistor and inductor are assumed to be constant</li> <li>Ground resistance and FDU resistance are not considered</li> <li>6 PF coils assumed but this is a very tenuous assumption</li> </ul> <p>S - Complex Power (is not actually AC complex power but a summation of real power dissipated and stored in the inductors)</p>"},{"location":"modelica/magnet/mutual_inductor/","title":"Magnets.Superconductor.MutualInductor","text":"<p>Implementation of two basic inductors together with a mutual inductance between them.</p>"},{"location":"modelica/magnet/mutual_inductor/#information","title":"Information","text":"<p>The model of mutual inductance here is taken in the simplest form in terms of circuit theory:</p> <p>\\(V1 = L_1\\frac{di_1}{dt} + M\\frac{di_2}{dt}\\)</p> <p>\\(V2 = L_2\\frac{di_2}{dt} + M\\frac{di_1}{dt}\\)</p> <p>The upper inductor is taken as '1' and the lower inductor is taken as '2'.</p> <p>Customization is fairly easy to include more than 2 inductors depending on modeling needs.</p>"},{"location":"modelica/magnet/mutual_inductor/#revisions","title":"Revisions","text":"<ul> <li>2021 by Alexander Petrov (credit due to the creators of the TwoPort and Transformer classes), initially implemented</li> </ul>"},{"location":"modelica/magnet/pfcoil/","title":"Magnets.PF_Magnet","text":"<p>A specialized magnet model for a Poloidal Field (PF) coil system</p>"},{"location":"modelica/magnet/pfcoil/#extends","title":"Extends","text":"<ul> <li>BaseMagnet</li> </ul>"},{"location":"modelica/magnet/pfcoil/#information","title":"Information","text":"<p>Most notably the superconductor coil is set to true by default. Resistances have been set to very low values. Only one coil per component.</p>"},{"location":"modelica/magnet/pfcoil/#revisions","title":"Revisions","text":"Date Comment Authors 2021-03-11 Documentation added and model implemented. Alexander Petrov"},{"location":"modelica/magnet/preisach_everett/","title":"Magnets.Superconductor.Hysteresis.PreisachEverett","text":"<p>Superconductor I-Phi(V) hysteresis based on the Preisach model and Everett function data</p>"},{"location":"modelica/magnet/preisach_everett/#information","title":"Information","text":"<p>An I-V model of superconducting hysteresis using the Preisach hysteresis model with an Everett function.</p> <p>The details surrounding the Presiach model implementation in Modelica (for ferromagnetism) can be found in the OpenModelica documentation for Preisach-Everett hysteresis. The majority of this code is an adapted version of GenericHystPreisachEverett that makes it possible to work in an electric circuit using current as an input and magnetic flux as output. The derivative of the magnetic flux is the voltage.</p> <p>The Everett function is specified as a set of parameters through the HTS_EverettParameter data record. Different parameters may be set by either modifying the record file or setting a different file path for the 'mat' parameter on input.</p> <p>NOTE: Take care with solver tolerance and time steps when attempting to model very small fluxes - a tolerance of 1e-10 or 1e-12 offers better results.</p> <p>More information about Preisach and its use for superconductor hysteresis modelling can be found here:</p> <p>M. Sjostrom, B. Dutoit, and J. Duron, 'Equivalent circuit model for superconductors', IEEE Transactions on Applied Superconductivity, vol. 13, no. 2, pp. 1890\u20131893, Jun. 2003, doi: 10.1109/TASC.2003.812941. M. Sjostrom, 'Hysteresis modelling of high temperature superconductors', Infoscience, 2001. http://infoscience.epfl.ch/record/32848 (accessed Jan. 29, 2021).</p>"},{"location":"modelica/magnet/preisach_everett/#revisions","title":"Revisions","text":"<ul> <li>by OpenModelica (the authors of GenericHystPreisachEverett, and all the classes this model extends as well as the authors of OnePort, and Ferenc Preisach, without all of whom this superconducting variant of the Presiach-Everett model would not have been possible)</li> <li>Jan 2021 by Alexander Petrov. Modified the model for use in an electrical system.</li> </ul>"},{"location":"modelica/magnet/supercon_layer/","title":"Magnets.Superconductor.SuperconLayer","text":"<p>A model that can simulate a single superconducting tape or strand</p>"},{"location":"modelica/magnet/supercon_resistive/","title":"Magnets.Superconductor.SuperconResistive","text":"<p>Resistive model of a superconductor's I-V relationship, employing a macroscopic power law.</p>"},{"location":"modelica/magnet/supercon_resistive/#information","title":"Information","text":"<p>The model simulates the I-V relationship of a superconductor based on a macroscopic power law (instead of critical current density and electric field, critical current and voltage are used). At about 1.2x Ic and higher this I-V macroscopic characteristic becomes dominant and the hysteresis may be neglected; otherwise the hysteresis is dominant and instead this I-V characteristic may be neglected.</p> <p>Inputs are the critical current, power exponent and normal state resistance. The critical current criterion is set to 1e-4 V/m whch should not normally be changed. Change the length to achieve the desired voltage.</p>"},{"location":"modelica/magnet/supercon_resistive/#revisions","title":"Revisions","text":"<ul> <li>by OpenModelica (class OnePort)</li> <li>2020 by Alexander Petrov (credits due to J Rhyner who developed the Power Law model) initially implemented</li> </ul>"},{"location":"modelica/magnet/tfcoil/","title":"Magnets.TF_Magnet","text":"<p>A specialized magnet model for a Toroidal Field (TF) coil system.</p>"},{"location":"modelica/magnet/tfcoil/#extends","title":"Extends","text":"<ul> <li>BaseMagnet</li> </ul>"},{"location":"modelica/magnet/tfcoil/#information","title":"Information","text":"<p>This model focuses on use for the toroidal field coil. The values for the joint resistances are from latest known experimental results.</p>"},{"location":"modelica/magnet/tfcoil/#revisions","title":"Revisions","text":"Date Comment Authors 2021-03-11 Documentation added and model implemented. Alexander Petrov"},{"location":"modelica/powergen/equations/","title":"PowerGenEquations.mo","text":""},{"location":"modelica/powergen/equations/#information","title":"Information","text":"<p>This model calculates the efficiency of power conversion (plasma heat - electrical power) in the system. It's inputs are the primary coolant, secondary coolant, compression ratio, operating pressure and thermal power, and it's output is the electrical power generated.</p>"},{"location":"modelica/powergen/equations/#modelling-methodology","title":"Modelling Methodology","text":"<p>The Power Generation modelling has been based on the excel power generation model created as part of internal UKAEA work.</p> <p>30 different relevant scenarios were identified according to the following criteria:</p> <ul> <li>Different primary coolants </li> <li>Different secondary coolants </li> <li>Different compression ratios or operating pressures (depending on secondary coolant chosen). </li> </ul> <p>Each scenario was evaluated to develop an equation relating reactor operating temperature (ie primary fluid reactor outlet temperatures) to total loop efficiency. Total loop efficiency considers the power consumption from 1st, 2nd and 3rd loops (excluding tritium related equipment and any power consumption within the boundaries of reactor).  </p>"},{"location":"modelica/turbopump/pumps/","title":"TurboMolecularPump.mo","text":""},{"location":"modelica/turbopump/pumps/#summary","title":"Summary","text":"<p>Turbopumps will be used directly to achieve the low pressures required in the torus vacuum vessel. Many turbopumps in parallel are required to achieve the low pressure at the required flow rates. The turbopumps are backed by multiple booster stages and roughing (screw) pumps. The main power considerations are the electrical load required to run the various pumping stages in series.</p> <p>The model takes the thermal power as an input, and outputs the electrical power required to run the pumps.</p>"},{"location":"modelica/turbopump/pumps/#main-equations","title":"Main Equations","text":"<ul> <li> <p>Required flowrate (m<sup>3</sup> / sec) = molar flow per GW (mol / s.GW) * thermal power (GW) * 8.314 (m^3.Pa / K.mol) * T (\u00b0K) / (Pressure (mbar) * 100 (Pa / mbar))</p> </li> <li> <p>Turbo power (kW) = SinglePump power (W) * 0.001 * Required flowrate / single pump flowrate</p> </li> </ul>"},{"location":"modelica/wasteheat/wasteheat_package/","title":"WasteHeat.mo","text":""},{"location":"modelica/wasteheat/wasteheat_package/#information","title":"Information","text":"<p>Package containing the waste heat Management system object (WasteHeatSystem) and model for the power load of waste heat management of Magnets, H&amp;CD, Cryo and WaterDetrit (WasteHeatPower).</p>"},{"location":"modelica/wasteheat/wasteheat_package/#model-description-and-method","title":"Model Description and Method","text":"<p>The purpose of this model is to extract the waste heat from the air. It does this by taking in waste power from other models and performing a cooling with dehumidification calculation.</p> <p>The settable user input values for this model are given, alongside their default values:</p> <ul> <li>Waste power from other models (1000 W)</li> <li>Width of room </li> <li>Efficiency of Waste Heat system (0.8)</li> <li>simulation stop time (60 s)</li> </ul>"},{"location":"modelica/wasteheat/wasteheat_package/#assumptions","title":"Assumptions","text":"<ul> <li>Cooling with Dehumidification process</li> <li>Steady flow process</li> <li>mass flow rate of air constant</li> <li>Air behaves and an ideal gas</li> <li>Kinetic energy and Potential energy negligible</li> <li>Heat transfer through floor is negligible</li> <li>If the waste power is under 5000 W, the dehumidification calculation is disregarded. This is due to several reasons.<ul> <li>The temperature difference is calculated using the waste power, and at low powers this can be very small.</li> <li>The mass flow rate of the moisture in the air is calculated as a fraction of the mass flow rate of the air, and at these low powers it would dominate the calculation and give a negative overall power.</li> </ul> </li> </ul>"},{"location":"modelica/wasteheat/wasteheat_system/","title":"WasteHeat.WasteHeatSystem","text":""},{"location":"modelica/wasteheat/wasteheat_system/#information","title":"Information","text":"<p>Model of the power loads of the Waste Heat Management (formerly HVAC) system - takes in waste heat from other models and performs cooling with dehumidification calculation.</p>"},{"location":"modelica/wasteheat/wasteheat_system/#assumptions","title":"Assumptions","text":"<ul> <li>Cooling with Dehumidification process</li> <li>Steady flow process</li> <li>mass flow rate of air constant</li> <li>Air behaves and an ideal gas</li> <li>Kinetic energy and Potential energy negligible</li> <li>Heat transfer through floor is negligible</li> <li>If the waste power is below 5000 W dehumdifying is neglected due to small change in temperature. </li> </ul>"},{"location":"modelica/waterdetrit/waterdetrit_package/","title":"WaterDetritiation.mo","text":""},{"location":"modelica/waterdetrit/waterdetrit_package/#information","title":"Information","text":"<p>The input is the thermal power and the output is the electrical power required.</p>"},{"location":"modelica/waterdetrit/waterdetrit_package/#description-and-method","title":"Description and Method","text":"<p>There are three types of power load involved. The Thermal Power, the Electrical Power and the Negligeable Power Load. The development of this system is to control the tritium content in the diverging streams to minimize the power usage. This is completed by thermal power being pumped in to the Liquid Phase Catalytic Exchange or LPCE in this diagram. The electrical power loads include the electrical power for electrolysis and the potential electrical load on the compression of gases around the permeator. There are more models to predict the time this process takes but the overall goal will separate the clean water and the tritiated water into separate streams.</p> <p>There are 4 models included in this water detritiation package:</p> <ul> <li>Electrolysis Energy<ul> <li>Electrolysis Power (kW) = Flowrate (kg/s) * Electrolysis power consumption (kJ / kgH20)</li> </ul> </li> <li>Water Heating<ul> <li>Heating Power (kW) = Flowrate (kg/s) * (reflux ratio * heat capacity (kJ/kg.\u00b0C ) * (Target T (\u00b0C) - Ambient T (\u00b0C)) + latent heat of vaporisation * vapour fraction)</li> </ul> </li> <li>Gas Compression<ul> <li>Compressor energy (kW) = compressor work (kJ/kg) * hydrogen flowrate (kg/s)</li> </ul> </li> <li>Total Contingency<ul> <li>Electrolysis Power + Water heating + compressor work</li> </ul> </li> </ul>"},{"location":"modelica/waterdetrit/waterdetrit_package/#assumptions","title":"Assumptions","text":"<ul> <li>Thermal Power exiting the reactor - 1GW</li> </ul>"},{"location":"coverage/","title":"Coverage","text":""}]}